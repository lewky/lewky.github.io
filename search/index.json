[{"categories":["cmd"],"contents":"常用命令 1 2 3 4 5 6 7 8 # 删除目录下的所有文件（无法删除文件夹） del /q D:\\projects\\lewky\\hugo-deploy # 删除目录下所有文件和文件夹（无法删除隐藏文件夹） rd /s /q D:\\projects\\lewky\\lewky-hugo\\public # 拷贝文件夹下所有文件到另一个目录 xcopy .\\public D:\\projects\\lewky\\hugo-deploy /e /y /h /q ","permalink":"https://lewky.cn/posts/cmd-commands/","tags":["cmd"],"title":"cmd - 常用命令"},{"categories":["计算机"],"contents":"常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 # 查询系统信息 uname -a # 查CPU信息 lscpu # 查IP hostname -I # 查日期 date -R # 修改日期 date -s 11/03/2023 date -s 17:55:55 # 查当前用户 whoami # 切root用户，需要root用户密码 su - root # 提升为root权限，需要输入当前用户的密码 sudo -i # 查询内存 free -h // 显示内存单位 free -m // 以MB为单位 # 查询进程 jps ps -ef|grep java grep -v grep // 过滤掉grep自身 pgrep prometheus // 查询当前用户下的Prometheus进程号 ps -ef|grep prometheus.yml |grep -v grep //查询Prometheus进程 # 自动创建需要的上级目录 mkdir -p # zip压缩 zip -p -r deploy.zip deploy/ // 压缩指定目录的文件 zip -p -r deploy.zip * // 压缩当前目录所有文件 # zip解压 unzip deploy.zip // 解压到当前目录 unzip deploy.zip -d deploy/ // 解压到指定目录 # tar压缩，-z表示gzip格式 tar zcvf smart-monitor.tar.gz ./smart-monitor # tar解压，-z表示gzip格式 tar zxvf smart-monitor.tar.gz // 解压到当前目录 tar zxvf smart-monitor.tar.gz -C ./smart-monitor // 解压到指定目录 # gzip解压 gzip -d xx.gz # 查询网络、端口 ssh -v ip -p port nc -vz -w 2 ip port telnet ip port netstat -anp|grep port # sftp，-r表示递归 sftp user@ip cd xx // 切换到xx目录 put xx // 传输xx文件到远程机器当前目录 put -r deploy deploy // 将deploy目录的所有文件都传输到远程机器的deploy目录 get xx // 下载远程机器的xx文件到本地 exit // 退出sftp # 移动文件，可用于重命名 mv source target # 删除文件 rm xx rm -rf xx // 递归删除，慎用 # 搜索文本关键字 grep -rn apollo.token /home/test/apps/config/config.properties // 搜索到的关键字所在行会回显在控制台 grep -rl apollo.token /home/test/apps/config/config.properties // 只会把搜索到的文件名回显在控制台 # 搜索文件 find ./ -name client.jar* # CPU时间使用统计 top // top里的时间是分:秒 ps -ef // ps里的时间是时:分:秒 # 挂起信号，让进程重新加载配置文件 kill -1 xxx // 让进程退出，不要用-9 kill -15 xxx kill -9 `ps -ef|grep prometheus-2.34.0.linux-amd64|grep -v grep|awk \u0026#39;{print $2}\u0026#39;` \u0026amp;\u0026amp; sleep 10 # 查询使用过的命令 history history|grep start # 改权限 chmod -R 755 client.jar # 安装，需root yum install perl // 卸载 yum remove perl # 查看安装软件 yum list installed|grep perl # curl curl -H \u0026#34;Content-Type: application/json\u0026#34; -X GET -d \u0026#39;{\u0026#34;body\u0026#34;:\u0026#34;test123\u0026#34;}\u0026#39; \u0026#34;http://localhost:1234/test\u0026#34; curl -H \u0026#34;Content-Type: application/json\u0026#34; -X POST -d \u0026#39;{\u0026#34;body\u0026#34;:\u0026#34;test123\u0026#34;}\u0026#39; \u0026#34;http://localhost:1234/test\u0026#34; curl -H \u0026#34;Content-Type: application/json\u0026#34; -X POST -d @test.json \u0026#34;http://localhost:1234/test\u0026#34; // 读取指定文件内容作为body # 实时日志 tail -f -n 50 xx.log # 塞满磁盘 /dev/urandom // 伪随机，但不阻塞 /dev/random // 真随机，但阻塞 /dev/zero // 初始化 dd if=/dev/zero of=/home/apps/logs/test/filldisk bs=1M count=1G // 用1G个1M大小的块文件塞满指定磁盘 # 查看磁盘 df -h du -h du -d 1 -h // 统计深度为1的目录大小 # 防火墙 firewall-cmd --state systemctl start firewalld.service systemctl stop firewalld.service systemctl restart firewalld.service # 查看文件编码 file -i common.log # 进入vi后再查看编码 vi common.log :set fileencoding # docker，需root用户 docker ps // 查看docker内的进程 docker exec -it xxxx bash // 进入docker部署的进程 # 远程连接机器时指定秘钥算法 ssh -c 3des-cbc user@ip # 查看系统日志 /var/log/messages // messages日志可能滚动成多个同名日志 # aix机器可以用bash来使用便捷命令 bash # 统计行数 netstat -anp|grep 9080|grep ESTABLISHED|wc -l netstat -anp|grep 9080|grep TIME_WAIT|wc -l # 边车OOM无法新建SkyWalking进程 # 查看当前用户下的max user processes数量，改大为4096 ulimit -a cd /etc/security/limits.d/ // 需要修改当前目录下的文件 ls vi 90-nproc.conf // 下面是文件内的内容 * soft nproc 4096 root soft nproc unlimited # 改密码，需要root passwd # 指定修改emsp用户的密码 passwd emsp # 在根目录查看环境变量脚本（隐藏文件） ls -lrta .bash_profile # 设置环境变量 . .bash_profile ","permalink":"https://lewky.cn/posts/linux-commands/","tags":["工作记录","Linux"],"title":"Linux常用命令"},{"categories":["生活"],"contents":"深海与月光 耳边似乎还回响着水母之歌的旋律，笨拙的水母退场离开了舞台，顶碗人也不会忘记深海里曾经的那一束白月光。\n别了，向晚。\nA-Soul向晚\r","permalink":"https://lewky.cn/posts/asoul-ava/","tags":["A-Soul"],"title":"别了，向晚"},{"categories":["生活"],"contents":"攻略 可以提前说不要配菜 披萨可以论角上，口味还可以，推荐榴莲披萨、乳酪大会、超级至尊。 意面之类的，类似于热干面换成了意面 惠灵顿牛排，份量挺大的，没体验过的可以点一份多人一起吃 雪糕黑天使、草莓天使，其实就是可乐上面加奶油和冰淇淋 肋眼、西冷牛排，肋眼口感更好，适合点来冲单价，不过品质一般，不太推荐。牛排可以提前说不要配菜。 鸡块，相当于大号鸡米花，可以点 凤尾虾，必点 雪域，奶油蛋糕，还有抹茶口味，招牌甜品，喜欢甜品的必点 鱿鱼圈，一般 小龙虾麻辣口味优于咸蛋黄口味，要注意有没有开背，没开背不建议点。另外小龙虾底下会有通心粉，可以提前说不要加通心粉。好吃可点。 脆皮虾，好吃可点。 卡曼橘，饮品，还行。 总结：虾类、甜品、披萨都挺不错，孜然、百草飘香鸡块也可以各点一份，其他的见仁见智。\n点餐限时90分钟，吃东西不限时，吃不完不会罚款，放心大胆造。\n","permalink":"https://lewky.cn/posts/bishengke/","tags":["美食"],"title":"必胜客自助餐"},{"categories":["分布式组件"],"contents":"前言 APM系统即Application Performance Management应用性能管理，目的是对企业的关键业务系统进行实时性能监控和故障管理，主要有以下三个维度：日志聚合Logs、业务指标Metrics、链路跟踪Traces。\n在现今很流行的分布式架构微服务系统中，主流的APM系统组件：日志聚合可以使用ELK Stack，业务指标采用Prometheus，链路跟踪使用SkyWalking。比如新时代的银行业务系统需要上云，日志往往采用云服务商提供的日志聚合平台（如阿里云的SLS、腾讯云的CLS）。\n架构理解 Prometheus基于HTTP的Pull方式采集时序数据，由Go语言编写，其总体架构分为三层：采集层、存储计算层、应用层。\n这里的Pull指的是指标抓取模型，还有对应的Push模型，其区别在于被监控服务是否主动将指标数据推送到监控服务。\n在Prometheus的Pull模型中，每一个被Prometheus监控的服务都是一个job。被监控服务一般通过主动暴露metrics端口，或通过exporter方式暴露指标metrics_path，监控服务通过服务发现模块发现被监控服务，从而定期抓取业务指标（如性能，交易量，交易成功率等）。\n存储计算层 分为两部分：Prometheus server服务端，Service discovery服务发现。\nPrometheus server：存储计算层的核心，包含了存储引擎和计算引擎，有以下三大组件。\nRetrieval：取数组件，会主动从Pushgateway或者jobs/exporters拉取指标数据。 TSDB：时间序列数据库，属于内存数据库，负责存储采集到的时序数据。指标数据以时间序列的形式保存在内存中，并且定时刷到磁盘节点（HDD/SSD）上，默认是两个小时回刷一次。并且为了防止Prometheus发生崩溃或重启时能够恢复数据，Prometheus也提供了类似MySQL中binlog一样的预写日志，当Prometheus崩溃重启时，会读这个预写日志来恢复数据。 HTTP server：对外提供HTTP服务。 Service discovery：可以动态发现要监控的目标，支持多种服务发现协议：kubernetes_sd、file_sd等。\n采集层 分为两类：一类生命周期较短的作业，一类生命周期较长的作业。\n1）短作业：直接通过API（比如Java的MetricsServlet），在退出时（比如Flink）将指标推送给Pushgateway，Retrieval组件再从Pushgateway拉取指标数据。\n2）长作业：Retrieval组件直接从jobs或exporters拉取指标数据，jobs或exporters在Prometheus中属于targets，即采集目标。\n应用层 分为两种：负责数据可视化、导出的Prometheus web UI，负责告警的Alertmanager。\n1）Alertmanager：当PromeQL查询的指标超过Rules文件定义的阈值时，Prometheus会发出一条告警到Alertmanager，manager会将告警下发到配置好的钉钉、微信、邮件等进行告警。\n2）Prometheus web UI：官方提供的可视化界面，通过PromQL查询语言来查询指标。也可以使用其他组件进行查询，如Grafana、API Clients。\n安装与配置 可以从官网下载自己需要的组件服务：https://prometheus.io/download/\nprometheus是必备的服务（即Prometheus server），其他的诸如告警alertmanager、采集blackbox_exporter / node_exporter / pushgateway等自行选择是否需要下载安装，下载后解压开来即可使用。\nprometheus服务只有一个配置文件prometheus.yml，初始配置分为三部分：\n1）global全局配置模块：\nscrape_interval：拉取数据的时间间隔，默认为1分钟。 evaluation_interval：规则验证（生成alert）的时间间隔，默认为1分钟。 2）alerting和rule_files告警配置模块。\n3）scrape_configs抓取配置模块。Prometheus自身运行信息可以通过HTTP访问，所以Prometheus可以监控自身的运行数据。\njob_name：监控作业的名称。 static_configs：静态目标配置，固定从某个target拉取数据。 targets：指定监控的目标，Prometheus会从配置的target采集指标数据。 Prometheus支持动态更新配置，在启动Prometheus时添加--web.enable-lifecycle启动参数即可开启该功能：\n1 prometheus --config.file=/usr/local/etc/prometheus.yml --web.enable-lifecycle 之后无需重启Prometheus，可以通过HTTP服务来通知Prometheus重新加载最新配置：\n1 curl -v --request POST \u0026#39;http://localhost:9090/-/reload\u0026#39; PromQL 查询时间序列 范围查询 时间位移操作 聚合操作 标量和字符串 合法的PromQL表达式 操作符 参考链接 【尚硅谷】Prometheus+Grafana+睿象云的监控告警系统 监控神器：Prometheus 轻松入门，真香！ ","permalink":"https://lewky.cn/posts/prometheus-start/","tags":["Prometheus"],"title":"Prometheus简易入门"},{"categories":["杂谈"],"contents":"无法保存密码 在升级Chrome后原本正常的保存密码功能忽然失效，此时就算手动添加、导入密码都无法成功保存密码，暂不清楚原因，但有以下方式可以解决该问题：\n在地址栏输入chrome://version/，找到个人资料路径，比如本人目录是C:\\Users\\XXX\\AppData\\Local\\Google\\Chrome\\User Data\\Default。 打开该目录，将当前目录下的两个文件：Login Data和Login Data-journal删除（别关闭当前的浏览器）。 此时回到浏览器你会发现可以正常保存、导入、修改、添加密码，但是在重启浏览器后有可能依然触发无法保存密码的问题，此时只能重复上述两个步骤。如果不幸每次重新启动浏览器都这样，同时又需要新增保存的密码，可以先导出当前保存的所有密码，然后再重复上述前两个步骤，然后再导入密码，接着就可以继续新增密码了。 参考链接 已解决:mac下Chrome浏览器保存密码后无法填充 ","permalink":"https://lewky.cn/posts/chrome-issues/","tags":["Chrome"],"title":"Chrome问题汇总"},{"categories":["工作记录"],"contents":"no matching host key type found. Their offer: ssh-dss 使用SSH登录时报错如下：\n1 Unable to negotiate with 20.1.1.174 port 22: no matching host key type found. Their offer: ssh-dss 报错原因是OpenSSH7.0之后不再支持ssh-dss算法，可以通过添加参数-oHostKeyAlgorithms=+ssh-dss来支持该算法：\n1 sftp -oHostKeyAlgorithms=+ssh-dss -i id_rsa test@20.1.1.174 Permissions 0644 for \u0026lsquo;id_rsa\u0026rsquo; are too open 使用SSH登录时报错如下：\n1 2 3 Permissions 0644 for \u0026#39;id_rsa\u0026#39; are too open. It is required that your private key files are NOT accessible by others. This private key will be ignored. 这个报错是因为id_rsa是私钥文件，属于敏感文件，不能开放权限给其他用户组，哪怕是只读也不行，在缩小权限之前该私钥文件将一直被忽略。\n通过赋予该文件400或600的权限即可成功登陆SSH：\n1 2 chmod 400 id_rsa chmod 600 id_rsa 参考链接 no matching host key type found. Their offer: ssh-dss,ssh-rsa 【web渗透】私钥ssh远程登录报错：permission 0644 for ‘id_rsa‘ are too open ","permalink":"https://lewky.cn/posts/ssh-issues/","tags":["SSH命令"],"title":"SSH命令问题汇总"},{"categories":["工作记录"],"contents":"PGP和GPG 对接客户需求时对方使用PGP对文件进行加解密，但PGP是商用的非对称加解密方式，可以改用Apache基金会推出的开源的GPG，两者的加解密可以无缝对接。\nLinux通常自带GPG命令，可以直接使用。\n生成PGP密钥 1 2 3 4 5 6 7 8 9 10 11 12 输入gpg --gen-key 输入1，使用rsa算法 按下回车确定keysize 输入0，表明该密钥永不过期 输入y确定 输入xxx作为名字（请自行指定一个名字） 输入xxx作为邮箱（请自行指定一个邮箱） 按下回车跳过注释 输入o确定 输入私钥密码，后续若想修改密钥或解密需要用到该密码，然后回车确定 再次输入密码，回车确定 移动鼠标来提供随机数以生成密钥 GPG生成密钥的最后一步需要采集随机数，通常此时会卡住无法生成，需要先安装协助生成密钥的工具rng-tools：\napt-get install rng-tools 或 yum install rng-tools\n之后再执行命令，就能在采集随机数时瞬间生成密钥：\n1 rngd –r /dev/urandom 列出已经生成的PGP密钥 -K查询私钥，-k查询公钥，一次只能查询一种密钥。\n1 2 3 4 5 6 // 查询私钥 gpg -K gpg --fingerprint -K --keyid-format long // 查询公钥 gpg -k gpg --fingerprint -k --keyid-format long 这里导出的密钥会附带显示keyId。\nkeyId相当于一对密钥的别名，GPG密钥库里会把每次生成的密钥对都保存进去，因此会用keyId来区分，如果不指定keyId则会全部导出来。后续加解密时使用到密钥库文件其实也会通过keyId来获取对应的密钥对。\n导出PGP密钥 -a即--armor，表示以ASCII格式输出，即Base64串。\n-o即--output FILE，表示写入到文件里。\n–-export导出公钥，–-export-secret-keys导出私钥，后面通过指定keyId导出对应的密钥。\n1 2 3 4 // 导出公钥，97E208A1是keyId gpg –a –o public-file.key –-export 97E208A1 // 导出私钥，97E208A1是keyId gpg -a –o private-file.key –-export-secret-keys 97E208A1 导入PGP密钥 假设公钥文件是public-file.key，私钥文件是private-file.key\n1 2 gpg --import public-file.key gpg --import private-file.key 删除PGP密钥 --delete-keys删除公钥，--delete-secret-keys删除私钥。\n在同时拥有一对公钥和私钥时，需要先删除私钥，才能删除公钥。\n1 2 3 4 // 删除公钥，97E208A1是keyId gpg --delete-keys 97E208A1 // 删除私钥，97E208A1是keyId gpg --delete-secret-keys 97E208A1 Java实现PGP加解密 Java使用openpgp库来实现，pom依赖：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.bouncycastle\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bcprov-jdk15on\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.58\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.bouncycastle\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;bcpg-jdk15on\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.58\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 import org.apache.commons.io.IOUtils; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.bouncycastle.bcpg.ArmoredOutputStream; import org.bouncycastle.bcpg.CompressionAlgorithmTags; import org.bouncycastle.bcpg.HashAlgorithmTags; import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.bouncycastle.openpgp.PGPCompressedData; import org.bouncycastle.openpgp.PGPCompressedDataGenerator; import org.bouncycastle.openpgp.PGPEncryptedData; import org.bouncycastle.openpgp.PGPEncryptedDataGenerator; import org.bouncycastle.openpgp.PGPEncryptedDataList; import org.bouncycastle.openpgp.PGPException; import org.bouncycastle.openpgp.PGPLiteralData; import org.bouncycastle.openpgp.PGPObjectFactory; import org.bouncycastle.openpgp.PGPOnePassSignature; import org.bouncycastle.openpgp.PGPOnePassSignatureList; import org.bouncycastle.openpgp.PGPPrivateKey; import org.bouncycastle.openpgp.PGPPublicKey; import org.bouncycastle.openpgp.PGPPublicKeyEncryptedData; import org.bouncycastle.openpgp.PGPPublicKeyRing; import org.bouncycastle.openpgp.PGPPublicKeyRingCollection; import org.bouncycastle.openpgp.PGPSecretKey; import org.bouncycastle.openpgp.PGPSecretKeyRing; import org.bouncycastle.openpgp.PGPSecretKeyRingCollection; import org.bouncycastle.openpgp.PGPSignature; import org.bouncycastle.openpgp.PGPSignatureList; import org.bouncycastle.openpgp.PGPUtil; import org.bouncycastle.openpgp.jcajce.JcaPGPObjectFactory; import org.bouncycastle.openpgp.operator.PGPDigestCalculator; import org.bouncycastle.openpgp.operator.bc.BcKeyFingerprintCalculator; import org.bouncycastle.openpgp.operator.bc.BcPGPContentVerifierBuilderProvider; import org.bouncycastle.openpgp.operator.bc.BcPublicKeyDataDecryptorFactory; import org.bouncycastle.openpgp.operator.jcajce.JcaKeyFingerprintCalculator; import org.bouncycastle.openpgp.operator.jcajce.JcaPGPContentSignerBuilder; import org.bouncycastle.openpgp.operator.jcajce.JcaPGPDigestCalculatorProviderBuilder; import org.bouncycastle.openpgp.operator.jcajce.JcaPGPKeyPair; import org.bouncycastle.openpgp.operator.jcajce.JcePBESecretKeyDecryptorBuilder; import org.bouncycastle.openpgp.operator.jcajce.JcePBESecretKeyEncryptorBuilder; import org.bouncycastle.openpgp.operator.jcajce.JcePGPDataEncryptorBuilder; import org.bouncycastle.openpgp.operator.jcajce.JcePublicKeyKeyEncryptionMethodGenerator; import org.bouncycastle.util.io.Streams; import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchProviderException; import java.security.SecureRandom; import java.security.Security; import java.util.Date; import java.util.Iterator; /** * PGP加密解密方式 * * @author Administrator */ public class PGPUtils { private static final String PROVIDER_BC = \u0026#34;BC\u0026#34;; private static final String RSA = \u0026#34;RSA\u0026#34;; private static final Log log = LogFactory.getLog(PGPUtils.class); static { if (Security.getProvider(PROVIDER_BC) == null) { Security.addProvider(new BouncyCastleProvider()); } } /** * 生成PGP密钥对 * * @param keySize 生成多少位的密钥，如2048 * @param passPhrase 私钥密码，可为空 * @param identity 公钥的userId * @param pubKeyFile 公钥文件目录 * @param priKeyFile 私钥文件目录 * @param path 文件目录 * @throws Exception */ public static void generatePGPKeyPair(int keySize, String passPhrase, String identity, String pubKeyFile, String priKeyFile, String path) throws Exception { createDirectory(path); KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(RSA, PROVIDER_BC); keyPairGenerator.initialize(keySize); KeyPair keyPair = keyPairGenerator.generateKeyPair(); OutputStream priOs = null; OutputStream pubOs = null; try { // key format without armored priOs = new FileOutputStream(priKeyFile); pubOs = new FileOutputStream(pubKeyFile); // the pass phrase to open private key char[] passPhrase_ = passPhrase.toCharArray(); // Hash algorithm using SHA1 as certificate PGPDigestCalculator sha1Calc = new JcaPGPDigestCalculatorProviderBuilder().build().get(HashAlgorithmTags.SHA1); // Generate RSA key pair JcaPGPKeyPair jcaPGPKeyPair = new JcaPGPKeyPair(PGPPublicKey.RSA_GENERAL, keyPair, new Date()); PGPSecretKey pgpSecretKey = new PGPSecretKey(PGPSignature.DEFAULT_CERTIFICATION, jcaPGPKeyPair, identity, sha1Calc, null, null, new JcaPGPContentSignerBuilder(jcaPGPKeyPair.getPublicKey().getAlgorithm(), HashAlgorithmTags.SHA1), new JcePBESecretKeyEncryptorBuilder(PGPEncryptedData.CAST5, sha1Calc).setProvider(PROVIDER_BC).build(passPhrase_)); String privateKeyBase64Str = Base64.encode(pgpSecretKey.getEncoded()); System.out.println(\u0026#34;PGP密钥Base64串：\\r\\n\u0026#34; + privateKeyBase64Str); priOs.write(privateKeyBase64Str.getBytes()); PGPPublicKey publicKey = pgpSecretKey.getPublicKey(); String publicKeyBase64Str = Base64.encode(publicKey.getEncoded()); System.out.println(\u0026#34;PGP公钥Base64串：\\r\\n\u0026#34; + publicKeyBase64Str); System.out.println(\u0026#34;PGP公钥信息：\\r\\n\u0026#34; + publicKey.getKeyID()); System.out.println(\u0026#34;PGP公钥信息：\\r\\n\u0026#34; + publicKey.getUserIDs().next()); System.out.println(\u0026#34;PGP公钥信息：\\r\\n\u0026#34; + publicKey.getValidSeconds()); pubOs.write(publicKeyBase64Str.getBytes()); } catch (Exception e) { log.error(\u0026#34;生成密钥失败\u0026#34;, e); } finally { IOUtils.closeQuietly(priOs); IOUtils.closeQuietly(pubOs); } } public static void createDirectory(String path) throws Exception { File file = new File(path); if (!file.exists() \u0026amp;\u0026amp; !file.isDirectory()) { file.mkdirs(); } } public static byte[] compressFile(String fileName, int algorithm) throws IOException { ByteArrayOutputStream bOut = new ByteArrayOutputStream(); PGPCompressedDataGenerator comData = new PGPCompressedDataGenerator(algorithm); PGPUtil.writeFileToLiteralData(comData.open(bOut), PGPLiteralData.BINARY, new File(fileName)); comData.close(); return bOut.toByteArray(); } /** * Search a secret key ring collection for a secret key corresponding to keyID if it * \u0026lt;p\u0026gt; * exists. * * @param pgpSec a secret key ring collection. * @param keyID? keyID we want. * @param pass? passphrase to decrypt secret key with. * @return the private key. * @throws PGPException */ public static PGPPrivateKey findSecretKey(PGPSecretKeyRingCollection pgpSec, long keyID, char[] pass) throws PGPException { PGPSecretKey pgpSecKey = pgpSec.getSecretKey(keyID); if (pgpSecKey == null) { return null; } return pgpSecKey.extractPrivateKey(new JcePBESecretKeyDecryptorBuilder().setProvider(\u0026#34;BC\u0026#34;).build(pass)); } public static PGPPublicKey readPublicKey(String fileName) throws IOException, PGPException { InputStream keyIn = new BufferedInputStream(new FileInputStream(fileName)); PGPPublicKey pubKey = readPublicKey(keyIn); keyIn.close(); return pubKey; } /** * A simple routine that opens a key ring file and loads the first available key * \u0026lt;p\u0026gt; * suitable for encryption. * * @param input data stream containing the public key data * @return the first public key found. * @throws IOException * @throws PGPException */ public static PGPPublicKey readPublicKey(InputStream input) throws IOException, PGPException { PGPPublicKeyRingCollection pgpPub = new PGPPublicKeyRingCollection( PGPUtil.getDecoderStream(input), new JcaKeyFingerprintCalculator()); // we just loop through the collection till we find a key suitable for encryption, in the real // world you would probably want to be a bit smarter about this. Iterator keyRingIter = pgpPub.getKeyRings(); while (keyRingIter.hasNext()) { PGPPublicKeyRing keyRing = (PGPPublicKeyRing) keyRingIter.next(); Iterator keyIter = keyRing.getPublicKeys(); while (keyIter.hasNext()) { PGPPublicKey key = (PGPPublicKey) keyIter.next(); if (key.isEncryptionKey()) { return key; } } } throw new IllegalArgumentException(\u0026#34;Can\u0026#39;t find encryption key in key ring.\u0026#34;); } public static PGPSecretKey readSecretKey(String fileName) throws IOException, PGPException { InputStream keyIn = new BufferedInputStream(new FileInputStream(fileName)); PGPSecretKey secKey = readSecretKey(keyIn); keyIn.close(); return secKey; } /** * A simple routine that opens a key ring file and loads the first available key * \u0026lt;p\u0026gt; * suitable for signature generation. * * @param input stream to read the secret key ring collection from. * @return a secret key. * @throws IOException? on a problem with using the input stream. * @throws PGPException if there is an issue parsing the input stream. */ public static PGPSecretKey readSecretKey(InputStream input) throws IOException, PGPException { PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection( PGPUtil.getDecoderStream(input), new JcaKeyFingerprintCalculator()); // we just loop through the collection till we find a key suitable for encryption, in the real // world you would probably want to be a bit smarter about this. Iterator keyRingIter = pgpSec.getKeyRings(); while (keyRingIter.hasNext()) { PGPSecretKeyRing keyRing = (PGPSecretKeyRing) keyRingIter.next(); Iterator keyIter = keyRing.getSecretKeys(); while (keyIter.hasNext()) { PGPSecretKey key = (PGPSecretKey) keyIter.next(); if (key.isSigningKey()) { return key; } } } throw new IllegalArgumentException(\u0026#34;Can\u0026#39;t find signing key in key ring.\u0026#34;); } /** * 解密文件并跳过核签 * @param inputFileName 加密的文件 * @param priKeyFile 私钥文件，即base64串 * @param passwd 私钥密码 * @param outputFileName 输出文件名 * @throws Exception */ public static void decryptFileSkipSign(String inputFileName, String priKeyFile, char[] passwd, String outputFileName) throws Exception { InputStream in = null; InputStream keyIn = null; try { in = new BufferedInputStream(new FileInputStream(inputFileName)); keyIn = new ByteArrayInputStream(Base64.decode(priKeyFile)); // 自身私钥，用于解密 decryptFile(in, keyIn, passwd, outputFileName, null, true); } catch (Exception e) { throw new Exception(e); } finally { IOUtils.closeQuietly(keyIn); IOUtils.closeQuietly(in); } } /** * 解密文件 * @param inputFileName 加密的文件 * @param priKeyPath 私钥路径 * @param passwd 私钥密码 * @param outputFileName 输出文件名 * @param pubKeyPath 公钥路径 * @param skipCheckSign 跳过核签 * @throws Exception */ public static void decryptFile(String inputFileName, String priKeyPath, char[] passwd, String outputFileName, String pubKeyPath, boolean skipCheckSign) throws Exception { InputStream in = null; InputStream keyIn = null; InputStream signIn = null; try { in = new BufferedInputStream(new FileInputStream(inputFileName)); keyIn = new BufferedInputStream(new FileInputStream(priKeyPath)); // 自身私钥，用于解密 signIn = new BufferedInputStream(new FileInputStream(pubKeyPath)); // 对方公钥，用于验签 decryptFile(in, keyIn, passwd, outputFileName, signIn, skipCheckSign); } catch (Exception e) { throw new Exception(e); } finally { IOUtils.closeQuietly(keyIn); IOUtils.closeQuietly(in); IOUtils.closeQuietly(signIn); } } /** * decrypt the passed in message stream */ public static void decryptFile(InputStream in, InputStream keyIn, char[] passwd, String defaultFileName, InputStream signIn, boolean skipCheckSign) throws Exception { ByteArrayOutputStream actualOutput = null; OutputStream fOut = null; BufferedInputStream bis = null; try { in = PGPUtil.getDecoderStream(in); JcaPGPObjectFactory pgpF = new JcaPGPObjectFactory(in); PGPEncryptedDataList enc; Object o = pgpF.nextObject(); // the first object might be a PGP marker packet. if (o instanceof PGPEncryptedDataList) { enc = (PGPEncryptedDataList) o; } else { enc = (PGPEncryptedDataList) pgpF.nextObject(); } // find the secret key Iterator it = enc.getEncryptedDataObjects(); PGPPrivateKey sKey = null; PGPPublicKeyEncryptedData pbe = null; PGPSecretKeyRingCollection pgpSec = new PGPSecretKeyRingCollection( PGPUtil.getDecoderStream(keyIn), new JcaKeyFingerprintCalculator()); while (sKey == null \u0026amp;\u0026amp; it.hasNext()) { pbe = (PGPPublicKeyEncryptedData) it.next(); sKey = findSecretKey(pgpSec, pbe.getKeyID(), passwd); } if (sKey == null) { throw new IllegalArgumentException(\u0026#34;secret key for message not found.\u0026#34;); } InputStream clear = pbe.getDataStream(new BcPublicKeyDataDecryptorFactory(sKey)); PGPObjectFactory plainFact = new PGPObjectFactory(clear, new BcKeyFingerprintCalculator()); PGPOnePassSignatureList onePassSignatureList = null; PGPSignatureList signatureList = null; PGPCompressedData compressedData = null; String outFileName = null; Object message = plainFact.nextObject(); actualOutput = new ByteArrayOutputStream(); while (message != null) { if (message instanceof PGPCompressedData) { compressedData = (PGPCompressedData) message; plainFact = new PGPObjectFactory(compressedData.getDataStream(), new BcKeyFingerprintCalculator()); message = plainFact.nextObject(); } if (message instanceof PGPLiteralData) { PGPLiteralData ld = (PGPLiteralData) message; outFileName = ld.getFileName(); if (outFileName.length() == 0) { outFileName = defaultFileName; } else { outFileName = defaultFileName; } InputStream unc = ld.getInputStream(); Streams.pipeAll(unc, actualOutput); } else if (message instanceof PGPOnePassSignatureList) { onePassSignatureList = (PGPOnePassSignatureList) message; } else { signatureList = (PGPSignatureList) message; } message = plainFact.nextObject(); } byte[] outputBytes = actualOutput.toByteArray(); if (onePassSignatureList == null || signatureList == null) { log.info(\u0026#34;Poor PGP. Signatures not found.\u0026#34;); } else if (onePassSignatureList != null \u0026amp;\u0026amp; !skipCheckSign) { // 实际上不验签、验签失败也不会影响文件解密 for (int i = 0; i \u0026lt; onePassSignatureList.size(); i++) { PGPOnePassSignature ops = onePassSignatureList.get(i); PGPPublicKeyRingCollection pgpRing = new PGPPublicKeyRingCollection(PGPUtil.getDecoderStream(signIn), new BcKeyFingerprintCalculator()); PGPPublicKey publicKey = pgpRing.getPublicKey(ops.getKeyID()); // PGPPublicKey publicKey = readPublicKey(signIn); if (publicKey != null) { ops.init(new BcPGPContentVerifierBuilderProvider(), publicKey); ops.update(outputBytes); PGPSignature signature = signatureList.get(i); if (ops.verify(signature)) { log.info(\u0026#34;验证签名成功\u0026#34;); } else { log.info(\u0026#34;验证签名失败\u0026#34;); } } } } fOut = new BufferedOutputStream(new FileOutputStream(outFileName)); bis = new BufferedInputStream(new ByteArrayInputStream(outputBytes)); byte[] b = new byte[1024]; int len = -1; while ((len = bis.read(b)) != -1) { fOut.write(b, 0, len); } } catch (PGPException e) { log.error(\u0026#34;PGPException.\u0026#34;, e); if (e.getUnderlyingException() != null) { log.error(\u0026#34;UnderlyingException.\u0026#34;, e.getUnderlyingException()); } throw new Exception(e); } catch (IOException e) { log.error(\u0026#34;IOException.\u0026#34;, e); throw new Exception(e); } finally { IOUtils.closeQuietly(actualOutput); IOUtils.closeQuietly(fOut); IOUtils.closeQuietly(bis); } } public static void encryptFile(String outputFileName, String inputFileName, String encKeyFileName, boolean armor, boolean withIntegrityCheck) throws IOException, NoSuchProviderException, PGPException { OutputStream out = new BufferedOutputStream(new FileOutputStream(outputFileName)); PGPPublicKey encKey = readPublicKey(encKeyFileName); encryptFile(out, inputFileName, encKey, armor, withIntegrityCheck); out.close(); } public static void encryptFile(OutputStream out, String fileName, PGPPublicKey encKey, boolean armor, boolean withIntegrityCheck) throws IOException, NoSuchProviderException { if (armor) { out = new ArmoredOutputStream(out); } try { byte[] bytes = compressFile(fileName, CompressionAlgorithmTags.ZIP); PGPEncryptedDataGenerator encGen = new PGPEncryptedDataGenerator( new JcePGPDataEncryptorBuilder(PGPEncryptedData.CAST5).setWithIntegrityPacket(withIntegrityCheck).setSecureRandom(new SecureRandom()).setProvider(\u0026#34;BC\u0026#34;)); encGen.addMethod(new JcePublicKeyKeyEncryptionMethodGenerator(encKey).setProvider(\u0026#34;BC\u0026#34;)); OutputStream cOut = encGen.open(out, bytes.length); cOut.write(bytes); cOut.close(); if (armor) { out.close(); } } catch (PGPException e) { log.error(\u0026#34;PGPException.\u0026#34;, e); if (e.getUnderlyingException() != null) { log.error(\u0026#34;UnderlyingException.\u0026#34;, e.getUnderlyingException()); } } } public static void main(String[] args) throws Exception { String path = \u0026#34;D:\\\\pgp\\\\\u0026#34;; String pubKeyFile = path + \u0026#34;public-file.key\u0026#34;; String priKeyFile = path + \u0026#34;private-file.key\u0026#34;; // 生成PGP密钥对 //try { // generatePGPKeyPair(2048, \u0026#34;\u0026#34;, \u0026#34;sdebank\u0026#34;, pubKeyFile, priKeyFile, path); //} catch (Exception e) { // System.out.println(\u0026#34;生成PGP密钥对失败\u0026#34;); // e.printStackTrace(); //} boolean encryp = false; //加密：true? 解密：false // 加密 String fileName = \u0026#34;test.xml\u0026#34;; if (encryp) { String outPath = path + fileName + \u0026#34;.pgp\u0026#34;; String inputPath = path + fileName; String publicKeys = pubKeyFile; //公钥地址 encryptFile(outPath, inputPath, publicKeys, true, true); } else { // 解密 String password = \u0026#34;123\u0026#34;; //私钥的密码 String privateKeys = priKeyFile; //私钥地址 String inputPath = path + fileName + \u0026#34;.pgp\u0026#34;; //被加密的文件 String outPath = path + \u0026#34;decrypt_\u0026#34; + fileName; System.out.println(\u0026#34;要解密的文件：\u0026#34; + inputPath + \u0026#34;，解密出来的文件\u0026#34; + outPath); decryptFileSkipSign(inputPath, privateKeys, password.toCharArray(), outPath); } } } 虽然Java代码能成功生成PGP密钥对，但是在跟客户交互PGP公钥时发现公钥文件格式不对，最终还是改在Linux上用GPG命令来生成密钥对。除此之外，Java的PGP加解密功能则是没有问题，可以正常对接客户的需求。\n参考链接 gpg 密钥生成、导入、导出、自动输入密码 关于PGP \u0026amp; GPG文件加密有这篇就够了 运行gpg \u0026ndash;gen-key生成密钥时卡住在We need to generate a lot of random bytes 2021年，用更现代的方法使用PGP（上） PGP 对于JSON的加解密 ","permalink":"https://lewky.cn/posts/pgp/","tags":["PGP","GPG","加解密"],"title":"PGP加解密"},{"categories":["工作记录"],"contents":"Apollo简介 Apollo作为分布式配置中心，主要分为三个部分：客户端Client、服务端Server、管理门户Portal。Portal提供Web界面供用户管理配置。\nApollo涉及到3个进程，启动时需要按照configservice、adminservice、portal的顺序。\nApollo下发更新超时失败 项目使用Apollo来保存微服务接口的相关信息，做法是把部署在某个边车里的所有微服务接口信息都存到一个xml文件中，该文件会读取为一个字符串被保存到Apollo数据库release表的Configurations字段。每次改动某个接口时，都会触发一次xml文件的更新并下发到Apollo。\n由于该字段是longtext类型，随着维护接口的数量增长，该字段要维护的xml文件越来越大，最大可达十几M，此时发现Apollo经常更新配置失败。\n经过排查，发现Apollo底层用的Hibernate来将数据保存到数据库，由于没有给Apollo客户端设置超时时间，该参数底层默认值为-1。对于httpclient的sockettimeout参数，-1表示使用系统默认值，在部署的Linux机器上该默认值为5秒，因此下发数据时由于Configurations字段值很大导致超时失败。\n这里分为两部分来优化，一个是将边车中部分接口迁移到其他边车，减少当前边车对应的xml文件大小；一个是调大Apollo客户端的读取超时时间为20s，经过测试差不多需要五秒多的时间才能将原本十几M的xml文件保存到数据库中。\n1 2 3 4 5 6 7 8 9 public static ApolloOpenApiClient getApolloPortalClient() { String portalUrl = ESCConfigUtil.getValue(\u0026#34;esc.apollo.portal\u0026#34;); // portal url String token = ESCConfigUtil.getValue(\u0026#34;esc.apollo.token\u0026#34;); // 申请的token return ApolloOpenApiClient.newBuilder() .withReadTimeout(20000) .withPortalUrl(portalUrl) .withToken(token) .build(); } 此外，频繁更新下发数据，会导致release表和releasehistory表数据量剧增，Apollo本身没有对此提供清理策略，需要自行设置定时任务去定时定量删除无效或者无意义的历史数据。\nvalue too long. length limit 在下发数据到Apollo时报错ApolloOpenApiException，错误信息显示value too long. length limit:2000000，这个是因为下发的value数据（一个xml字符串）太大，超过了默认的长度。\nApollo数据库apolloconfig的serverconfig表有个属性控制了value长度，将item.value.length.limit值改成更大的长度，再重启Apollo进程即可。这里还有另一个属性item.key.length.limit`用于控制key的长度，改动生效也同理。\n参考链接 聊聊 分布式配置中心 Apollo ","permalink":"https://lewky.cn/posts/apollo-issues/","tags":["Apollo"],"title":"Apollo问题汇总"},{"categories":["杂谈"],"contents":"推送时报错秘钥格式不支持 GitHub在某次更新后改变了支持的秘钥策略，对于新增的RSA格式的SSH秘钥，如果是无密码加密的，会报错如下：\n1 You\u0026#39;re using an RSA key with SHA-1, which is no longer allowed. Please use a GitHub的改动详情可以参考如下页面：https://github.blog/2021-09-01-improving-git-protocol-security-github/\nWe’re changing which keys are supported in SSH and removing unencrypted Git protocol. Specifically we are:\nRemoving support for all DSA keys Adding requirements for newly added RSA keys Removing some legacy SSH algorithms (HMAC-SHA-1 and CBC ciphers) Adding ECDSA and Ed25519 host keys for SSH Turning off the unencrypted Git protocol 如果不想给生成的RSA格式SSH秘钥附带一个密码，可以改用Ed25519格式来生成（GitHub也允许你关闭加密Git协议策略来放行无加密的RSA秘钥，但我没找到在哪配置）：\n1 ssh-keygen -m PEM -t ed25519 -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 记得修改上述命令中的邮箱地址为你的邮箱地址，然后执行命令过程中一路按回车键即可，如果以前生成过会提示你是否覆盖，这时候需要输入y再继续回车。\n参考链接 Improving Git protocol security on GitHub ","permalink":"https://lewky.cn/posts/github-issues/","tags":["GitHub"],"title":"GitHub问题汇总"},{"categories":["工作记录"],"contents":"30天试用期到期解决方法 SmartGit可以免费试用三十天，三十天后可以通过删除配置文件来重复免费试用三十天的过程，不同版本需要删除的文件不同。\nwin + R组合键打开运行窗口，输入%APPDATA%\\syntevo\\SmartGit\\然后回车会进入到SmartGit的安装路径，进入你当前使用的版本目录，如果是旧版的SmartGit（如17.2版本），删除当前的settings.xml文件，然后重启SmartGit即可。\n如果找不到settings.xml文件，说明是新版本的SmartGit（如21.2版本），此时需要删除下面两个文件：\nlicense和preferences.yml，然后重启SmartGit即可。\n选择秘钥时不支持OPENSSH格式 某天发现用Git Bash生成的SSH key无法被SmartGit识别，提示需要PEM格式，不支持OPENSSH格式。奇怪的是之前也用同样的方法生成的key是可以被识别的，猜测要么是SmartGit版本不同导致无法支持OPENSSH格式，要么是Git Bash版本不同导致默认生成的key格式发生了变化。\n用编辑器打开私钥可以发现开头是BEGIN OPENSSH PRIVATE KEY，既然SmartGit无法支持OPENSSH格式的key，可以改用下面的命令重新生成PEM格式的SSH key：\n1 ssh-keygen -m PEM -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 记得修改上述命令中的邮箱地址为你的邮箱地址，然后执行命令过程中一路按回车键即可，如果以前生成过会提示你是否覆盖，这时候需要输入y再继续回车。如果想要生成其他算法的秘钥，可以通过修改-t后面的算法来实现，如-t ed25519。\n参考链接 SmartGit一个月试用期过期的解决方法 ssh-keygen命令生成的以BEGIN OPENSSH PRIVATE KEY开头的密钥无法通过验证 ","permalink":"https://lewky.cn/posts/smartgit-issues/","tags":["SmartGit"],"title":"SmartGit问题汇总"},{"categories":["工作记录"],"contents":"HttpURLConnection设置host请求头无效 由于业务需要在调用第三方SDK时需要设置host请求头为对方的域名，在测试时发现代码设置后依然无法生效。查找资料后发现是从JDK6的6u23版本开始就对HTTP的部分请求头做了限制，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 private static final String[] restrictedHeaders = { /* Restricted by XMLHttpRequest2 */ //\u0026#34;Accept-Charset\u0026#34;, //\u0026#34;Accept-Encoding\u0026#34;, \u0026#34;Access-Control-Request-Headers\u0026#34;, \u0026#34;Access-Control-Request-Method\u0026#34;, \u0026#34;Connection\u0026#34;, /* close is allowed */ \u0026#34;Content-Length\u0026#34;, //\u0026#34;Cookie\u0026#34;, //\u0026#34;Cookie2\u0026#34;, \u0026#34;Content-Transfer-Encoding\u0026#34;, //\u0026#34;Date\u0026#34;, \u0026#34;Expect\u0026#34;, \u0026#34;Host\u0026#34;, \u0026#34;Keep-Alive\u0026#34;, \u0026#34;Origin\u0026#34;, // \u0026#34;Referer\u0026#34;, // \u0026#34;TE\u0026#34;, \u0026#34;Trailer\u0026#34;, \u0026#34;Transfer-Encoding\u0026#34;, \u0026#34;Upgrade\u0026#34;, //\u0026#34;User-Agent\u0026#34;, \u0026#34;Via\u0026#34; }; allowRestrictedHeaders = ((Boolean)java.security.AccessController.doPrivileged( new sun.security.action.GetBooleanAction( \u0026#34;sun.net.http.allowRestrictedHeaders\u0026#34;))).booleanValue(); 可以通过设置JVM启动参数-Dsun.net.http.allowRestrictedHeaders=true，或者在启动类里加上代码System.setProperty(\u0026quot;sun.net.http.allowRestrictedHeaders\u0026quot;, \u0026quot;true\u0026quot;)来解决这个问题。\n实际上在发送HTTP请求时如果URL是用的域名，就已经将host请求头设置为该域名了，当然也可以手动设置成其他域名。\n有时候项目部署在内网，无法直接发送请求到对方域名，而是发送到代理IP上，而对方又对请求域名进行了检测和限制，此时就只能用上述方式来解除限制并在代码中设置host请求头了。如果条件允许，也可以用设置代理IP的方式来实现同样的效果，这样做的好处是不需要设置JVM启动参数。\n这两种方式可以用curl来举例模拟，如下是智信钉钉新版服务端的登陆接口：\n1 2 3 4 5 6 7 // 智信钉钉接口域名是api.dingtalk.com，在公司内网的代理地址是20.1.1.123:80 // 第一种方式，使用host属性，URL里用的是代理IP curl -H \u0026#34;Content-Type:application/json\u0026#34; -H \u0026#34;host:api.dingtalk.com\u0026#34; -X POST -d \u0026#39;{\u0026#34;appKey\u0026#34;:\u0026#34;xxx\u0026#34;,\u0026#34;appSecret\u0026#34;:\u0026#34;xxx\u0026#34;}\u0026#39; \u0026#34;https://20.1.1.123/v1.0/oauth2/accessToken\u0026#34; // 第二种方式，使用proxy代理IP，URL里用的是域名 curl --proxy \u0026#34;20.1.1.123:80\u0026#34; -H \u0026#34;Content-Type:application/json\u0026#34; -X POST -d \u0026#39;{\u0026#34;appKey\u0026#34;:\u0026#34;xxx\u0026#34;,\u0026#34;appSecret\u0026#34;:\u0026#34;xxx\u0026#34;}\u0026#39; \u0026#34;https://api.dingtalk.com/v1.0/oauth2/accessToken\u0026#34; 如果既不想设置host请求头，项目部署在内网并开通了代理，可以让运维那边设置网络策略为TCP转发（这一步其实可以不用做，只是如果服务端是HTTPS双向认证时会出问题），然后修改项目所在机器的hosts文件，这样就不需要设置JVM启动参数和设置host请求头了。\nlengthTag=111, too big SpringBoot项目读取HTTPS证书文件时报错如下：\n1 2 3 4 5 6 7 8 9 Caused by: java.io.IOException: DerInputStream.getLength(): lengthTag=111, too big. at sun.security.util.DerInputStream.getLength(DerInputStream.java:599) ~[na:1.8.0_181] at sun.security.util.DerValue.init(DerValue.java:391) ~[na:1.8.0_181] at sun.security.util.DerValue.\u0026lt;init\u0026gt;(DerValue.java:332) ~[na:1.8.0_181] at sun.security.util.DerValue.\u0026lt;init\u0026gt;(DerValue.java:345) ~[na:1.8.0_181] at sun.security.pkcs12.PKCS12KeyStore.engineLoad(PKCS12KeyStore.java:1938) ~[na:1.8.0_181] at java.security.KeyStore.load(KeyStore.java:1445) ~[na:1.8.0_181] at org.springframework.boot.web.embedded.netty.SslServerCustomizer.loadStore(SslServerCustomizer.java:173) ~[spring-boot-2.4.1.jar:2.4.1] ... 21 common frames omitted 报错是因为maven在打包项目时将resource目录下的证书文件重新编译了一次（这个可以对比编译前后的文件大小即可看出来），导致程序运行时读取证书文件失败。\n可以在pom.xml中通过插件排除指定的文件来解决这个问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;test\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-resources-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;nonFilteredFileExtensions\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;jks\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;p12\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;cer\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;crt\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;pem\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;pfx\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;/nonFilteredFileExtensions\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; HTTPS单向认证和双向认证 HTTP是明文传输，默认端口为80。\nHTTPS是SSL / TLS + HTTP，默认端口为443，可进行加密传输和身份认证，因此涉及到两类文件：密钥和信任证书。SSL协议使用的加解密方式很像数字信封。\nTLS可以说是SSL的升级版，但二者不可共用。TLS的版本号与SSL不同，TLS的版本1.0使用的版本号是SSLv3.1。\n单向认证是只有客户端验证服务端的身份，客户端发起连接时服务端需要发送自己的数字证书给客户端验证。双向认证是客户端和服务端都需要互相验证对方的身份。单向认证的方式比较简单且常见，但安全性较低。\n更具体的可以看看这篇文章：SSL 和 TLS 之间的主要区别是什么？\nJDK自带的keytool工具生成证书 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 生成keystore文件，生成的证书文件是Java专用的JKS格式 keytool -genkey -alias tomcat -keyalg RSA // 生成一个别名为tomcat的自签名证书，证书文件名为test，证书实体信息为\u0026#34;CN=Liu, OU=TestOU, O=TestO, L=sde, ST=GD, C=CN\u0026#34;，密钥密码和密钥库密码为123456，有效期为180天 keytool -genkey -alias tomcat -keyalg RSA -dname \u0026#34;CN=Liu, OU=TestOU, O=TestO, L=sde, ST=GD, C=CN\u0026#34; -keystore test -keypass 123456 -storepass 123456 -validity 180 // 把JKS格式转为行业标准格式PKCS12，参数和生成keystore类似，根据src和dest区分 keytool -importkeystore -srckeystore test -destkeystore test1 -deststoretype pkcs12 -srcalias tomcat -destalias tomcat -srckeypass 123456 -srcstorepass 123456 -destkeypass 123456 -deststorepass 123456 // 列出详细信息 keytool -list -v -keystore .keystore // 导出cer信任证书 keytool -export -alias tomcat -file test.cer -keystore .keystore -storepass 123456 -rfc // 查看证书信息 keytool -printcert -file test.cer // jdk自带的证书库文件：`%JAVA_HOME%/jre/lib/security/cacerts` keytool -list -v -keystore \u0026#34;%JAVA_HOME%/jre/lib/security/cacerts\u0026#34; Java实现HTTPS双向认证 JDK通过KeyStore对象来存储密钥文件和信任证书，但两个文件由不同的管理器类分开管理：KeyManagerFactory、TrustManagerFactory\nKeyManagerFactory负责装载密钥文件，加解密通讯数据；TrustManagerFactory负责装载信任证书，进行身份验证。\n如果对于安全性要求不是很高，直接使用忽略认证SSL来发送https请求也是可以的，但是不建议在生产环境这样做。\npom依赖：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpmime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 public static void main(String[] args) { // 设置协议http和https对应的处理socket链接工厂的对象 RegistryBuilder\u0026lt;ConnectionSocketFactory\u0026gt; builder = RegistryBuilder.\u0026lt;ConnectionSocketFactory\u0026gt;create() .register(\u0026#34;http\u0026#34;, PlainConnectionSocketFactory.getSocketFactory()); Registry\u0026lt;ConnectionSocketFactory\u0026gt; registry = null; // HTTPS是否忽略SSL认证 boolean ignoreSSL = false; // 是否信任所有信任证书，相当于跳过客户端验证服务端证书 boolean trustAllCerts = false; // 是否使用代理 boolean useProxy = false; if (!ignoreSSL) { // 密钥和信任证书被存储在一个密钥库文件中（也可能存储在两个不同的密钥库文件中），需要用密钥库口令才能读取密钥库文件 // 密钥本身还有一个口令保护着，因此这里涉及到两个口令：密钥口令和密钥库口令 // 信任证书相关 String trustStoreType = \u0026#34;\u0026#34;; String trustStoreFile = \u0026#34;\u0026#34;; String trustStorePass = \u0026#34;\u0026#34;; // 存储信任证书的密钥库口令，jetty里将该密钥库称为信任库 // 密钥文件相关 String keyStoreType = \u0026#34;\u0026#34;; String keyStoreFile = \u0026#34;\u0026#34;; String keyStorePass = \u0026#34;\u0026#34;; // 存储密钥的密钥库口令 String keyPass = \u0026#34;\u0026#34;; // 密钥口令 SSLContext sslContext = custom(trustStoreType, trustStoreFile, trustStorePass, keyStoreType, keyStoreFile, keyStorePass, keyPass, trustAllCerts); registry = builder.register(\u0026#34;https\u0026#34;, new SSLConnectionSocketFactory(sslContext)) .build(); } else { // 完全忽略SSL认证，既不加载密钥，也不加载信任证书 registry = builder.register(\u0026#34;https\u0026#34;, new SSLConnectionSocketFactory(createIgnoreVerifySSL(), SSLConnectionSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER)) .build(); } PoolingHttpClientConnectionManager cm = new PoolingHttpClientConnectionManager(registry); // 这两个值设置一样大不太合适，PreRoute指的是针对某个url的最大并发数 cm.setMaxTotal(2000); cm.setDefaultMaxPerRoute(500); RequestConfig requestConfig; if(useProxy){ String proxyIP = \u0026#34;\u0026#34;; String proxyPort = \u0026#34;\u0026#34;; HttpHost pr = new HttpHost(proxyIP,Integer.parseInt(proxyPort)); requestConfig = RequestConfig.custom().setConnectTimeout(30000).setSocketTimeout(30000) .setConnectionRequestTimeout(30000).setProxy(pr).build(); }else{ requestConfig = RequestConfig.custom().setConnectTimeout(30000).setSocketTimeout(30000) .setConnectionRequestTimeout(30000).build(); } HttpClient httpClient = HttpClients.custom().setConnectionManager(cm).setDefaultRequestConfig(requestConfig).build(); String uri = \u0026#34;http://localhost:55555\u0026#34;; String charset = \u0026#34;UTF-8\u0026#34;; final HttpPost post = new HttpPost(uri); // 设置请求头 post.setHeader(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;); post.setHeader(\u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34;); // 设置支持cookie HttpContext localContext = new BasicHttpContext(); BasicCookieStore cookieStore = new BasicCookieStore(); Cookie cookie = new BasicClientCookie(\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;); cookieStore.addCookie(cookie); localContext.setAttribute(HttpClientContext.COOKIE_STORE, cookieStore); // 设置body final BasicHttpEntity entity = new BasicHttpEntity(); entity.setChunked(false); byte[] content = null; try { content = \u0026#34;POST body content.\u0026#34;.getBytes(charset); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } entity.setContentEncoding(charset); entity.setContentLength(content.length); entity.setContent(new ByteArrayInputStream(content)); post.setEntity(entity); // 发送请求 HttpResponse httpResponse = null; try { httpResponse = httpClient.execute(post, localContext); } catch (IOException e) { e.printStackTrace(); } } public static SSLContext custom(String trustStoreType, String trustStoreFile, String trustStorePass, String keyStoreType, String keyStoreFile, String keyStorePass, String keyPass, boolean trustAll) { SSLContext ctx = null; ByteArrayInputStream trustInputStream = null; ByteArrayInputStream keyInputStream = null; KeyStore trustStore = null; KeyStore keyStore = null; TrustManager[] trustManagers = null; try { // 密钥文件，通常格式为pfx、p12或jks（jks是java专用的格式） keyStore = KeyStore.getInstance(StringUtils.isNotBlank(keyStoreType) ? keyStoreType : \u0026#34;PKCS12\u0026#34;); keyInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(keyStoreFile)); keyStore.load(keyInputStream, keyStorePass.toCharArray()); KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); kmf.init(keyStore, keyPass.toCharArray()); if (trustAll) { // 信任所有信任证书 TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() { @Override public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { // don\u0026#39;t check } @Override public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { // don\u0026#39;t check } @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[]{}; } } }; trustManagers = trustAllCerts; } else { // 信任证书，通常格式为crt、cer trustStore = KeyStore.getInstance(StringUtils.isNotBlank(trustStoreType) ? trustStoreType : KeyStore.getDefaultType()); trustInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(trustStoreFile)); trustStore.load(trustInputStream, trustStorePass.toCharArray()); TrustManagerFactory tmf = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(trustStore); trustManagers = tmf.getTrustManagers(); } // TLS可以视为SSL升级版，TLSv1.0版本号记为SSLv3.1 ctx = SSLContext.getInstance(\u0026#34;TLS\u0026#34;); ctx.init(kmf.getKeyManagers(), trustManagers, null); } catch (Exception e) { log.error(\u0026#34;当前HTTPS协议装载SSL证书失败！\u0026#34;, e); } finally { IOUtils.closeQuietly(trustInputStream); IOUtils.closeQuietly(keyInputStream); } return ctx; } public static SSLContext createIgnoreVerifySSL() { SSLContext ctx = null; // 信任所有信任证书 TrustManager[] trustAllCerts = new TrustManager[] { new X509TrustManager() { @Override public void checkClientTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { // don\u0026#39;t check } @Override public void checkServerTrusted(X509Certificate[] x509Certificates, String s) throws CertificateException { // don\u0026#39;t check } @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[]{}; } } }; try { ctx = SSLContext.getInstance(\u0026#34;SSL\u0026#34;); ctx.init(null, trustAllCerts, null); } catch (NoSuchAlgorithmException e) { e.printStackTrace(); } catch (KeyManagementException e) { e.printStackTrace(); } return ctx; } HttpClient提交表单数据 通过application/x-www-form-urlencoded提交页面form表单数据，键值对会被自动url编码，并通过\u0026amp;拼接起来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 String uri = \u0026#34;http://localhost:55555\u0026#34;; String charset = \u0026#34;UTF-8\u0026#34;; final HttpPost post = new HttpPost(uri); // 设置请求头 post.setHeader(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;); post.setHeader(\u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34;); // 设置支持cookie HttpContext localContext = new BasicHttpContext(); BasicCookieStore cookieStore = new BasicCookieStore(); Cookie cookie = new BasicClientCookie(\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;); cookieStore.addCookie(cookie); localContext.setAttribute(HttpClientContext.COOKIE_STORE, cookieStore); // 获取URL参数 List\u0026lt;NameValuePair\u0026gt; pairs = new ArrayList\u0026lt;NameValuePair\u0026gt;(); pairs.add(new BasicNameValuePair(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;)); pairs.add(new BasicNameValuePair(\u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34;)); UrlEncodedFormEntity entity = new UrlEncodedFormEntity(pairs, Charset.forName(charset)); post.setEntity(entity); // 发送请求 HttpClient httpClient = HttpClients.createDefault(); HttpResponse httpResponse = null; try { httpResponse = httpClient.execute(post, localContext); } catch (IOException e) { e.printStackTrace(); } the request was rejected because no multipart boundary was found 通过multipart/form-data提交表单数据时，需要用到boundary来分割文件和请求参数，如果只需要提交文件，用HttpClient时不需要设置Header，底层会自动生成boundary。\n如果需要同时提交文件和请求参数，需要手动设置Header和boundary，否则会报错the request was rejected because no multipart boundary was found，设置方法可以参考下文。\nHttpClient发送文件请求 通过multipart/form-data上传文件，文件和请求参数需要用boundary来分割。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 public class Test { private static final char[] MULTIPART_CHARS = \u0026#34;-_1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;.toCharArray(); public static void main(String[] args) { String uri = \u0026#34;http://localhost:55555\u0026#34;; String charset = \u0026#34;UTF-8\u0026#34;; final HttpPost post = new HttpPost(uri); // 设置请求头 post.setHeader(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;); post.setHeader(\u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34;); // 设置支持cookie HttpContext localContext = new BasicHttpContext(); BasicCookieStore cookieStore = new BasicCookieStore(); Cookie cookie = new BasicClientCookie(\u0026#34;name\u0026#34;, \u0026#34;value\u0026#34;); cookieStore.addCookie(cookie); localContext.setAttribute(HttpClientContext.COOKIE_STORE, cookieStore); // 设置boundary，用于分割文件和请求参数 String boundary = generateBoundary(); post.setHeader(\u0026#34;Content-type\u0026#34;, \u0026#34;multipart/form-data; boundary=\u0026#34; + boundary + \u0026#34;; charset=utf-8\u0026#34;); MultipartEntityBuilder builder = MultipartEntityBuilder.create(); builder.setMode(HttpMultipartMode.BROWSER_COMPATIBLE); builder.setCharset(Charset.forName(charset)); builder.setBoundary(boundary); // 添加请求参数 ContentType textContentType = ContentType.create(\u0026#34;application/x-www-form-urlencoded\u0026#34;, Charset.forName(charset)); builder.addTextBody(\u0026#34;key1\u0026#34;, \u0026#34;value1\u0026#34;, textContentType); builder.addTextBody(\u0026#34;key2\u0026#34;, \u0026#34;value2\u0026#34;, textContentType); // 添加文件 ContentType fileContentType = ContentType.create(\u0026#34;multipart/form-data\u0026#34;, Charset.forName(charset)); InputStream inputStream = null; File file = new File(\u0026#34;C:\\\\Users\\\\WB2027\\\\Downloads\\\\123.txt\u0026#34;); try { inputStream = new FileInputStream(file); String fileName = file.getName(); builder.addBinaryBody(\u0026#34;file\u0026#34;, inputStream, fileContentType, fileName); } catch (Exception e) { e.printStackTrace(); } HttpEntity entity = builder.build(); post.setEntity(entity); // 发送请求 HttpClient httpClient = HttpClients.createDefault(); HttpResponse httpResponse = null; try { httpResponse = httpClient.execute(post, localContext); } catch (IOException e) { e.printStackTrace(); } finally { IOUtils.closeQuietly(inputStream); } } // 拷贝自Apache MultipartEntityBuilder private static String generateBoundary() { StringBuilder buffer = new StringBuilder(); Random rand = new Random(); int count = rand.nextInt(11) + 30; for(int i = 0; i \u0026lt; count; ++i) { buffer.append(MULTIPART_CHARS[rand.nextInt(MULTIPART_CHARS.length)]); } return buffer.toString(); } } 连接超时的3个参数 在使用HttpClient时会涉及到3个超时参数：ConnectTimeout、SocketTimeout、ConnectionRequestTimeout。\nConnectTimeout是建立数据库连接的超时时间，此时如果超时报错就是连接超时，意味着三次握手失败了。\nSocketTimeout是数据读取超时，超过设定的时间则会连接断开，一般用这个参数来控制一次连接的最长时间，比如某笔重要交易服务端返回的数据量会很巨大，需要大量时间来返回和读取，那么就要给它设置一个比较大的值，避免读取到的响应不完整。\nConnectionRequestTimeout是从连接池中获取连接的超时时间，如果设置的连接池数量太少，而当前的TPS比较高，大量交易在排队等着从连接池获取连接，如果业务处理不过来则会报错连接池获取连接超时。这个参数不建议设置太高，3秒足矣，太高会影响整个交易的业务超时时间，对于上述的例子，正确做法是增加连接池里的连接数量。\n参考链接 HttpURLConnection 设置Host 头部无效 如何在HttpURLConnection中覆盖http-header\u0026quot;Host\u0026quot;？ springboot2.4开启HTTPS功能报DerInputStream.getLength(): lengthTag=111, too big异常 JAVA SSL HTTPS 连接详解 生成证书 Java，Web，https，读取网站申请SSL证书，JKS、PFX、CRT格式 post请求中的参数形式和form-data提交数据时取不到的问题 httpclient 使用application/x-www-form-urlencoded提交 ","permalink":"https://lewky.cn/posts/httpclient-issues/","tags":["JavaWeb"],"title":"HttpClient问题汇总"},{"categories":["生活"],"contents":"前言 前不久买了Oculus Quest2，从购买到激活再到使用这个过程属实折腾了好一番手脚，这里简单记录下，一方面给其他朋友做个参考，一方面也能以防万一日后重置机器需要重新激活。\n设备本体 Oculus Quest2目前分为两种配置，一种内存128G，一种内存256G，通常128G就够用了，一般玩过的游戏、看过的电影删了就行，基本不会内存不够用。当然土豪也可以直接上256G。\nQuest2从2022年8月起涨价了几百块，但总体来说依然性价比极高，且买后激活的15天内会免费赠送节奏光剑游戏（原价40美金），需要在Oculus app的邮箱通知里领取，过期作废，别忘记领取了。\n推荐从京东国际网购，并不会比亚马逊贵多少，并且发货速度比亚马逊快起码半个月时间。需要注意的是，Quest2的质保针对的是头显，并不包括手柄，如果手柄坏了只能找客服付费维修。\n头戴有配套的充电器充电，手柄则是使用的七号电池，设备开箱后按照说明书去掉一些保护膜即可使用，建议到手后立刻充电。\n配件推荐 精英头戴 Quest2本体戴久了压得脸颊痛，建议淘宝买个精英头戴，也就一百多块钱，却可以大大提高舒适度。\n定制VR镜片 对于近视、散光人群，建议去淘宝定制VR镜片，不然同时戴着眼镜和VR不太舒服。VR镜片是磁吸附的，可以安装在Quest2里，Quest2的镜片位置是有几个凹槽留给VR镜片的。通常购买时需要跟客服沟通，最好提供一个视力单子给对方以制作精确度数的镜片。\n另外，Quest2的镜片是可以调整眼间距的，直接把两个镜片位置同时向两边拨动即可，一共有3个档位。\n面罩 由于Quest2设计偏向于欧美人，因此亚洲人在使用时面罩鼻梁处漏怪较为严重，接受不了的可以淘宝买个防漏光加宽面罩，可以改善漏怪状况，且加宽的面罩可以减轻压脸的情况，并且吸汗效果也比本体更好。戴着Quest2玩游戏是真的很容易出汗，建议开着空调玩。\n软硬件支持 本人电脑很拉，没法串流玩PCVR，只玩一体机里的游戏，因此这里只做简单介绍，具体串流指南可以看这篇文章：Quest 2 从配件选购到无线串流教程指南\n有线连接 官方的Link串流线非常贵（几百块），直接淘宝买一个同款即可，也就几十块钱。需要注意的是，使用有线串流玩电脑VR游戏（PCVR），需要魔法上网，不然打不开官方app。\n使用Link串流线需要注意，玩的时候别绊倒自己了，最好买长度长点的（比如五米长的）。\n无线连接 无线连接使用起来舒服，不用担心绊到线，可以随意原地转圈（有些游戏是360度操作的）。但对显卡配置要求也是非常高的，建议至少3060Ti，因为无线串流时需要渲染两次游戏画面，对显卡负担可想而知。\n为了降低延迟，可以建议连接WIFI6 5G网络，最好手动选5G wifi6，保证设备走的是最优路线，如果没有WIFI6 5G路由器的，可以考虑入手一个游戏专用的路由器（如华硕无线路由器RT-AX56U）。\n无线串流目前有3个软件：alvr，vd（即Virtual Desktop），airlink。\nairlink是免费的，在三者中效率最差，非常吃显卡性能。\nvd是付费的，17美金，全英文界面，公认效果最好。\nalvr也是免费的，性能比airlink强，GitHub上可以下载到。\n激活与更新 Quest2的激活相当麻烦，不少新人就是倒在了开头的激活和更新上，最后不得不选择其他的VR产品。\n为了激活、更新Quest2，需要满足：\n魔法上网。 注册Facebook账号，Quest2是Facebook家的产品，要求绑定其账号，否则无法激活和购买游戏。 魔法上网只是第一步，还要能支持UDP转发，否则Quest2在启动成功后卡在更新这一步上，依然使用不了。 魔法上网 这个百度即可，建议找一些靠谱机场买一个月的付费节点。这样可以更稳定激活，更有利于个人使用。\n也可以让别人代激活，比如淘宝就有这种服务。代激活其实就是人家远程你电脑替你魔法上网，前提是电脑要带无线网卡（笔记本自带了）。人家的节点可能激活过很多人，万一节点出问题了，容易触发封号。\n注意，整个激活和更新流程都基于魔法上网，以下操作默认你会魔法上网！\n注册Facebook账号 建议使用gmail邮箱来注册Facebook账号，因此需要先申请个gmail邮箱，这个很简单，直接手机号注册一个就行（国内手机号的区号是86）。\n由于国内注册Facebook封号率可以说是几乎达到100%的封号率，基本上是申请了就秒封。这个没关系，封号后可以申请解封，两天后即会成功解封，因此建议在设备到货之前先把账号注册下来，免得到时候白白等两天解封时间。\n申请解封地址是：https://tickets.oculusvr.com/hc/zh-cn/requests/new\n为了避免日后又被封号，网上有很多养号的文章，总结来说：\n每次在浏览器登陆Facebook时都用隐身模式 退出Facebook后清除浏览器缓存、Cookie Facebook会记录每次登陆时的IP，如果IP发生了大变动，比如上一次是美国IP，这一次是香港IP，大概率直接封号。因此魔法上网时最好使用稳定的付费节点，且固定使用某个地区的IP 不要频繁改动账号的设置，比如频繁改名、换头像、大量加好友等 将账号绑定邮箱，改为用邮箱登陆，提高账号的安全性，这样可以降低封号率 如果激活设备后又被封号，可以申请解封，或者强制恢复出厂设置换账号。\n发射支持魔法上网的wifi 当你的电脑可以魔法上网后，Quest2初次启动需要连接wifi，该wifi也要能魔法上网，此时需要一个无线网卡，如果是笔记本已经自带了。\n电脑安装v2rayN软件，（百度下载，尽量最新版本的，否则转发UDP报文时会有问题），用v2rayN魔法上网：\n将付费的订阅节点地址拷贝到v2rayN中：订阅-》订阅设置 设置-》参数设置-》基础设置-》勾选允许来自局域网的连接，勾选开启UDP 选择一个节点（香港、美国都行），按下回车键，会跳转到对应的节点（要用Shadowsocks节点，也就是所谓的ss节点，有的节点是VMess节点，其不支持UDP请注意！） 右键桌面右下角任务栏里的v2rayN图标，选择路由-》绕过大陆 右键桌面右下角任务栏里的v2rayN图标，选择系统代理-》自动配置系统代理，此时图标会变红色，意味着魔法上网成功 如果想取消魔法上网，选择系统代理-》清除系统代理 此时对于笔记本，直接启动一个wifi热点，连接到该热点的设备即可实现魔法上网。\n这里还有个问题，Windows系统版本在更新了某两个版本（kb5014697和kb5014699）后存在一个bug，会导致发射的魔法上网的wifi热点失效，甚至是造成蓝屏，需要回退到更新之前的版本。\n卸载方法如下：\n点击开始菜单 -\u0026gt; 打开设置 进入设置后点击查看历史更新记录 点击上方卸载更新 卸载最近的更新即可。特别是kb5014697和kb5014699相关的更新。最好把2022-06-10号之后含有KB的更新都卸载了 具体可以参考这篇文章：Win系统蓝屏\u0026amp;网络问题解决方案\nwifi支持UDP转发 启动Quest2设备，必须全程充电！！！\n按照指引操作，一路到wifi界面，连接上刚刚发射的热点，如果热点不能魔法上网，那么在连接wifi时会一直报错。\n仅仅wifi支持魔法上网还无法激活，因为初始启动Quest2需要更新驱动，由于更新时要发包到Quest2的服务器，该服务器是用udp协议，通常情况下Quest2在启动并连接wifi后，会卡在更新界面，一直卡在0%的进度。\n这时候电脑需要用到另一个软件SSTap（百度下载，GitHub上也有，最新版本是SSTap-beta-setup-1.0.9.7.exe）。\n启动SSTap后操作如下：\n点击代理一栏的+号，选择添加SOCKS5代理 服务器填127.0.0.1，端口填10808，分组名称和Country随便填，然后点保存 模式一栏选择不代理中国IP 点击代理一栏的闪电图标，可以测试当前udp连接是否正常 点击连接，此时成功连接上上面v2rayN的SOCKS服务器节点（10808就是默认的SOCKS端口） 此时，wifi就可以转发UDP报文了，如果Quest2设备的更新进度条没动弹，可以按照开机键选择重启设备，重新连接一遍wifi即可。更新速度取决于你的节点，这也是为什么用付费节点的原因，免费节点通常使用人数多，流量有限，在更新这一步很可能下载个大半天都更新不到一半进度。\n连接wifi后app无法联网 由于设备默认使用网络时间，过段时间后会发现系统时间和实际时间对不上，会导致app无法联网。这时候需要安装Settings Oculus Quest2这个app来修改系统时间，安装后打开该app，将使用网络时间选项关闭，就可以直接修改系统时间了，改完系统时间后就可以正常联网了。\n使用技巧 开启透视模式 在头显的任意一侧连续敲击两下，会开启透视模式，类似于夜视仪视野，这样就不需要把头显摘下来也能直接看到周围事物。\n进入透视模式后再次连续敲击两下头显的任意一侧，就会退出透视模式。\n快速关机 按住开机键不放时，会弹出设置菜单，这时候继续按住开机键三秒钟，会直接自动关机，而不需要手柄去选择关机按钮。\n手势模式 在设置里开启手势模式后，不需要手柄也能操作设备，设备会识别手势而做出对应的操作，设备里自带了几个教程视频，可以去看看。某些游戏就扩充了手势识别，需要开启手势功能才能游玩。\n注意使用手势的前提是，手柄要远离头戴一段距离才行，不然不会激活手势模式。\n快速截屏 截屏快捷键是同时按住右侧手柄Oculus键 + 扳机（左右都可），截图成功会有弹窗和提示音。\n投屏 手机或电脑安装了CastReceiver软件后，只要和Quest2连接同一个wifi，无需翻墙即可投屏。\n操作步骤是：\n手机或电脑启动CastReceiver软件 Quest2连接同一个wifi，在下方菜单栏里选择分享按钮（一个向右的箭头图标），接着选择投屏，选择需要投屏到哪个设备即可。 开启开发者模式 只有开启了开发者模式才能安装来源不明的应用（比如破解版游戏），在开启之前需要做一些准备。\n手机安装Oculus App 安卓手机要先安装谷歌三件套：\n谷歌服务框架（Google Services Framework） 谷歌服务（Google Play Services） 谷歌商店（Google Play Store） 一个最简单的办法就是用Go谷歌安装器，将该软件下载到安卓手机后直接启动就能傻瓜式自动安装三件套。下载地址：https://www.coolapk.com/apk/com.goplaycn.googleinstall\n相关文章可以看这个：安卓手机安装谷歌三件套的方法\n安装好后启动谷歌商店，下载Oculus App并安装（安卓去google play下载，苹果去Apple Store下载，外区。）\n手机的Oculus App可以通过蓝牙连接设备，可以在App的邮箱通知里领取赠送节奏光剑的游戏（是英文邮件），还可以用app来控制设备连接哪一个wifi。\n安装Oculus电脑端 电脑安装Oculus：https://oculus.en.softonic.com/\n安装的时候默认安装在C盘，可以通过下面方式安装到其他磁盘：\n右键单击下载好的安装文件OculusSetup.exe，创建快捷方式，然后右键单击新创建的快捷方式，在目标（T）那里显示的内容后面加上 /drive=D，然后保存并双击该快捷方式即可安装到D盘，想安装到其他盘修改D为其他盘符即可。注意/drive前是有个空格的。 安装好后即可在电脑端启动Oculus应用，Oculus电脑端会有更多的选项可以设置。但是启动时，即使开了魔法上网，依然可能无法登陆，此时需要修改hosts文件：\n打开C:\\Windows\\System32\\drivers\\etc目录，用记事本打开\thosts文件 在该文件末尾添加如下内容： 1 2 3 4 5 6 7 157.240.11.49 graph.oculus.com 157.240.11.49 www2.oculus.com 157.240.8.49 scontent.oculuscdn.com 157.240.8.49 securecdn.oculus.com 保存时会让你选择路径，选择桌面，将桌面保存后文件后缀 .txt删掉，之后将该文件替换掉C:\\Windows\\System32\\drivers\\etc目录的hosts文件。 如果是用其他编辑器如Nodepad++等，则无需这么麻烦，直接修改即可保存替换原文件。 然后需要刷新DNS缓存才能生效：\n按下Windows + R组合键，输入cmd开启运行命令窗口 输入ipconfig /flushdns，然后回车即可 申请开发者账号 打开https://dashboard.oculus.com/organizations/create网站，并登陆Oculus账号 选择Create New Organization，随便输入组织名，点击Submit提交 查看保密协议，点击接受 绑定信用卡即可创建完毕，如果没有信用卡，可以绑定PayPal账号，这个不需要翻墙就能直接注册一个PayPal账号，直接绑定一张银联卡即可（通常绑定工资卡就行） 验证手机号（验证的地址：https://developer.oculus.com/manage/verify/），这里网站有个bug，如果之前注册Facebook账号时已经绑定了手机号，这里会卡住无法下一步。需要先去Facebook解除绑定手机号，然后重新绑定一次，接着重新回到网站这边即可正常验证手机号。 此时Oculus账号申请开发者账号成功，可以进入下一步了。\n开启开发者模式 电脑下载Oculus Developer Hub（以下简称ODH）并安装：https://developer.oculus.com/downloads/native-android/ 启动Quest2设备，用数据线连接电脑，戴上VR设备在里面选择允许电脑读取。 启动ODH，使用已经创建好的开发者账户登录 进入软件后选择Device Manager-》Set Up New Device 一直下一步，连接上能魔法上网的WiFi，然后勾选Enable Developer Mode 戴上VR设备，在里面选择允许此电脑使用USB调试 这样设备的开发者模式就启动成功了，以后也可以随意关闭开发者模式，手机app也可以勾选或取消开发者模式。\n解决连接受限、不自动连接WiFi 由于Quest2启动后会发数据包到服务器，如果此时wifi不是支持魔法上网且udp转发的，则wifi会由于连接受限而不会自动连接wifi，就算连接了wifi也会显示连接受限。\n首先你需要安装adb，如果有安装上一步的Oculus Developer Hub，那么去其安装路径下的\\resources\\bin目录可以找到adb.exe，在该目录下的地址栏里输入cmd，并按下回车，可打开运行命令窗口，输入下面命令：\n1 adb devices 该命令会检测设备是否连接电脑，在执行该命令前需要先把Quest2连接到电脑上。\n然后执行命令：\n1 adb shell settings put global captive_portal_mode 0 该命令会关闭Quest2设备的检测功能，即不会发送数据包到服务器。\n最后执行命令：\n1 adb shell settings put global captive portal_https_url http://connect.rom.miui.com/generate_204 这个命令是将数据包发送到指定的url，实际上只要关闭了检测，没有这一步应该也是一样的效果。\n此时Quest2设备已经可以正常连接上国内的网络wifi，然后你就可以快乐地跟其他朋友用国内网络来本地联机了。\n游戏推荐 节奏光剑（BeatSaber） 忍者传奇 皮鞭手枪 超热 攀爬2 爆裂球拍 真实乒乓球 无界术士·黑暗时代 龙与地下城 愤怒的小鸟·猪之岛 Rez无限 地下世界 小魔女学园 illusion的VR游戏（朋友强推VR女友，恋活和hs2） Quest商城的游戏很贵，没条件购买的可以直接安装个VR87助手，里面有很多破解版游戏可以玩，不过网传玩破解游戏可能被Facebook封号，这个就见仁见智了。\n需要注意，不同游戏的确认键是不一样的，有的是右手柄的A键，有的是触发键（即食指对应的按键），在进入游戏后都按下试试。通常B键是返回按键，左手柄的Oculus键可以调出游戏菜单，右手柄的Oculus键可以调出系统菜单，通常会用系统菜单里的录屏或者退出游戏功能。\n安装第三方软件 将设备启动后用数据线（Link串流线也行）连接电脑后，即可在我的电脑中看到Quest这个设备，类似于将手机连接到电脑，打开这个Quest设备即可像操作U盘一样，随意将文件拷贝到Quest2中，也可以删除Quest2中的文件。\n如果想要安装第三方软件，需要用到SideQuest软件。电脑安装该软件，启动SideQuest，会自动检测是否连接到VR设备。当设备连接电脑后，并且设备连接wifi后，SideQuest即可操作VR设备。\n此时SideQuest相当于一个安卓模拟器，将想要安装的apk文件拖动到SideQuest里即可。\n安装好的第三方软件，可以在Quest2设备中的应用 - 未知来源找到。未知来源应用不会显示图标，为了便于管理，可以安装个VR87助手，在里面的管理里可以像手机一样展示和管理这些未知来源应用。\n软件推荐 SKYBOX（看3d视频、全景视频） 飞猪播放器（除了看视频，还能看全景图片） 火狐浏览器VR版 SideQuest（新版本可以直接安装在Quest2里，需要魔法上网才能使用，可以更换主控室场景！） v2rayNG（只要连接国内wifi即可直接魔法上网，无需前文那么复杂的流程，订阅节点地址可以通过电脑端的sidequest的传输文本功能自动输入） 参考链接 VR一体机眼镜推荐 Oculus Quest2激活踩坑记录（仅供个人记录使用） Oculus开启开发者模式202110月版教程 超详细Oculus Quest2激活使用攻略，手把手带你玩转Quest2 转贴：Oculus Quest 解锁+SideQuest安装教程 Quest2操作教程 ","permalink":"https://lewky.cn/posts/oculus-quests/","tags":["VR"],"title":"Oculus Quest2食用指南"},{"categories":["生活"],"contents":"前言 自从看了老菊的背包英雄视频后，最近几周都痴迷于这款体量虽小但却很精品的肉鸽页游。各种套路组合挺多，机制也有意思，引入了常规肉鸽里不存在的背包空间限制，对于build的构建很有挑战。加上通关后还有个无尽模式，一直在尝试无尽模式能打到多远。今天通关了无尽，记录下攻略，也不算白白浪费了这段时间的努力。\n这是游戏的官方地址，官方自带中文翻译，如果访问不了的也可以去灵动游戏上玩。\n无尽模式匕首流 目前版本匕首流应该是强度最高的，组件集齐后可以无脑通关无限层，并且和菜刀流相比优势在于回合结束很快，不需要漫长的刮痧浪费时间。运气好的话，经过大量sl，可以在40层之前就集齐组件，具备通关无限层的条件。\n首先无尽模式下每9层为一个轮回，每过一轮最终boss壁虎大师增长16200血量，因此组件思路就是在一个轮回内输出伤害能够赶上boss的血量增长，这样就能无脑通关无尽模式。\n诅咒流提供开局精力 本套路参考了灵动游戏论坛里的匕首流攻略，并加以改善。首先需要开局一把刺客匕首，然后组件需要诅咒流提供大量精力。诅咒流就是用绿宝石手镯配合诅咒来在第一回合加额外精力，只有第一回合才有效。9个格子的诅咒流可以收益最大化，即5个手镯+4个诅咒，可以在第一回合可以提供12精力，加上自带3精力就是15精力，如果有风车就是16精力。考虑到风车占2个格子，因此诅咒流成型后就不需要风车了。\n诅咒流带2个荆棘诅咒和2个蜂蜜诅咒 ，蜂蜜诅咒可以在蜜蜂那主动被诅咒，荆棘诅咒则是从那个问号扔盾拿道具那里获取。道具里固定有一个随机诅咒，每次重新点开可以刷新诅咒（不用重新读取存档），直到刷新出荆棘诅咒。\n盾牌流提供高频输出 然后是盾之精灵+老头盾+大力神盾+胶带+蜡烛打输出。前期还需要秒表对冲盾之精灵的负面效果，没有秒表可以用3把国王/女王菜刀+匕首腰带过渡。蜡烛用来打反伤，没有蜡烛可以先用镜盾来代替，匕首流优势在于攻击力高，攻击次数少，因此不是很害怕反伤。如果盾附魔了比较多的疾速甚至不需要蜡烛。\n最终后期需要6个胶带，1个大力神盾，8个老头盾。注意，大力神盾只能有1个，因为盾之精灵的机制跟菜刀流一样，一个盾牌只能触发一次匕首，但是盾之精灵的负面效果可以反复触发，如果大力神盾超过一个，就会导致负面效果反复触发，极大降低了匕首伤害。关于匕首的附魔，需要选择5固伤，狂暴和中毒没啥作用，因为不吃磨刀石的倍率，而5固伤可以吃到倍率加成，因此上限更高，相当于杀了五个怪的成长。\n连帽衫提供血量上限 另外还需要一件红色连帽衫来增长血量上限，每场战斗触发一次，诅咒流带的荆棘诅咒可以完美配合连帽衫自我扣血，因此也需要一颗回血宝石来回血。如果地图问号有卖药水的，可以去卖血买一次，也可以触发连帽衫效果。血量上限有兴趣的可以一直堆上去，根据实际情况来看有个三四百血就很安全了。在遇到转盘人物又背包空间不够时，可以把连帽衫丢了，先把磨刀石刷起来，事后再重新带个连帽衫。\n匕首流倍率成长分析 下面是26层时的装备图：\n匕首流无尽26层\r诅咒流15精力开局\r此时开局第一回合由于诅咒流可以有15精力，因此可以有7次大力神盾出手+1次老头盾出手，相当于7*5+1=36刀刺客匕首的伤害。这里有秒表对冲了盾之精灵的负面效果。\n假设每一轮无尽9层有50个怪，我们需要在第一个回合就秒掉boss，为了赶上boss的生命成长，那么刺客匕首的伤害倍率为16200/36/50=9。一个黄金磨刀石倍率为25%，也就是说刺客匕首需要刷32个黄金磨刀石，每过一轮无尽刷50个怪，才能赶上boss的生命成长。\n当然这个其实不难sl，前期sl几次商店来提高基数。中后期不sl商店，效率太低，可以选择sl大转盘那个人物，只要平时多屯钱，遇到一次转盘人物就可以直接毕业一个组件。比如我最多时一次花400金币转出来16个黄金磨刀石，而胶带和老头盾这些都很简单，各遇到一次转盘人物就能毕业。\n下图是完整的组件，当然可以更进一步把红色连帽衫换成胶带和老头盾来提供更高输出。\n匕首流无尽72层\r匕首流无尽73层\r此时开局15精力，8个老头盾+1个大力神盾+6个胶带可以一次出手触发9次匕首，总共是7次大力神盾出手+1次老头盾出手，相当于出手了7*9+1=64次匕首。\n套用上面的倍率公式：16200/64/50=5.06，按5.25算，那么只需要刷17个黄金磨刀石就能无脑通关无尽模式。也就是说，运气好的话，只需要sl3次转盘人物，就能把磨刀石、老头盾和胶带毕业。至于诅咒流用到的5个绿宝石手镯，这玩意不需要特意刷，爆率特别高随便出。根据体感来看，老头盾虽然只是罕见装备，但是特别难出。。\n按照这个公式，上图我的匕首已经伤害大大溢出了，基本上都是出手3次最终boss就死了，还能剩下一半精力。\n参考链接 背包英雄：版本T0匕首流（qq930265237） ","permalink":"https://lewky.cn/posts/backpack-hero-dagger/","tags":["游戏","背包英雄"],"title":"背包英雄：匕首流无尽模式详细攻略"},{"categories":["计算机"],"contents":"bad interpreter: No such file or directory 在Windows环境下用Notepad++写了个shell脚本，上传到Linux平台后运行报错如下：\n1 /bin/sh^M: bad interpreter: No such file or directory 经过查阅资料才知道，这是文件格式导致的问题：使用vi/vim进入该shell文件，按下:进入末行模式，输入set ff查询文件格式，结果如下：\n1 fileformat=dos 不同的操作系统使用了不同的符号来换行，可以简单参考下下面的表格：\n系统 换行符 DOS CR/LF UNIX LF MAC CR 如果通过Windows下的Git将文件提交到Linux上的服务器，也会收到换行符将被替换的消息通知。而解决方法也很简单，切换文件格式即可，如下：\n通过vi/vim进入想要修改的文件，按下:进入末行模式，输入set fileformat=unix，接着按下ZZ或者按下shift + z + z或者输入:x或者:wq保存修改即可。\n判断网络是否连通 ssh命令 有个通用命令，Windows和Linux都能使用，如下：\n1 ssh ip -v -p port -v表示调试模式，会打印出具体日志。-p表示端口号。如果网络连通则会打印出来连接已建立Connection established。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 C:\\Users\\10191\u0026gt;ssh localhost -v -p 1313 OpenSSH_for_Windows_8.1p1, LibreSSL 3.0.2 debug1: Connecting to localhost [::1] port 1313. debug1: connect to address ::1 port 1313: Connection refused debug1: Connecting to localhost [127.0.0.1] port 1313. debug1: Connection established. debug1: identity file C:\\\\Users\\\\10191/.ssh/id_rsa type 0 debug1: identity file C:\\\\Users\\\\10191/.ssh/id_rsa-cert type -1 debug1: identity file C:\\\\Users\\\\10191/.ssh/id_dsa type -1 debug1: identity file C:\\\\Users\\\\10191/.ssh/id_dsa-cert type -1 debug1: identity file C:\\\\Users\\\\10191/.ssh/id_ecdsa type -1 debug1: identity file C:\\\\Users\\\\10191/.ssh/id_ecdsa-cert type -1 debug1: identity file C:\\\\Users\\\\10191/.ssh/id_ed25519 type -1 debug1: identity file C:\\\\Users\\\\10191/.ssh/id_ed25519-cert type -1 debug1: identity file C:\\\\Users\\\\10191/.ssh/id_xmss type -1 debug1: identity file C:\\\\Users\\\\10191/.ssh/id_xmss-cert type -1 debug1: Local version string SSH-2.0-OpenSSH_for_Windows_8.1 debug1: kex_exchange_identification: banner line 0: HTTP/1.1 400 Bad Request debug1: kex_exchange_identification: banner line 1: Content-Type: text/plain; charset=utf-8 debug1: kex_exchange_identification: banner line 2: Connection: close debug1: kex_exchange_identification: banner line 3: kex_exchange_identification: Connection closed by remote host nc命令 如果服务器里无法使用ssh命令，可以使用下面的命令：\n1 nc -vz -w 2 ip port -v表示可视化，-z扫描时不发送数据，-w后面跟的数字表示超时几秒。用法如下：\n1 2 3 4 5 6 7 // 端口能通 C:\\Users\\10191\u0026gt;nc -vz -w 2 1.2.3.70 8888 1.2.3.70 (1.2.3.70:8888) open // 端口不能通 C:\\Users\\10191\u0026gt;nc -vz -w 2 1.2.3.70 8889 nc: 1.2.3.70 (1.2.3.70:8889): Operation timed out 查看端口是否启用 lsof命令 该命令用于列出系统已经打开的所有文件，在Linux中任何事物都以文件形式存在，通过文件可以访问常规数据、网络连接和硬件等。但该命令需要访问核心内存和各种文件，因此需要root用户执行。\n1 2 3 4 lsof -i:port // 查39007端口是否启用 lsof -i:39007 netstat命令 1 2 3 4 netstat -aptn // 查39007端口是否启用 netstat -aptn | grep 39007 查看和修改Linux的时区 查看当前时区 1 date -R 修改设置Linux服务器时区 1 2 3 4 5 6 7 8 // Linux通用 tzselect // 仅限于RedHat Linux 和 CentOS timeconfig // 适用于Debian dpkg-reconfigure tzdata 复制相应的时区文件，替换系统时区文件；或者创建链接文件 1 2 3 4 cp /usr/share/zoneinfo/$主时区/$次时区 /etc/localtime // demo：设置中国时区使用亚洲/上海(+8) cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 查看和修改Linux的时间 查看时间和日期 1 date 设置时间和日期 1 2 3 4 5 // 将系统日期设定成2009年11月3日的命令 date -s 11/03/2009 // 将系统时间设定成下午5点55分55秒的命令 date -s 17:55:55 将当前时间和日期写入BIOS，避免重启后失效 1 hwclock -w 附注 1 2 3 4 5 // 不加参数可以直接看到当前日期时间 date // 不加参数可以直接看到本月月历 cal vi/vim打开文件提示Found a swap file by the name swap文件来源 在使用vi或vim命令打开一个文件后，就会产生一个.(filename).swp的文件。如果编辑完成之后，正常退出，那么这个swp文件就会被自动删除。但是如果在操作该文件时发生了异常中断(非正常退出)，就会在当前目录下生成了一个对应的swp文件。\n在Linux中，以.开头的文件都是隐藏文件，可以通过使用ll -a或者ls -a来查看。\n而这种swp文件是隐藏文件，有两个作用：\n避免用多个程序编辑同一个文件时，产生两个不同的版本。 非常规退出时，文件恢复。 删除swp文件 只要将swp文件删除，就不会再出现这个提示。可以通过rm命令来删除该文件。\n禁止生成swp文件 如果想要禁止生成swp文件，可以通过修改vim的配置文件来实现。新建一个~/.vimrc文件，在文件中添加一行代码：\n1 set noswapfile 这样该配置就只会对当前用户生效，你也可以直接修改/etc/vimrc文件，效果是一样的。\n通过swp文件来恢复文件 swp文件可以用来恢复文件，假如你有一个swp文件.my.ini.swp，可以通过以下命令来恢复：\n1 vi -r my.ini 恢复文件之后可以把swp文件删除，不然每次打开my.ini文件时都会提示。\nLinux命令英文全称 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 su：Swith user 切换用户，切换到root用户 cat: Concatenate 串联 uname: Unix name 系统名称 df: Disk free 空余硬盘 du: Disk usage 硬盘使用率 chown: Change owner 改变所有者 chgrp: Change group 改变用户组 ps：Process Status 进程状态 tar：Tape archive 解压文件 chmod: Change mode 改变模式 umount: Unmount 卸载 ldd：List dynamic dependencies 列出动态相依 insmod：Install module 安装模块 rmmod：Remove module 删除模块 lsmod：List module 列表模块 alias :Create your own name for a command bash :GNU Bourne-Again Shell linux内核 grep:global regular expression print httpd :Start Apache ipcalc :Calculate IP information for a host ping :Send ICMP ECHO_Request to network hosts reboot: Restart your computer sudo:Superuser do /bin = BINaries /dev = DEVices /etc = ETCetera /lib = LIBrary /proc = PROCesses /sbin = Superuser BINaries /tmp = TeMPorary /usr = Unix Shared Resources /var = VARiable ? FIFO = First In, First Out GRUB = GRand Unified Bootloader IFS = Internal Field Seperators LILO = LInux LOader PS = Prompt String Perl = \u0026#34;Pratical Extraction and Report Language\u0026#34; = \u0026#34;Pathologically Eclectic Rubbish Lister\u0026#34; Tcl = Tool Command Language Tk = ToolKit VT = Video Terminal YaST = Yet Another Setup Tool apt = Advanced Packaging Tool ar = archiver as = assembler bash = Bourne Again SHell bc = Basic (Better) Calculator bg = BackGround cal = CALendar cat = CATenate cd = Change Directory chgrp = CHange GRouP chmod = CHange MODe chown = CHange OWNer chsh = CHange SHell cmp = compare cobra = Common Object Request Broker Architecture comm = common cp = CoPy cpio = CoPy In and Out cpp = C Pre Processor cups = Common Unix Printing System cvs = Current Version System dc = Desk Calculator dd = Disk Dump df = Disk Free diff = DIFFerence dmesg = diagnostic message du = Disk Usage ed = editor egrep = Extended GREP elf = Extensible Linking Format elm = ELectronic Mail emacs = Editor MACroS eval = EVALuate ex = EXtended exec = EXECute fd = file descriptors fg = ForeGround fgrep = Fixed GREP fmt = format fsck = File System ChecK fstab = FileSystem TABle fvwm = F*** Virtual Window Manager gawk = GNU AWK gpg = GNU Privacy Guard groff = GNU troff hal = Hardware Abstraction Layer joe = Joe\u0026#39;s Own Editor ksh = Korn SHell lame = Lame Ain\u0026#39;t an MP3 Encoder lex = LEXical analyser lisp = LISt Processing = Lots of Irritating Superfluous Parentheses ln = LiNk lpr = Line PRint ls = list lsof = LiSt Open Files m4 = Macro processor Version 4 man = MANual pages mawk = Mike Brennan\u0026#39;s AWK mc = Midnight Commander mkfs = MaKe FileSystem mknod = MaKe NODe motd = Message of The Day mozilla = MOsaic GodZILLa mtab = Mount TABle mv = MoVe nano = Nano\u0026#39;s ANOther editor nawk = New AWK nl = Number of Lines nm = names nohup = No HangUP nroff = New ROFF od = Octal Dump passwd = PASSWorD pg = pager pico = PIne\u0026#39;s message COmposition editor pine = \u0026#34;Program for Internet News \u0026amp; Email\u0026#34; = \u0026#34;Pine is not Elm\u0026#34; ping = Packet InterNet Grouper pirntcap = PRINTer CAPability popd = POP Directory pr = pre printf = PRINT Formatted ps = Processes Status pty = pseudo tty pushd = PUSH Directory pwd = Print Working Directory rc = runcom = run command, shell rev = REVerse rm = ReMove rn = Read News roff = RunOFF rpm = RPM Package Manager = RedHat Package Manager rsh, rlogin, = Remote rxvt = ouR XVT sed = Stream EDitor seq = SEQuence shar = SHell ARchive slrn = S-Lang rn ssh = Secure SHell ssl = Secure Sockets Layer stty = Set TTY su = Substitute User svn = SubVersioN tar = Tape ARchive tcsh = TENEX C shell telnet = TEminaL over Network termcap = terminal capability terminfo = terminal information tr = traslate troff = Typesetter new ROFF tsort = Topological SORT tty = TeleTypewriter twm = Tom\u0026#39;s Window Manager tz = TimeZone udev = Userspace DEV ulimit = User\u0026#39;s LIMIT umask = User\u0026#39;s MASK uniq = UNIQue vi = VIsual = Very Inconvenient vim = Vi IMproved wall = write all wc = Word Count wine = WINE Is Not an Emulator xargs = eXtended ARGuments xdm = X Display Manager xlfd = X Logical Font Description xmms = X Multimedia System xrdb = X Resources DataBase xwd = X Window Dump yacc = yet another compiler compiler 参考链接 bash: ./a.sh: /bin/bash^M: bad interpreter: No such file or directory的解决方法 DOS、Mac 和 Unix 文件格式+ UltraEdit使用 DOS文件转换成UNIX文件格式详解 Linux系统查看当前时间的命令 linux下vi操作Found a swap file by the name 非正常关闭vi编辑器时会生成一个.swp文件 Linux怎么查看端口是否启用 ","permalink":"https://lewky.cn/posts/linux-issues/","tags":["工作记录","Linux"],"title":"Linux问题汇总"},{"categories":["工作记录"],"contents":"无法更改请求报文的编码 在测试接口的时候发现，在Header中用Content-type指定编码为GBK也没有效果，服务端收到的报文始终是UTF-8编码的字节数组。在查阅资料后得出结论，就是Postman限制死了请求报文的编码为UTF-8，无法通过配置等方式进行修改，如果需要使用其他编码，要么换其他HTTP工具，要么用Java写一段代码去测试接口。\n这里使用的Postman是6.7.4版本，也许更高版本的允许更改请求报文编码，由于工作环境不允许更换工具或者升级版本，这里采用了Java代码的方式去发送接口，如下：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.5.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.UnsupportedEncodingException; import org.apache.http.HttpEntity; import org.apache.http.client.methods.CloseableHttpResponse; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.BasicHttpEntity; import org.apache.http.impl.client.CloseableHttpClient; import org.apache.http.impl.client.HttpClients; import org.apache.http.util.EntityUtils; public class HttpUtils { private static final String url = \u0026#34;http://localhost:39007/\u0026#34;; private static final String contentType = \u0026#34;application/xml;charset=GBK\u0026#34;; public static void main(String[] args) { String message = \u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; encoding=\\\u0026#34;GBK\\\u0026#34;?\u0026gt;\u0026lt;custNm\u0026gt;小明\u0026lt;/custNm\u0026gt;\u0026#34;; String encoding = \u0026#34;GBK\u0026#34;; byte[] content = null; try { content = message.getBytes(encoding); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } doPost(url, contentType, content, encoding); } private static void doPost(String url, String contentType, byte[] content, String encoding) { CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPost httpPost = new HttpPost(url); // 请求头 httpPost.addHeader(\u0026#34;Content-type\u0026#34;, contentType); // 请求实体 BasicHttpEntity entity = new BasicHttpEntity(); entity.setChunked(false); // 禁止分块编码 entity.setContentEncoding(encoding); entity.setContentLength(content.length); entity.setContent(new ByteArrayInputStream(content)); httpPost.setEntity(entity); // 执行请求 CloseableHttpResponse httpResponse = null; HttpEntity responseEntity = null; try { httpResponse = httpClient.execute(httpPost); responseEntity = httpResponse.getEntity(); String result = EntityUtils.toString(responseEntity); System.out.println(result); } catch (IOException e) { e.printStackTrace(); } finally { closeQuietly(httpClient); closeQuietly(httpResponse); } } /** * 关闭资源 */ private static void closeQuietly(CloseableHttpResponse httpResponse) { if (httpResponse != null) { try { httpResponse.close(); } catch (IOException e) { e.printStackTrace(); } } } /** * 关闭资源 */ private static void closeQuietly(CloseableHttpClient httpClient) { if (httpClient != null) { try { httpClient.close(); } catch (IOException e) { e.printStackTrace(); } } } } 另外，GBK仅支持简体中文和繁体中文，对于某些业务（如银行业务等），可能需要使用GB18030来支持更多的中文字符，包括藏文、蒙文、维吾尔文等主要的少数民族文字。\n参考链接 计算机字符编码中GBK GB2312 GB18030有什么区别 谁包含的东西多？谁更早？ ","permalink":"https://lewky.cn/posts/postman-issues/","tags":["Postman"],"title":"Postman问题汇总"},{"categories":["生活"],"contents":"江湖路远，有缘再见 感谢这一路走来的欢笑与感动，东北的小狼公主提前离开了城堡，皇家骑士们依然守候在身后。\n别了，珈乐。\nA-Soul珈乐\r","permalink":"https://lewky.cn/posts/asoul-jiale/","tags":["A-Soul"],"title":"别了，珈乐"},{"categories":["计算机"],"contents":"桌面窗口管理器（dwm.exe）内存泄漏 自从某天更新了Intel的核显驱动后，就发现电脑开机一段时间后必然发生卡顿，后来发现每次卡顿都是桌面窗口管理器（dwm.exe）占用内存过高。观察一段时间后发现，该进程内存会无限增加，怀疑发生了内存泄漏。在知乎搜索后发现很多人遇到了同款问题，这里记录下解决方法。\nIntel核显驱动降级 经本人测试，将驱动降级到27.20.100.8190是可行的，直接官网下载并用旧版本覆盖安装即可：Intel® Graphics – Windows* DCH Drivers\n上面的官方下载链接里可以自行选择其他版本，这里附上其他人测试的可行的版本：26.20.100.8141，26.20.100.7985\n上述三种驱动不适用于10代桌面U，需要尝试27.20.100.8336或27.20.100.8476\n另外，在安装之前，记得先取消驱动的自动更新，否则你会发现安装后重启电脑就又自动更新成新版本驱动了。\nWin10如何取消驱动自动更新 此电脑右键菜单选择属性 -\u0026gt; 点击高级系统设置 -\u0026gt; 切换到硬件面板 -\u0026gt; 点击设备安装设置 -\u0026gt; 选择否，然后保存更改。\n参考链接 桌面窗口管理器（dwm.exe）占用内存高怎么办？ win10自动更新显卡驱动 怎么关闭 ","permalink":"https://lewky.cn/posts/dwm-issues/","tags":["计算机"],"title":"桌面窗口管理器占用内存过高"},{"categories":["ELK"],"contents":"创建索引 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // 创建blog索引，类型是_doc，id是1 curl -H \u0026#39;Content-Type:application/json\u0026#39; -XPUT http://localhost:9200/blog/_doc/1 -d \u0026#39; { \u0026#34;id\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;New version of Elasticsearch released!\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Version 1.0 released today!\u0026#34;, \u0026#34;priority\u0026#34;: 10, \u0026#34;tags\u0026#34;: [\u0026#34;announce\u0026#34;, \u0026#34;elasticsearch\u0026#34;, \u0026#34;release\u0026#34;] }\u0026#39; // 创建blog索引，类型是_doc，id由ES自己生成 // 该id长度为20个字符，URL安全，base64编码，GUID，分布式系统并行生成时不可能会发生冲突 curl -H \u0026#39;Content-Type:application/json\u0026#39; -XPOST http://localhost:9200/blog/_doc/ -d \u0026#39; { \u0026#34;title\u0026#34;: \u0026#34;New version of Elasticsearch released!\u0026#34;, \u0026#34;content\u0026#34;: \u0026#34;Version 1.0 released today!\u0026#34;, \u0026#34;priority\u0026#34;: 10, \u0026#34;tags\u0026#34;: [\u0026#34;announce\u0026#34;, \u0026#34;elasticsearch\u0026#34;, \u0026#34;release\u0026#34;] }\u0026#39; 查询索引 1 2 3 4 5 6 7 // 查询索引，v参数会显示column，对应的column可以作为url参数并配合通配符来使用 GET http://localhost:9200/_cat/indices?v GET http://localhost:9200/_cat/indices?v\u0026amp;index=item* // 查询blog索引中id为1的文档，pretty参数会格式化返回的json，可以只查询文档的_source节点 GET http://localhost:9200/blog/_doc/1?pretty GET http://localhost:9200/blog/_doc/1/_source?pretty 删除索引 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 删除索引，可以同时删除多个索引，也可以使用通配符或_all，_all是删除所有索引 // 不建议使用通配符或_all，万一误删索引影响较大 DELETE http://localhost:9200/blog DELETE http://localhost:9200/blog1,blog2 DELETE http://localhost:9200/blog* DELETE http://localhost:9200/_all // delete_by_query，会通过批处理来删除查询到的数据。 // 如果查询或批处理请求被拒绝，在默认最多重试10次后会导致delete_by_query中止，并记录在failures字段中，已删除的数据不会被回滚。 // 如果不希望故障中止，可以在URL中设置为conflicts=proceed或者在请求体中设置\u0026#34;conflicts\u0026#34;: \u0026#34;proceed\u0026#34; POST http://localhost:9200/blog/_delete_by_query { \u0026#34;query\u0026#34;: { \u0026#34;match\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;Lewis Liu\u0026#34; } } } 配置类接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 查询blog索引的配置，不指定索引则会查询所有索引的配置 GET http://localhost:9200/blog/_settings GET http://localhost:9200/_settings // 查询blog索引的映射，不指定索引则会查询所有索引的映射 GET http://localhost:9200/blog/_mapping GET http://localhost:9200/_mapping // 查询节点健康状态，如果是单节点部署则status是yellow，因为单节点部署下无法分配副本分片 // 健康状态分为红绿黄三色：green是健康，所有分片均处于可用状态。 // yellow是主分片可用，副本分片不可用或者根本没有副本分片，此时ES集群可用性降低。 // red是部分分片可用，意味着至少有部分主分片损坏。这会导致数据缺失，搜索结果可能只能返回一部分。 GET http://localhost:9200/_cluster/health?pretty GET http://localhost:9200/_cat/health?v // 查询索引的分片信息（shard，默认是5个主分片primary和1个副本分片replica，即一个主分片都有一个副本，也就是总共10个分片） // 主分片和副本分片不能在同一个节点上，换言之如果是单节点部署则无法分配副本分片 // 分片算法：shard = hash(routing) % number_of_primary_shards // 为了避免主分片数量增加导致分片路由变动，从而永远找不到旧路由下的文档，因此ES不允许在创建索引后改变主分片数量。 GET http://localhost:9200/_cat/shards?v 分段接口 ES在索引数据时会生成分段（segment，一个segment就是一个完整的lucene倒排索引），分段是不可变的，如果分段中的数据被删除了，实际上只是打了一个删除标志。ES在查询时依然会查询到分段中这些有删除标志的文件，但是在返回结果时会将其过滤。只有在合并分段时，这些文件才会被真正地物理删除，并释放被占用的内存。\n换言之，如果有频繁删改数据（由于分段文件不可变，更新文档实际上也是删除+创建文档），会生成越来越多的分段，最终影响性能，所以每隔一段时间需要对这些分段进行合并。对于一些不再更新的索引，也要主动进行合并分段操作。由于合并分段时对服务器负载较大（取决于索引的数据量），所以要挑个相对空闲的时间来合并分段。当然ES本身自己也会在分段数量达到一定程度后自动合并，只是通过主动合并分段可以提前释放被占用的内存。\n分段数量也不是越少越好，这会导致一个分段太大，使得查询性能降低，当查询效率低于期望时，这时候就需要考虑增加shard数量，提升查询的并行度。一般推荐一个shard不要超过50GB，也就是说一个segment最好也不要超过这个值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 查询所有索引的分段信息 GET http://localhost:9200/_cat/segments?v // 查询blog索引的分段信息 GET http://localhost:9200/_cat/segments/blog?v // 合并blog索引的分段，尽量避免一次性合并所有索引的分段，以免影响查询性能 // max_num_segments表示最终合并成几个大分段 POST http://localhost:9200/blog/_forcemerge?max_num_segments=1 // 查询合并分段的进度 GET http://localhost:9200/_cat/indices/?s=segmentsCount:desc\u0026amp;v\u0026amp;h=index,segmentsCount,segmentsMemory,memoryTotal,mergesCurrent,mergesCurrentDocs,storeSize,docsDeleted,p,r // 查询当前合并分段的线程数 GET http://localhost:9200/_cat/thread_pool/force_merge?s=name\u0026amp;v 除了合并分段外，也可以通过删除不用的索引、或者关闭不用的索引来减少分段的内存占用，会比合并分段操作释放更多被占用的内存。\n分词接口 1 2 3 4 5 6 7 8 9 10 // 查询blog索引中id为1的文档中的name及其子字段的分词情况 GET http://localhost:9200/blog/doc/1/_termvectors?fields=name.* // 查询词项分析，和上面接口的区别在于：这个用来测试指定字符串的词项分析情况，因此这个接口需要传入body // 查询blog索引中text字段的词项分析情况，这里指定的分析器是char_group_analyzer，字段值是test_123 GET http://localhost:9200/blog/_analyze { \u0026#34;analyzer\u0026#34;: \u0026#34;char_group_analyzer\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;test_123\u0026#34; } 查询参数 在查询时可以通过添加一些参数来达到调试的目的。\nexplain 如果想显示当前查询的打分情况，可以添加explain: true，在查询结果的hits节点中，每个命中的文档里会多出来一个_explanation节点。\n1 2 3 4 5 6 7 8 { \u0026#34;from\u0026#34;: 0, \u0026#34;size\u0026#34;: 50, \u0026#34;explain\u0026#34;: true, \u0026#34;query\u0026#34;: {}, \u0026#34;_source\u0026#34;: {}, \u0026#34;sort\u0026#34;: [] } profile 如果想显示当前查询的命中情况，可以添加profile: true，在查询结果中会多出来一个profile节点。不过需要注意的是，如果查询的索引字段很多，profile参数可能会导致当前的查询效率很慢，返回的结果也会很大。\n1 2 3 4 5 6 7 8 { \u0026#34;from\u0026#34;: 0, \u0026#34;size\u0026#34;: 50, \u0026#34;profile\u0026#34;: true, \u0026#34;query\u0026#34;: {}, \u0026#34;_source\u0026#34;: {}, \u0026#34;sort\u0026#34;: [] } 自定义的几种分词器 ES的分析（analysis）指的是用过分析器（Analyzer）将一个原始文本进行分析、分词为一个个标记或词项的过程，分析器通常分为三个部分：字符过滤器（Character filters）、分词器（Tokenizers）和标记过滤器（Token filters）。\n一个原始文本，首先经过字符过滤器来过滤特定的字符，然后分词器将其进行分词为一个个标记（Token），标记过滤器再对这些标记进行过滤（比如转成全小写）。\nES 6.4 - Analysis 下面的配置自定义了两个分析器，一个是按照指定的字符来分词，一个是ngram分词（就是将一个单词分解成若干个前缀词项，用于前缀搜索，比如将Item分解为I，It，Ite，Item）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;analyzer\u0026#34;: { \u0026#34;char_group_analyzer\u0026#34;: { \u0026#34;tokenizer\u0026#34;: \u0026#34;char_group_tokenizer\u0026#34;, \u0026#34;filter\u0026#34;: [ \u0026#34;lowercase\u0026#34; ] }, \u0026#34;ngram_analyzer\u0026#34;: { \u0026#34;tokenizer\u0026#34;: \u0026#34;ngram_tokenizer\u0026#34;, \u0026#34;filter\u0026#34;: [ \u0026#34;lowercase\u0026#34; ] } }, \u0026#34;tokenizer\u0026#34;: { \u0026#34;char_group_tokenizer\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;char_group\u0026#34;, \u0026#34;tokenize_on_chars\u0026#34;: [ \u0026#34;whitespace\u0026#34;, \u0026#34;-\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;/\u0026#34;, \u0026#34;\\\\\u0026#34; ] }, \u0026#34;ngram_tokenizer\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;ngram\u0026#34; } } } } } 将上面定义的分析器用于指定的索引字段中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \u0026#34;properties\u0026#34;: { \u0026#34;fieldA\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;fields\u0026#34;: { \u0026#34;keyword\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;ignore_above\u0026#34;: 256 }, \u0026#34;ngram_search\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;ngram_analyzer\u0026#34; }, \u0026#34;char_group_search\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;analyzer\u0026#34;: \u0026#34;char_group_analyzer\u0026#34; } } } } } 注意，在修改Settings时需要先关闭index，修改完之后再打开index：\n1 2 3 4 // 关闭索引 POST localhost:9200/\u0026lt;indexName\u0026gt;/_close // 打开索引 POST localhost:9200/\u0026lt;indexName\u0026gt;/_open 参考链接 Elasticsearch Guide 6.7 - Search Settings 2019-07-01 elasticsearch force merge 步骤 原创 segment段文件非常大会有什么问题没？比如说100G一个？ Elasticsearch 集群和索引健康状态及常见错误说明 ","permalink":"https://lewky.cn/posts/elk-6/","tags":["Elasticsearch","工作记录"],"title":"ELK系列(6) - Elasticsearch常用接口"},{"categories":["ELK"],"contents":"机器内存分配 官方推荐一个ES节点最好是分配当前机器最大内存的50%，比如机器内存是16g，就分配8g给ES：-Xmx8g。\n剩下的8g内存并不是说就闲置了，ES会拿机器剩余的内存来优化自身的查询效率。也就是说，并不是一味将最大内存设置很大就是最优解。\n优化分段内存占用 随着ES数据量的增加，分段（segment）数量会越来越多，占用的内存也会逐渐增加，可以通过以下方式来释放分段占用的内存：\n删除不用的索引 关闭索引，此时数据依然存在于磁盘，但是占用的内存会被释放 定期合并不再更新的索引的分段，将多个小分段合并成大分段，具体接口可以参考这部分文章 参考链接 Elasticsearch调优——segment memory ","permalink":"https://lewky.cn/posts/elk-5/","tags":["Elasticsearch","工作记录","性能调优"],"title":"ELK系列(5) - Elasticsearch性能调优"},{"categories":["MyBatis"],"contents":"使用domainObjectRenamingRule报错 在使用MyBatis逆向工程时报错如下：\n1 2 3 4 5 6 org.mybatis.generator.exception.XMLParserException: XML Parser Error on line 43: 必须声明元素类型 \u0026#34;domainObjectRenamingRule\u0026#34;。 at org.mybatis.generator.config.xml.ConfigurationParser.parseConfiguration(ConfigurationParser.java:121) at org.mybatis.generator.config.xml.ConfigurationParser.parseConfiguration(ConfigurationParser.java:82) at org.mybatis.generator.config.xml.ConfigurationParser.parseConfiguration(ConfigurationParser.java:74) at GeneratorSqlmap.generator(GeneratorSqlmap.java:22) at GeneratorSqlmap.main(GeneratorSqlmap.java:32) domainObjectRenamingRule该功能项是在MBG 1.3.6中新增加的功能，用于定义实体的重命名规则，常见的用途是取消表前缀。类似于columnRenamingRule，前者是重命名生成的模型对象的名称，后者是重命名表字段的名称。\n如果在低于该版本的MBG中使用该功能，会出现如下错误：\n1 XML Parser Error on line 59: 必须声明元素类型 \u0026#34;domainObjectRenamingRule\u0026#34;。 使用domainObjectRenamingRule无效 配置好了domainObjectRenamingRule后，运行逆向工程却无效果，原因是searchString的值配置不对。\n根据表名来生成的类名是按照驼峰命名法，生成的类名首字母是大写的。而searchString是区分大小写的，并且它的值是Java里的正则表达式。\n举个例子，现在有个表叫tb_vq，我希望生成的类名是Vq，而不是TbVq，可以通过domainObjectRenamingRule来实现这个功能，配置如下：\n1 2 3 4 5 \u0026lt;table tableName=\u0026#34;tb_vq\u0026#34; schema=\u0026#34;\u0026#34; enableCountByExample=\u0026#34;false\u0026#34; enableDeleteByExample=\u0026#34;false\u0026#34; enableUpdateByExample=\u0026#34;false\u0026#34; enableSelectByExample=\u0026#34;false\u0026#34; selectByExampleQueryId=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;domainObjectRenamingRule searchString=\u0026#34;^Tb\u0026#34; replaceString=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/table\u0026gt; 需要注意的是，这里的searchString必须填^Tb，这是个Java正则表达式，这里不能写成^tb，必须首字母大写，否则匹配不上，另外为了避免匹配出错，这里使用了^Tb而不是Tb。\n插入null值时报错 当插入的数据包含null值时报错：\n1 2 3 ### Cause: org.apache.ibatis.type.TypeException: Error setting null for parameter #3 with JdbcType OTHER . Try setting a different JdbcType for this parameter or a different jdbcTypeForNull configuration property. Cause: java.sql.SQLException: 无效的列类型 at org.apache.ibatis.exceptions.ExceptionFactory.wrapException(ExceptionFactory.java:26) ... 这个报错是因为MyBatis无法识别null值的类型，有两种解决方案。\n方法一 在MyBatis的配置文件中添加jdbcTypeForNull的配置，通过这个全局配置来指定null值的类型：\n1 2 3 4 5 \u0026lt;configuration\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;setting name=\u0026#34;jdbcTypeForNull\u0026#34; value=\u0026#34;NULL\u0026#34; /\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;/configuration\u0026gt; 如果是在SpringBoot中使用MyBatis-Plus，则在application.yml中配置如下：\n1 2 3 mybatis-plus: configuration: jdbc-type-for-null: \u0026#39;null\u0026#39; #注意：单引号 也可以直接定义一个Bean：\n1 2 3 4 5 6 7 8 9 10 11 12 @Bean public ConfigurationCustomizer configurationCustomizer(){ return new MybatisPlusCustomizers(); } class MybatisPlusCustomizers implements ConfigurationCustomizer { @Override public void customize(org.apache.ibatis.session.Configuration configuration) { configuration.setJdbcTypeForNull(JdbcType.NULL); } } 方法二 在sql中为允许插入null值的column单独指定对应的类型，如下：\n1 2 3 4 5 6 7 \u0026lt;insert id=\u0026#34;save\u0026#34; parameterType=\u0026#34;com.test.entity.Student\u0026#34;\u0026gt; insert into student values( student_seq.nextval, #{name,jdbcType=VARCHAR} ) \u0026lt;/insert\u0026gt; 参考链接 mybatis.generator 1.3.6中添加的domainObjectRenamingRule说明 springboot 项目mybatis plus 设置 jdbcTypeForNull （oracle数据库需配置JdbcType.NULL, 默认是Other） oracle: jdbcTypeForNull configuration property. Cause: java.sql.SQLException: 无效的列类型: 1111 ","permalink":"https://lewky.cn/posts/mybatis-issues/","tags":["MyBatis","工作记录"],"title":"MyBatis问题汇总"},{"categories":["PostgreSQL"],"contents":"查询执行很长时间的SQL（慢SQL） 可以通过查询系统表来找到目前处于活跃状态的SQL：\n1 2 SELECT * FROM pg_stat_activity WHERE datname=\u0026#39;数据库名\u0026#39; and client_addr = \u0026#39;发起查询的IP地址\u0026#39; order by state_change desc; 有个更好的办法，是安装扩展pg_stat_statements，此处需要PostgreSql支持，部分版本需要编译安装：\n1 2 3 CREATE extension pg_stat_statements; SELECT pg_stat_reset(); SELECT pg_stat_statements_reset(); 等待一段时间后就可以查询慢SQL：\n1 SELECT * FROM pg_stat_statements ORDER BY total_time DESC LIMIT 5; 查询使用Buffer次数最多的SQL：\n1 SELECT * FROM pg_stat_statements ORDER BY shared_blks_hit+shared_blks_read DESC LIMIT 5; 分析执行计划 explain可以看到sql的执行计划（但不会去执行这条sql），explain analyze或者explain analyse则可以看到真正执行sql时的执行计划。\n对于已经能够确定其性能很慢的sql不建议使用explain analyze，除非你想慢慢等它执行完再看到对应的执行计划。\nPostgreSQL的执行计划会显示出这条SQL的预估成本cost，需要扫描的数据行数量rows，扫描方式（是否使用索引等），循环次数loops等。执行计划中会使用缩减符和-\u0026gt;来表示执行时每一步的先后顺序，缩减最大的就是最早执行的SQL片段。\ncost就是执行对应的SQL片段时所需要的预估成本，包含启动成本和结束成本。不同的扫描方式其启动成本不一定一样，每一步的cost都会包含上一步的成本。\nwidth表示扫描的数据行宽度，width=0表示只获取行的位置，没有读取数据；开始读取数据后其值会大于0。\n扫描方式常见的有：\nSeq Scan：全表扫描 Index Scan，Bitmap Index Scan，Bitmap Heap Scan：索引扫描 Subquery Scan：子查询 Nested Loop：表连接查询，内表（一般是带索引的大表）被外表（也叫“驱动表”，一般为小表：相对其它表为小表，且记录数的绝对值也较小，不要求有索引）驱动，就是拿小表的数据根据连接条件去大表里进行连接查询 Hash Join：建立哈希表，由于Hash的特点只能用于等值连接（=），会将表连接的两个表数据放进内存中，需要消耗大量内存 Merge Join：等值或非等值连接（\u0026gt;，\u0026lt;，\u0026gt;=，\u0026lt;=，但是不包含!=，也即\u0026lt;\u0026gt;），需要对连接表进行排序，在非等值连接时，Merge Join比Hash Join更有效 Sort：排序 Unique：DISTINCT，UNION操作 Limit：LIMIT，OFFSET操作 Aggregate：count，sum，avg，stddev等聚合函数 Group：GROUP BY分组操作 通过分析执行计划中的成本，以及扫描方式来决定下一步怎么对SQL进行优化，下面是一些常见的调优方案。\n优化表连接 主要分为两个方向：\n尽量减少连接（外连接或内连接）其他表的次数 优化表连接的条件，尽可能确保连接条件足够充分 以上都是为了尽可能减少中间表的数据量，通过执行计划就可以很明显看到表连接的cost大幅降低。\n另外，在能使用inner join时尽量不要使用left join，inner join可以过滤掉不少不必要的数据，从而减少中间表的数据量。\n使用CTE进行预查询 公用表表达式（Common Table Expression，简称CTE），对于一个很长很复杂的sql，可以用CTE把一部分sql片段预先查询出来，该sql片段查询的结果可以被整个sql所使用。类似于在代码中抽出一个公共的方法逻辑，方便被其他方法所使用。\nCTE不仅提高了可读性，还可以非常有效地提高一条复杂长sql的查询效率，多个CTE之间可以用,分隔。语法是with \u0026lt;表名\u0026gt; as ()，如果被CTE定义的表名被调用两次以上，则优化器会自动将预查询的数据放入一个TEMP表中，如果只被调用一次则不会。\n但不是所有数据库都有实现这个功能，PostgreSQL和SQL SERVER都有提供。样例如下：\n1 2 3 4 5 6 7 8 with pre as ( select trim(both \u0026#39;{}\u0026#39; from ch.path) as \u0026#34;preLabelKey\u0026#34;,id from cnt_codelist_book_h ch limit 2 ), pre2 as ( select regexp_split_to_table(trim(both \u0026#39;{}\u0026#39; from ch.path), \u0026#39;}[^}]*{\u0026#39;) as \u0026#34;pre2LabelKey\u0026#34;,id from cnt_codelist_book_h ch limit 2 ) select distinct book.path,pre.\u0026#34;preLabelKey\u0026#34;,pre2.\u0026#34;pre2LabelKey\u0026#34; from cnt_codelist_book_h book inner join pre on pre.id = book.id inner join pre2 on pre2.id = book.id; 查询结果如下：\npath preLabelKey pre2LabelKey {lbl.codelist} \u0026gt; {lbl.common.version} lbl.codelist} \u0026gt; {lbl.common.version lbl.codelist {lbl.codelist} \u0026gt; {lbl.common.version} lbl.codelist} \u0026gt; {lbl.common.version lbl.common.version 注：上述sql中由于别名存在大小写，因此要用双引号包括起来，否则会报错。另外这里仅仅演示语法，因此写的很随意，不喜勿怪。\n优化索引 这个就不详说了，不外乎对查询条件建立索引，注意使用联合索引时的字段顺序，不过PostgreSQL对于联合索引似乎会自动优化查询时的字段顺序。\n参考链接 详解 PostgreSQL explain 查询计划 PostgreSQL执行计划的解释 SQL优化（一） Merge Join vs. Hash Join vs. Nested Loop EXPLAIN分析pgsql的性能 T-SQL查询进阶\u0026ndash;详解公用表表达式(CTE) 使用WITH AS提高性能简化嵌套SQL PostgreSql查询正在执行的SQL和查询执行耗时的SQL ","permalink":"https://lewky.cn/posts/postgresql-sql-tuning/","tags":["工作记录"],"title":"PostgreSQL - SQL调优方案"},{"categories":["Java"],"contents":"字符集 字符集是一系列字符的集合，将每个收录的字符和数字进行映射。最早的字符集是ASCII，使用一个字节进行存储字符，8位一共可以表示256个字符，而ASCII只使用了其中的128位，即0～127位，这128位里面包括了常用的英文字符以及标点符号。\n一部分不使用英文的字符可以用后面的128位来表示，即128～256位，后面的128位也被称为扩展字符集。但是它表示的字符有限，对于汉字来说，用单字节无法表示完整，因此国标码采用了双字节来表示汉字（即GBK等编码）。\n由于不同国家的语言编码不同，互相之间如何通过ASCII进行交流？于是就有了万国码Unicode。Unicode是一个几乎包括了世上所有字符的字符集，每个字符都有一个对应的独一无二的Unicode码，比如聊天时使用的emoji表情字符，GitHub上也可以通过 :grin: 这种写法来输出emoji字符，这个对应的是😁。\n因为Unicode使用四个字节来存储，虽然编码效率高，但是会极大浪费存储空间，因此就有了对Unicode字符集进行编码解码的存储方式，如UTF-8等字符编码。字符编码其实就是对Unicode字符集的实现方式，用以约定如何用1~4个字节来存储字符。\n字符编码 UTF-8 UTF-8是可变长编码，即多字节编码，在存储不同的字符时使用的字节数量是不同的。比如存储英文字母时只使用1个字节，而存储汉字时则使用3个字节。\nUTF-8分为有BOM（Byte Order Marker）和无BOM的两种编码方式，现代文本编辑器在改变文件的编码时应该都看到过这两种编码。\nUTF-8的好处是节省了空间，但编码效率降低了，即时间换空间。\nUTF-16 UTF-16是双字节编码，属于定长编码。由于使用两个字节为一组来表示一个字符，那么就涉及到了字节顺序的问题，即大端小端的问题。这个是Mac机和PC机对字节顺序的理解不一致导致的历史遗留问题，机器在读取字节顺序时，会从低地址读取，将两个字节中的高位字节放在低地址表示，这就是大端BE，即big-endian。反之就是小端LE，即little-endian。\n因此UTF-16存在三种编码：\nUTF-16BE，使用两个字节进行存储的大端编码。Java就是使用的这个编码来存储字符，中文和英文都是两个字节（即char这个基础数据类型），所以Java是双字节编码。 UTF-16LE，使用两个字节进行存储的小端编码。 UTF-16，没有指定后缀，即不知道其是大端还是小端，所以需要用四个字节来存储，开始的两个字节表示该字节数组是大端还是小端。即FE FF表示大端，FF FE表示小端。 使用UTF-16的好处是编码效率较高，但浪费存储空间，属于用空间换时间。\n不同字符集编码的英文字母和中文汉字的字节数 英文字母：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 编码：GB2312；字节数 : 1 编码：GBK；字节数 : 1 编码：GB18030；字节数 : 1 编码：ISO-8859-1；字节数 : 1 编码：UTF-8；字节数 : 1 编码：UTF-16；字节数 : 4 编码：UTF-16BE；字节数 : 2 编码：UTF-16LE；字节数 : 2 中文汉字：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 编码：GB2312；字节数 : 2 编码：GBK；字节数 : 2 编码：GB18030；字节数 : 2 编码：ISO-8859-1；字节数 : 1 编码：UTF-8；字节数 : 3 编码：UTF-16；字节数 : 4 编码：UTF-16BE；字节数 : 2 编码：UTF-16LE；字节数 : 2 参考链接 UTF-16BE、UTF-16LE、UTF-16 三者之间的区别 英文字母和中文汉字在不同字符集编码下的字节数 为什么UTF-16要有LE和BE之分 你真的了解 Unicode 和 UTF-8 吗？ ","permalink":"https://lewky.cn/posts/java-charset/","tags":["Java","字符编码"],"title":"Java - 字符编码"},{"categories":["Spring"],"contents":"前言 本文基于以下版本：\n1 2 3 4 5 6 \u0026lt;!-- 对应的是3.3.0版本的jedis（redis的java客户端） --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; SpringBoot配置Redis 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ## 配置redis连接 spring.redis.host=localhost spring.redis.port=6379 ## 是否使用redis作为cache #spring.cache.type=none spring.cache.type=redis ## 默认情况下redis中的数据永不过期 #spring.cache.redis.time-to-live=30s ## 是否存储null值 #spring.cache.redis.cache-null-values=false ## key是否使用前缀 #spring.cache.redis.use-key-prefix=true #spring.cache.redis.key-prefix=tb- RedisTemplate存储数据到Redis后key值出现\\xac\\xed\\x00\\x05 由于SpringData的redis模块用的是jedis包，因此在使用RedisTemplate操作数据时，默认使用的是JDK的序列化器JdkSerializationRedisSerializer。当存入数据到Redis后，原本的String类型或者Hash类型的key值就会变成带有\\xac\\xed\\x00\\x05前缀的值。\n建议对于String、hash类型的值，使用String序列化器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @EnableCaching @Configuration public class RedisConfig { @Bean public RedisTemplate\u0026lt;String, Object\u0026gt; redisTemplate(final RedisConnectionFactory redisConnectionFactory) { final RedisTemplate\u0026lt;String, Object\u0026gt; template = new RedisTemplate\u0026lt;String, Object\u0026gt;(); template.setConnectionFactory(redisConnectionFactory); template.setEnableDefaultSerializer(false); template.setKeySerializer(RedisSerializer.string()); template.setValueSerializer(RedisSerializer.java()); template.setHashKeySerializer(RedisSerializer.string()); template.setHashValueSerializer(RedisSerializer.string()); template.afterPropertiesSet(); return template; } } Redis宕机导致@Cacheable直接抛出异常，服务不可用 当使用@Cacheable来将数据存入Redis时，如果Redis服务器不可达会导致系统直接抛出异常，从而使得服务不可用，正常来说就算Redis挂了也不应该影响原本的业务逻辑的正常运行下去。\n需要写一个CacheErrorHandler来对上述异常进行处理：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @EnableCaching @Configuration @Slf4j public class RedisConfig extends CachingConfigurerSupport { /* * (non-Javadoc) * @see org.springframework.cache.annotation.CachingConfigurerSupport#errorHandler() */ @Override public CacheErrorHandler errorHandler() { return new CacheErrorHandler() { @Override public void handleCachePutError(final RuntimeException exception, final Cache cache, final Object key, final Object value) { log.error(\u0026#34;Failed to put key \u0026#39;{}\u0026#39; into Redis Cache: {}.\u0026#34;, key, cache.getName(), exception); } @Override public void handleCacheGetError(final RuntimeException exception, final Cache cache, final Object key) { log.error(\u0026#34;Failed to get key \u0026#39;{}\u0026#39; from Redis Cache: {}.\u0026#34;, key, cache.getName(), exception); } @Override public void handleCacheEvictError(final RuntimeException exception, final Cache cache, final Object key) { log.error(\u0026#34;Failed to evict key \u0026#39;{}\u0026#39; from Redis Cache: {}.\u0026#34;, key, cache.getName(), exception); throw exception; } @Override public void handleCacheClearError(final RuntimeException exception, final Cache cache) { log.error(\u0026#34;Failed to clear Redis Cache: {}.\u0026#34;, cache.getName(), exception); } }; } } 参考链接 RedisTemplate写入Redis数据出现无意义乱码前缀\\xac\\xed\\x00\\x05 Spring @Cacheable redis异常不影响正常业务方案 ","permalink":"https://lewky.cn/posts/spring-data-redis/","tags":["工作记录","Redis"],"title":"Spring Data Redis问题汇总"},{"categories":["Java"],"contents":"double转成BigDecimal的精度损失问题 如果直接用构造方法将double数值转成BigDecimal，可能存在损失精度的问题：\n1 2 3 4 5 6 final BigDecimal b1 = new BigDecimal(0.48); final BigDecimal b2 = BigDecimal.valueOf(0.48); // 0.479999999999999982236431605997495353221893310546875 System.out.println(b1); // 0.48 System.out.println(b2); 可以看到，第一种方式丢失了精度。原因是0.48这个浮点数实际上并不能非常精确的表示0.48这个double值，因为二进制表示的小数部分长度是有限的。\n为了避免丢失精度，需要调用官方提供的valueOf方法，实际上底层是将浮点数先转成字符串，再转成BigDecimal：\n1 2 3 4 5 6 7 public static BigDecimal valueOf(double val) { // Reminder: a zero double returns \u0026#39;0.0\u0026#39;, so we cannot fastpath // to use the constant ZERO. This might be important enough to // justify a factory approach, a cache, or a few private // constants, later. return new BigDecimal(Double.toString(val)); } 因此，也可以直接传入字符串来构造BigDecimal：\n1 2 3 final BigDecimal b3 = new BigDecimal(\u0026#34;0.48\u0026#34;); // 0.48 System.out.println(b3); 判断BigDecimal是否相等 在判断两个BigDecimal是否相等时，不能使用equals()，原因是equals()除了比较数值是否相等外，还会比较标度scale。从业务来考虑，通常只需要对比数值就行了，此时应该用compareTo()方法：\n1 2 3 4 5 6 7 8 public static void main(final String[] args) { BigDecimal a = new BigDecimal(\u0026#34;0.1\u0026#34;); BigDecimal b = new BigDecimal(\u0026#34;0.10\u0026#34;); // false System.out.println(a.equals(b)); // 0 System.out.println(a.compareTo(b)); } compareTo()会返回-1,0和1，从上述代码可以看出来，a和b的标度不同，a的标度是0.1，b的标度是0.10，所以equals()返回的false，但是由于二者数值相同，所以compareTo()返回了0。\n","permalink":"https://lewky.cn/posts/java-number/","tags":["Java","工作记录"],"title":"Java数值问题汇总"},{"categories":["工作记录"],"contents":"Eclipse安装lombok插件 方式一 使用lombok框架开发可以减少大量重复性的代码，大大提高开发效率，但是Eclipse本身并不支持lombok，会编译报错。除了项目要导入lombok依赖，还需要为Eclipse安装该lombok插件。\n安装方法很简单，找到你导入的lombok的jar包，双击运行该jar包，会出现一个安装界面。或者右键jar包，选择打开方式，接着选择Java (TM) Platform SE binary，会出现安装界面。\n在安装界面选择当前的Eclipse进程，或者点击左下角的Specify location...选择你要安装插件的Eclipse，接着点右下角的Install / Update，很快就安装完毕，点击Quit Installer。\nlombok的下载地址：https://projectlombok.org/downloads/lombok.jar\n方式二 通过jar包的方式来安装，实际上只是在eclipse的配置文件eclipse.ini中添加了一行启动参数，我们也可以自己手动添加来实现安装lombok插件的目的：\n1 -javaagent:.\\lombok-1.18.6.jar 这里的-javaagent参数后面是lombok的jar包目录。\n在Eclipse里@Slf4j和@Data无效 在Eclipse安装好lombok之后，虽然能够正常识别@Slf4j注解生成的log变量，但@Data注解依然无效：在使用到了pojo类的私有变量时，依然会提示说缺少setter/getter方法。折腾了好久，才发现原来是因为Eclipse自动给我的pojo类的私有变量加上final修饰符，导致setter/getter方法注入失败了。\n把pojo类的私有变量前边的final去掉后，@Data终于生效了。之所以会自动给变量加上final修饰符，是因为我设置了Save Action，Eclipse会自动在我保存代码的时候自动在私有变量、局部变量前加上final修饰符，这个是公司制定的代码编程规范。\n@EqualsAndHashCode 该注解默认使用当前类的非静态、非瞬态的属性来生成equals(Object other)和hashCode()方法，而@Data本身包括了这个@EqualsAndHashCode注解。\n如果一个pojo继承了其他pojo，通常是需要使用到父类里的公共字段，这时候应该使用父类的字段来参与生成equals(Object other)和hashCode()方法，此时需要将callSuper设为true，如下：\n1 2 3 4 5 6 7 @Data @EqualsAndHashCode(callSuper = true) public class ItemDto extends BaseEntityDto { private String name; } 参考链接 lombok @EqualsAndHashCode 注解的影响 我的博客即将同步至腾讯云+社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=3paqcjjzio4k8\n","permalink":"https://lewky.cn/posts/lombok-issues/","tags":["lombok"],"title":"lombok问题汇总"},{"categories":["工作记录"],"contents":"前言 常见的json框架有：Jackson，FasJson（阿里的，万年没更新，积累了大量issue），Gson（谷歌的）。其中Jackson效率最高，性能最好，最为常用。本文基于2.11.3版本的Jackson。\nJackson在1.x版本使用的包名是codehaus，后来升级到2.x版本时，为了和旧版本区分开来，采用了新的包名fasterxml。有这种类似操作的还有Log4j和Log4j2，在使用时需要注意引入的包名，避免混用版本或误用版本。\nJackson可以轻松的将Java对象转换成json对象和xml文档（即序列化），同样也可以将json、xml转换成Java对象（即反序列化）。\n序列化日期字段的时区问题 在将日期转为字符串时会使用@JsonFormat注解，默认使用零时区，因此在使用时要注意时区问题。比如项目部署在中国境内的服务器（东八区时区），不注意时区问题可能会导致json中的时间和预期的差距8个小时。\n实际开发中，假如存在多个不同时区的客户，通常是把客户所在的时区时间转换为零时区，然后存入到数据库中。这样项目从数据库读取到的时间就是零时区，再根据客户所在时区修改显示在前端页面的时间。这样比较灵活，不怕时间字段的值发生混乱，不易管理。\n在格式化成json时注解如下：\n1 2 3 4 // 将日期格式化成ISO格式 // 这里转成零时区，北京时间东八区是GMT+8 @JsonFormat(shape=JsonFormat.Shape.STRING, pattern=\u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss.SSS\u0026#39;Z\u0026#39;\u0026#34;, timezone=\u0026#34;GMT\u0026#34;) private LocalDateTime updatedOn; 另外，@DatetimeFormat是spring提供的一个注解，用以将日期转为String，提供给前端使用。\n序列化时重命名字段 可以使用@JsonProperty来重命名字段，@JsonProperty能够在序列化和反序列化时给字段映射到指定的名字：\n1 2 @JsonProperty(\u0026#34;updatedBy\u0026#34;) private String updateUserName; 如上，updateUserName在序列化为json时会被重命名为updatedBy，在反序列化时json中updatedBy的值会被映射到updateUserName。\n将这个注解和MapStruct映射框架结合起来，可以通过定义@JsonProperty来避免额外定义MapStruct框架的不同名字段映射规则；比如：@Mapping(source = \u0026quot;updateUserName\u0026quot;, target = \u0026quot;updatedBy\u0026quot;)\n还有个类似的注解@JsonAlias，其作用是给字段起别名，只在反序列化阶段有效，可以让字段接受更多的映射名称：\n1 2 @JsonAlias(\u0026#34;updatedBy\u0026#34;) private String updateUserName; 如上，在反序列化时，json中的updatedBy或者updateUserName都可以映射到pojo的updateUserName字段上。\n序列化忽略指定的字段 按照字段进行忽略 可以使用@JsonIgnore或者@JsonIgnoreProperties来忽略字段，@JsonIgnoreProperties比前者多了一个使用方式，那就是加在类上：\n1 2 3 4 5 6 7 8 // 在使用JPA-hibernate的懒加载功能时，懒加载对象会多出来`hibernateLazyInitializer`字段，这里将其忽略掉 @JsonIgnoreProperties(value = { \u0026#34;hibernateLazyInitializer\u0026#34; }) public class Item { @JsonIgnore private String tag; } 按照字段的值进行忽略 上述两个注解会直接忽略指定的字段，如果想忽略满足某个条件的字段，比如忽略值为null的字段，或者值为0的数值型字段等，可以用@JsonInclude注解。\n@JsonInclude用来指定序列化时需要包括哪些字段，本身提供了多种策略：ALWAYS、NON_NULL、NON_EMPTY等。如果需要自定义包括字段的策略，方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // 指定自定义的序列化策略，同时提供相关的值过滤类ValueFilter @JsonInclude(value = Include.CUSTOM , valueFilter = ValueFilter.class) public class Item { //... } // 自定义的过滤类 public class ValueFilter { @Override public boolean equals(final Object obj){ // return true表示将其过滤，即在序列化时将其忽略。 // 这里将所有值为null、false、0的字段全部忽略 if (obj == null) { return true; } if (obj.equals(Boolean.FALSE)) { return true; } if (obj.equals(Integer.valueOf(0))) { return true; } if (obj instanceof BigDecimal) { final BigDecimal value = (BigDecimal) obj; if (value.compareTo(BigDecimal.ZERO) == 0) { return true; } } return false; } @Override public int hashCode() { return super.hashCode(); } } pojo的循环依赖导致序列化时无限递归 当多个pojo之间存在循环依赖时，在序列化时会无限递归，最终堆栈溢出StackOverflowError。pojo如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // 供应商Vendor，关联着中间表VendorFact @Data public class Vendor { private List\u0026lt;VendorFact\u0026gt; facts; } // 工厂Fact，关联着中间表VendorFact @Data public class Fact { private List\u0026lt;VendorFact\u0026gt; vendors; } // 中间表VendorFact，存放Vendor和Fact的关联关系（多对多） @Data public class VendorFact { private Fact fact; private Vendor vendor; } 上述的pojo在序列化时会互相引用、无限递归，因此需要打断这个循环链。\n经过本人测试，其他博客中提及的@JsonManagedReference和@JsonBackReference并无效果，至少在多对多的关联关系中不起效（一对多没有测试）。\n使用@JsonIgnore 直接在其中一方的字段上加上@JsonIgnore，这样在序列化时该字段就会被忽略，自然也就不会互相引用无限递归了。比如对于Vendor的序列化，可以将VendorFact里的vendor变量忽略：\n1 2 3 4 5 6 7 8 9 @Data public class VendorFact { private Fact fact; @JsonIgnore private Vendor vendor; } 不过这个方案有个缺点，就是序列化后的json中只有一方持有另一方，在另一方的json中无法持有对方，在一对多或者多对多的情况中并不便利。比如上面的方式，虽然Vendor可以正常序列化了，但是Fact依然不能正常序列化。而在序列化VendorFact时，也缺少了vendor的信息。\n当然有个方案是，为每一方都单独创建一套对应的dto来进行序列化，这样的话虽然类的数量变多了，但是可以解决多对多关系中只有一方能序列化的问题。比如上面的例子，需要两个VendorFact的dto类，各自对应Vendor和Fact。不过在序列化VendorFact时，依然缺少另一方的信息。不过正常情况下不会单独去序列化作为中间表的VendorFact，因此不予考虑这个缺点。\n此外，和@JsonIgnore效果类似的@JsonIgnoreProperties，也能起到一样的效果，但是这个注解如果添加在集合变量上是无效的，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Data public class Vendor { // 不会起效，因为这里的json结构实际上是数组，对应的是List对象，而不是VendorFact // 需要将该注解添加在VendorFact类上 @JsonIgnoreProperties(\u0026#34;vendor\u0026#34;) private List\u0026lt;VendorFact\u0026gt; facts; } @Data // 上面的注解应该加在这里 @JsonIgnoreProperties(\u0026#34;vendor\u0026#34;) public class VendorFact { private Fact fact; private Vendor vendor; } 自定义对象的序列化和反序列化 有时候只靠默认的序列化方式，或者常规的json注解，难以实现某个对象的序列化要求。比如，现在需要对一个HashMap对象进行序列化，这个对象中的字段和类型是未知的，此时可以用@JsonSerialize和@JsonDeserialize来控制序列化和反序列化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 @Data // 指定自定义的序列化器CustomTableDtoSerializer @JsonSerialize(using = CustomTableDtoSerializer.class) // 指定自定义的反序列化器CustomTableDtoDeserializer @JsonDeserialize(using = CustomTableDtoDeserializer.class) public class CustomTableDto { public static final DateTimeFormatter DATE_FORMAT = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#34;); private Map\u0026lt;String, Object\u0026gt; dynamicModelMap; } // 序列化器 public class CustomTableDtoSerializer extends JsonSerializer\u0026lt;CustomTableDto\u0026gt; { @Override public void serialize(final CustomTableDto customTable, final JsonGenerator gen, final SerializerProvider serializers) throws IOException { final Map\u0026lt;String, Object\u0026gt; dynamicModelMap = customTable.getDynamicModelMap(); if (dynamicModelMap != null) { gen.writeStartObject(); for (final String key : dynamicModelMap.keySet()) { final Object value = dynamicModelMap.get(key); final Optional\u0026lt;CustomFieldType\u0026gt; typeOpt = CustomFieldType.findTypeByColumnName(key); if (typeOpt.isPresent() \u0026amp;\u0026amp; value != null) { writeType(gen, typeOpt.get(), key, value); } } gen.writeEndObject(); } else { gen.writeNull(); } } private static void writeType(final JsonGenerator gen, final CustomFieldType type, final String key, final Object value) throws IOException { final String jsonKey = StringUtils.replaceOnce(key, type.getColumnName(), type.getJsonName()); // 根据不同的字段类型进行对应的业务处理 // CustomFieldType是自定义的枚举类，这里就不写出来了 switch (type) { case TEXT: case TEXT_AREA: gen.writeStringField(jsonKey, (String) value); break; case DATE: gen.writeStringField(jsonKey, CustomTableDto.DATE_FORMAT.format((LocalDate) value)); break; case NUMBER: gen.writeNumberField(jsonKey, (Long) value); break; case DECIMAL: gen.writeNumberField(jsonKey, (BigDecimal) value); break; case CHECKBOX: gen.writeBooleanField(jsonKey, (Boolean) value); break; case CODELIST: case HCL_GROUP: gen.writeObjectField(jsonKey, value); break; default: //do nothing } } } // 反序列化器 public class CustomTableDtoDeserializer extends JsonDeserializer\u0026lt;CustomTableDto\u0026gt; { @Override public CustomTableDto deserialize(final JsonParser p, final DeserializationContext ctxt) throws IOException { final ObjectCodec oc = p.getCodec(); final JsonNode root = oc.readTree(p); final Map\u0026lt;String, Object\u0026gt; dynamicModelMap = new HashMap\u0026lt;\u0026gt;(); final Iterator\u0026lt;String\u0026gt; fieldIterator = root.fieldNames(); while (fieldIterator.hasNext()) { final String jsonKey = fieldIterator.next(); final JsonNode value = root.get(jsonKey); final Optional\u0026lt;CustomFieldType\u0026gt; typeOpt = CustomFieldType.findTypeByJsonName(jsonKey); if (typeOpt.isPresent() \u0026amp;\u0026amp; value != null) { put(oc, dynamicModelMap, typeOpt.get(), jsonKey, value); } } final CustomTableDto customTableDto = new CustomTableDto(); customTableDto.setDynamicModelMap(dynamicModelMap); return customTableDto; } private static void put(final ObjectCodec oc, final Map\u0026lt;String, Object\u0026gt; dynamicModelMap, final CustomFieldType type, final String jsonKey, final JsonNode value) throws IOException { final String columnKey = StringUtils.replaceOnce(jsonKey, type.getJsonName(), type.getColumnName()); // 根据不同的字段类型进行对应的业务处理 // CustomFieldType是自定义的枚举类，这里就不写出来了 switch (type) { case TEXT: case TEXT_AREA: dynamicModelMap.put(columnKey, value.textValue()); break; case DATE: final String dateStr = value.textValue(); dynamicModelMap.put(columnKey, LocalDate.from(CustomTableDto.DATE_FORMAT.parse(dateStr))); break; case NUMBER: dynamicModelMap.put(columnKey, value.longValue()); break; case DECIMAL: dynamicModelMap.put(columnKey, value.decimalValue()); break; case CHECKBOX: dynamicModelMap.put(columnKey, value.booleanValue()); break; case CODELIST: dynamicModelMap.put(columnKey, oc.treeToValue(value, EmbedCodelist.class)); break; case HCL_GROUP: dynamicModelMap.put(columnKey, oc.treeToValue(value, EmbedHcl.class)); break; default: //do nothing } } } 参考链接 java 关于时间返回结果与参数的注解@DatetimeFormat和@JsonFormat @JsonProperty和@JsonAlias的区别 JPA中因双向依赖而造成的json怪相 相互访问造成溢出 ","permalink":"https://lewky.cn/posts/jackson-issues/","tags":["Jackson"],"title":"Jackson问题汇总"},{"categories":["Java"],"contents":"Cannot forward after response has been committe 之前在使用Servlet的时候，总是在 doGet()/doPost() 的最后一行才使用请求转发或者重定向。如果需要根据条件来判断进行不同的请求转发或者重定向，代码如下：\n1 2 3 4 5 6 7 8 9 @Override protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException { if (req.getSession().getAttribute(AttrConsts.LOGIN_USER) == null) { req.getRequestDispatcher(PathConsts.PATH_PREFIX + PathConsts.LOGIN_PAGE).forward(req, resp); } req.getRequestDispatcher(PathConsts.PATH_PREFIX + PathConsts.MAIN_PAGE).forward(req, resp); } 上边的代码在执行后会报如下异常：\n1 2 java.lang.IllegalStateException: Cannot forward after response has been committe ... 报异常的原因是重复转发或者重定向了请求，如果有多个转发或者重定向，需要在每个转发或者重定向请求之后加上return语句(最后一个请求转发或者重定向不需要加return)，如下：\n1 2 3 4 5 6 7 8 9 10 @Override protected void doGet(final HttpServletRequest req, final HttpServletResponse resp) throws ServletException, IOException { if (req.getSession().getAttribute(AttrConsts.LOGIN_USER) == null) { req.getRequestDispatcher(PathConsts.PATH_PREFIX + PathConsts.LOGIN_PAGE).forward(req, resp); return; } req.getRequestDispatcher(PathConsts.PATH_PREFIX + PathConsts.MAIN_PAGE).forward(req, resp); } 通过return语句确保在转发或者重定向请求之后返回，避免在执行上边的转发/重定向之后，接着继续往下执行转发/重定向请求，这样就不会再报这个异常了。\nweb.xml中classpath*:与classpath:的区别 classpath对应src目录，该目录下的文件会在编译后被存放到WEB-INF文件夹下的classes目录。\nclasspath：只会到你的class路径中查找配置文件，对于多个同名的配置文件，只会加载找到的第一个文件；\nclasspath*：除了指定的class路径，还会到该class路径下的jar包中进行查找配置文件，对于多个同名的配置文件，都会被加载。\n但是对于classpath*，无法使用模糊匹配的方式，可以通过逗号来隔开多个配置文件。\n1 2 3 4 5 6 7 8 9 \u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath*:applicationContext.xml, classpath*:app-1.xml, classpath*:app-2.xml, classpath*:app-3.xml, classpath*:app-4.xml \u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; 在一个filter配置多个url-pattern 如果想一个filter配置多个url-pattern，需要在filter标签后添加多个filter-mapping标签。因为一个filter-mapping标签里只能有一个url-pattern，不能直接把多个url-pattern配置到同一个filter-mapping标签里，也不能直接把多个url直接配置到一个url-pattern标签里。\n正确地配置方式如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;filter\u0026gt; \u0026lt;filter-name\u0026gt;test\u0026lt;/filter-name\u0026gt; \u0026lt;filter-class\u0026gt;com.test.TestFilter\u0026lt;/filter-class\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;test\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/test/a/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; \u0026lt;filter-mapping\u0026gt; \u0026lt;filter-name\u0026gt;test\u0026lt;/filter-name\u0026gt; \u0026lt;url-pattern\u0026gt;/test/b/*\u0026lt;/url-pattern\u0026gt; \u0026lt;/filter-mapping\u0026gt; 报错Invalid content was found starting with element \u0026lsquo;init-param\u0026rsquo; 在web.xml中配置servlet节点时报错如下：\ncvc-complex-type.2.4.a: Invalid content was found starting with element \u0026lsquo;init-param\u0026rsquo;. One of \u0026lsquo;{\u0026ldquo;http://java.sun.com/xml/ns/j2ee\":run-as, \u0026ldquo;http://java.sun.com/xml/ns/j2ee\":security-role-ref}' is expected.\n原因是init-param节点不能放在load-on-startup节点的后面，将init-param节点放置到前边就不再报这个错误了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;resteasy-servlet\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt; org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher \u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;javax.ws.rs.Application\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;com.cbx.ws.rest.jaxrs.CbxApplication\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;2\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; 参考链接 在Web.xml中自动扫描Spring的配置文件及resource时classpath*:与classpath:的区别\n","permalink":"https://lewky.cn/posts/javaweb-servlet-issues/","tags":["JavaWeb","工作记录"],"title":"Java Servlet问题汇总"},{"categories":["计算机"],"contents":"查询被占用的端口 假如被占用的是61613端口号（activemq的），在cmd窗口中执行如下命令：\n1 netstat -aon|findstr \u0026#34;61613\u0026#34; 可以看到结果如下：\n1 2 3 C:\\Users\\lewis.liu\u0026gt;netstat -aon|findstr \u0026#34;61613\u0026#34; TCP 0.0.0.0:61613 0.0.0.0:0 LISTENING 30400 TCP [::]:61613 [::]:0 LISTENING 30400 这说明61613端口号被PID为30400的进程占用了。\n查看指定PID的进程 可以查询是哪个进程或者程序占用了该端口：\n1 tasklist|findstr \u0026#34;30400\u0026#34; 可以看到结果如下：\n1 2 C:\\Users\\lewis.liu\u0026gt;tasklist|findstr \u0026#34;30400\u0026#34; java.exe 30400 Console 5 198,396 K 杀死指定PID的进程 强制（/F参数）杀死PID为30400的所有进程包括子进程（/T参数）：\n1 taskkill /T /F /PID 30400 也可以在任务管理器里借助PID来找到对应的进程或程序，然后手动点结束进程。\n参考链接 Windows下如何查看某个端口被谁占用 ","permalink":"https://lewky.cn/posts/windows-netstat/","tags":["计算机"],"title":"Windows查询被占用的端口"},{"categories":["PostgreSQL"],"contents":"匿名函数 DO关键字 pl/pgsql即Procedural Language/ Postgres SQL(过程化sql语言)，是Postgresql数据库对sql语句的扩展，可以在pl/pgsql代码块内定义多条sql语句，每条语句以分号结束，代码块由begin开始，end结束，代码块的最后一个end可以不加分号。\nDO关键字用来执行一段匿名代码块，即在在程序语言过程中一次性执行的匿名函数。代码块可以看做是一段没有参数、没有返回值的函数体。其格式如下：\n1 DO [LANGUAGE lang_name] code; code code block代码块实际上为一个字符串，可以用\u0026quot;美元符引用”$$书写字符串常量，$$中间可以包含标签名，可以自由命名，但是不能以数字开头，可以命名为$$，$_$，$a$，$a1$...，该标签名必须成对出现，且大小写敏感。\n用DECLARE声明变量(如果不需要声明变量可以不写declare)，用BEGIN和END包括需要执行的代码/sql语句，每个语句末尾需要加上分号，BEGIN不加分号，代码块最后一个END后可以省略分号；其格式如下：\n1 2 3 4 5 DO $body$ BEGIN update student set name = \u0026#39;张小明\u0026#39; where id = 10010; END $body$; 1 2 3 4 5 6 7 8 DO $body$ DECLARE NEW_NAME varchar(100); BEGIN NEW_NAME:=\u0026#39;张\u0026#39;||\u0026#39;小明\u0026#39;; update student set name = NEW_NAME where id = 10010; END $body$; lang_name 用来解析code的程序语言的名字，如果缺省，默认为plpgsql，lang_name可以写在code前，也可以写在code后，即\n1 DO code; 等效于下边的\n1 DO LANGUAGE PLPGSQL code; 或者\n1 DO code LANGUAGE PLPGSQL; 这里的code指的是代码块，也就是上边说的内容格式。\n一个例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 DO $body$ DECLARE SIZES_VALUE varchar(1000); MEASUREMENT_TEMPLATE RECORD; BEGIN FOR MEASUREMENT_TEMPLATE IN (SELECT ID FROM CNT_MEASUREMENT_TEMPLATE WHERE DOMAIN_ID IN (\u0026#39;/\u0026#39;,\u0026#39;RD1\u0026#39;,\u0026#39;RD2\u0026#39;) AND IS_LATEST = TRUE AND (SIZES IS NULL OR SIZES = \u0026#39;\u0026#39;)) LOOP -------- split sizes value from CNT_MEASUREMENT_TEMPLATE_SIZE order by seq_no -------- SIZES_VALUE = (SELECT ARRAY_TO_STRING(ARRAY(SELECT ALT_LABEL||CASE WHEN COALESCE(LABEL,\u0026#39;\u0026#39;) = \u0026#39;\u0026#39; THEN \u0026#39;\u0026#39; ELSE \u0026#39;(\u0026#39;||LABEL||\u0026#39;)\u0026#39; END FROM CNT_MEASUREMENT_TEMPLATE_SIZE WHERE PARENT_ID = MEASUREMENT_TEMPLATE.ID ORDER BY SEQ_NO),\u0026#39;, \u0026#39;)); -------- set sizes value for cnt_measurement_template whose sizes value is null or \u0026#39;\u0026#39; -------- UPDATE CNT_MEASUREMENT_TEMPLATE SET SIZES = SIZES_VALUE WHERE ID = MEASUREMENT_TEMPLATE.ID; END LOOP; END; $body$ LANGUAGE PLPGSQL; 遍历数据，变量赋值 遍历操作以及变量赋值操作需要在匿名函数脚本中使用，且匿名函数在执行时必须显示开启事务。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 begin; DO $body$ declare targetId bpchar(32); update_sr RECORD; begin --遍历表中符合条件的数据 for update_sr in ( select temp.* from tab_test temp inner join tab_student sr on sr.id = temp.id where sr.is_latest is true ) loop select max(id) into targetId from tab_student where ref_no = update_sr.ref_no; if targetId is not null then --操作数据等 end if; end loop; END; $body$ LANGUAGE PLPGSQL; commit; 上面的脚本中使用了for loop来遍历数据，需要注意的是，在遍历时会将数据缓存起来，如果在遍历时改变了被遍历的数据，是不会影响到被缓存的数据的。如果此时需要使用到被更改的值，只能通过赋值给临时变量来获取到被更改的值。\n在变量赋值时，可以用select max(xx) into的写法。使用max()的目的是，如果select不到数据则会返回null，避免在变量赋值时出错。\n插入其他表的数据 1 2 3 4 INSERT INTO tab_test (id, name, ref_no, version) select id, name, ref_no, version from tab_student; 使用insert into ... select from ...来插入其他表的数据，也可以是同一个表，但此时需要起表别名来区分数据。且这种写法，需要两个表都存在才行。\n修改多个列的值 在修改的列数量较少时，可以用下面的写法：\n1 update tab_test set name = \u0026#39;new name\u0026#39;, ref_no = \u0026#39;new ref_no\u0026#39; where id = \u0026#39;1\u0026#39;; 如果列非常多时，比如同时改几十上百个，可以用下面的写法简单点：\n1 2 3 update tab_test set (name, ref_no, version) = (\u0026#39;new name\u0026#39;, \u0026#39;new ref_no\u0026#39;, 2) where id = \u0026#39;1\u0026#39;; update语句怎么关联其他表 PostgreSQL的update语句关联外表的写法与MySQL不同，不能直接通过join/outer join来关联其他表，就算使用update+join不会报错，join的那部分其实也不会有任何效果，如下所示：\n1 2 3 4 5 6 7 8 update a set value = \u0026#39;test\u0026#39; from a join b on a.b_id = b.id join c on b.c_id = c.id where a.key = \u0026#39;test\u0026#39; and c.value = \u0026#39;test\u0026#39;; 上边的sql本意是a、b、c三表关联，当c的value是\u0026rsquo;test\u0026rsquo;且a的key也是\u0026rsquo;test\u0026rsquo;的时候，就将a的value也改为\u0026rsquo;test\u0026rsquo;。\n但实际上这个sql有大问题，这里的join和where条件并没有意义，一旦update成功，你会发现，a表内的所有数据的value都被改成了test！！要么update 0条数据，要么全部update！至于是哪种结果，这要看where的条件，目前还不清楚为什么会这样。因为这种写法本身就是不对的！\nPostgreSQL中正确的多表关联update写法 在update语句中不应该通过join来进行多表关联，而是要通过from来多表关联，如下：\n1 2 3 4 5 6 7 8 update a set value = \u0026#39;test\u0026#39; from b,c where a.b_id = b.id and b.c_id = c.id and a.key = \u0026#39;test\u0026#39; and c.value = \u0026#39;test\u0026#39;; 通过from来多表关联，而关联条件则是放到了where中，这样就可以达到我们想要的效果了。另外补充一句，对于set xxx = 'xxx'这个update的部分，是不可以在column字段前加上表前缀的，比如下边的写法就是有语法错误的：\n1 2 update a set a.value = \u0026#39;test\u0026#39;; 此外，update语句也可以连接自身的表，只要起了表别名将二者区分开来就行。\n参考链接 PostgreSQL数据库PL/PGSQL学习使用 PostgreSQL中的DO-有条件的创建函数 How to do an update + join in PostgreSQL? ","permalink":"https://lewky.cn/posts/postgresql-dml/","tags":["工作记录"],"title":"PostgreSQL - DML操作汇总"},{"categories":["数据库"],"contents":"快捷键hot key ctrl + r 执行全部sql（就算用了分号也会一起被执行）\nctrl + shift + r 运行选中的sql\n","permalink":"https://lewky.cn/posts/navicat/","tags":["可视化工具","DBeaver"],"title":"Navicat使用汇总"},{"categories":["版本控制工具"],"contents":"git clone 克隆远程库到本地：\n1 2 3 4 5 6 7 // 默认本地仓库名字与远程库一样 git clone https://github.com/jquery/jquery.git // 指定本地库名字为test git clone https://github.com/jquery/jquery.git test // git clone的仓库地址支持多种协议，通常使用最多的是http(s)和ssh协议，比如从GitHub上克隆仓库。 git remote 该命令用于管理远程库，当clone远程库到本地时，远程库将被自动命名为origin。\ngit remote可以查询当前仓库下的所有远程库：\n1 2 $ git remote origin git remote -v可以查询当前仓库下的所有远程库对应的地址，一个远程库对应fetch和push两种操作，所以有两个地址。\n1 2 3 $ git remote -v origin git@github.com:jquery/jquery.git (fetch) origin git@github.com:jquery/jquery.git (push) git clone -o可以指定远程库的别名：\n1 2 3 $ git clone -o jQuery https://github.com/jquery/jquery.git $ git remote jQuery 其他操作：\n1 2 3 4 5 6 7 8 9 10 11 // 查看远程库的详细信息 git remote show \u0026lt;远程库别名\u0026gt; // 添加新的远程库 git remote add \u0026lt;远程库别名\u0026gt; \u0026lt;网址\u0026gt; // 删除远程库 git remote rm \u0026lt;远程库别名\u0026gt; // 重命名远程库的别名 git remote rename \u0026lt;原远程库别名\u0026gt; \u0026lt;新远程库别名\u0026gt; git branch 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // 创建本地分支 git branch \u0026lt;分支名\u0026gt; // 删除本地分支 git branch -d \u0026lt;分支名\u0026gt; git branch --delete \u0026lt;分支名\u0026gt; // 设置关联远程分支，新建的本地分支需要关联远程分支，被关联的远程分支要存在否则会报错 git branch --set-upstream-to=\u0026lt;远程库别名\u0026gt;/\u0026lt;远程分支名\u0026gt; \u0026lt;本地分支名\u0026gt; // 查看当前分支 git branch // 查看远程分支 $ git branch -r origin/master // 查看所有分支 // * master表明当前分支是master，对应的远程分支是origin/master $ git branch -a * master remotes/origin/master git checkout 用于检出分支，从当前分支切换到另一个分支。切换分支时，要注意已暂存的文件或者提交。\n1 2 3 4 5 6 7 8 // 切换到另一个已存在的分支 git checkout \u0026lt;分支名\u0026gt; // 基于当前分支创建并切换到新的分支 git checkout -b \u0026lt;新的分支名\u0026gt; // 基于远程分支创建并切换到新的分支 git checkout -b \u0026lt;新的分支名\u0026gt; \u0026lt;远程库别名\u0026gt;/\u0026lt;远程分支名\u0026gt; git fetch 该命令用于将远程库的更新拉取到本地库：\n1 2 3 4 5 // 获取远程库所有分支的更新到本地库 git fetch \u0026lt;远程库别名\u0026gt; // 获取指定分支的更新到本地库 git fetch \u0026lt;远程库别名\u0026gt; \u0026lt;分支名\u0026gt; 如果远程库的某个分支被删掉了，git fetch默认不会把这个删除操作同步到本地库，依然会看到被删掉的远程分支，这时候可以通过加上-p或--prune参数来将被删掉的远程分支更新到本地：\n1 2 git fetch --prune origin git fetch -p origin git pull 该命令用于取回远程分支的更新，并将其合并到本地分支。\n1 2 3 4 5 6 7 8 9 // 取回并合并到指定的本地分支 git pull \u0026lt;远程库别名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; // 如果是合并到当前分支可以不需要指明本地分支名 // git pull相当于git fetch + git merge git pull \u0026lt;远程库别名\u0026gt; \u0026lt;远程分支名\u0026gt; // 指定rebase方式合并 git pull --rebase \u0026lt;远程库别名\u0026gt; \u0026lt;远程分支名\u0026gt;:\u0026lt;本地分支名\u0026gt; git有两种合并方式：merge和rebase，这两个合并方式存在一定的区别，不能误用。\ngit add git add [参数] \u0026lt;路径\u0026gt;用于将工作区的文件添加到暂存区，可以多次使用git add命令将文件添加到暂存区中。暂存区中的文件可以通过git commit一次性提交到本地仓库。\n1 2 3 4 5 6 7 8 9 10 // 将当前路径下修改的文件以及新增的文件添加到暂存区，不包括被删除的文件 git add . // 将当前路径下修改的文件和被删除的文件添加到暂存区，不包括新增的文件 // 相当于git add --update git add -u . // 将当前路径下的所有文件添加到暂存区，相当于上面两个命令的集合 // 相当于git add --all git add -A . git push 用于推送本地分支的更新到远程分支，用法与git pull类似。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 推送本地分支到远程分支，注意这里的两个分支名顺序和pull是相反的 git push \u0026lt;远程库别名\u0026gt; \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; // 远程分支名可以省略，会自动推送到有关联关系的远程分支（通常都是和本地分支同名的），如果该远程分支不存在则会新建远程分支 git push \u0026lt;远程库别名\u0026gt; \u0026lt;本地分支名\u0026gt; // 本地分支名可以省略，此时表示推送空分支到远程分支 // 即删除远程分支 // demo: git push origin :master git push \u0026lt;远程库别名\u0026gt; :\u0026lt;远程分支名\u0026gt; // 删除远程分支 // demo: git push origin --delete master git push \u0026lt;远程库别名\u0026gt; --delete \u0026lt;远程分支名\u0026gt; // 推送本地所有分支到远程库 // demo: git push --all origin git push --all \u0026lt;远程库别名\u0026gt; 在push时，如果远程库的分支版本更新，则会push当前分支失败，需要先git pull合并到当前分支（可能需要解决冲突），然后再重新push。或者可以使用--force参数，强制覆盖掉远程分支，但是一般不建议这样做。\n此外，git push不会推送tag，除非添加--tags参数。\ngit reset 该命令用于将仓库代码回退到指定的版本，通常会带上--hard参数。本地git仓库分为三个区域：工作区，暂存区和本地库。回退版本的命令有3个参数，与这三个区域有关。\n--hard 移动本地库HEAD指针 重置工作区 重置暂存区 回退版本后，本地库原本工作区和暂存区的文件将被清空，彻底变回指定版本的状态。\n--soft 移动本地库HEAD指针 回退版本后，仅仅移动了本地库的指针，工作区和暂存区文件保持不变。\n--mixed 移动本地库HEAD指针 重置暂存区 回退版本后，本地库原本暂存区的文件将被清空。\n可以通过实际情况来决定使用哪个参数，但在实际开发中，为了避免自己的工作成果被误删，最好先确保自己的改动已经提交到了本地库或者远程库。\n对于误操作回退版本导致文件丢失的情况，可以参考这篇文章：关于git reset \u0026ndash;hard命令！！！，未提交代码丢失找回\n具体操作 首先切换到需要回退的分支：git checkout \u0026lt;分支名\u0026gt;。\n然后用git reset命令来回退到指定的版本，通常会带上--hard参数：\n1 2 3 4 5 6 7 8 9 // 回退到上一个版本 git reset --hard HEAD^ // 回退到上上个版本 git reset --hard HEAD^^ // 每多回退一个版本，就多一个^ // 为了避免^太多，可以用~n来简化，n表示回退几次提交，默认是一次 git reset --hard HEAD~2 此外，也可以用commit id来回退到指定的版本。仓库的每次提交都会为其生成一个唯一的id（40位哈希值），可以通过git log来查看每个提交对应的commit id。\n在回退版本时，可以用这个commit id来指定回退到对应的提交，不需要指定完整的commit id，只需要前7位字符（short commit id）即可。\n1 2 3 // 比如仓库有一个提交：commit 26e1d228c71e69f0cb63fa73db8cc1ae3c6d8e87 // 现在回退到这一个提交时的版本 git reset --hard 26e1d22 如果不放心这个手动截取前七位字符的short commit id，可以用以下命令来得到：\n1 2 git rev-parse --short 26e1d228c71e69f0cb63fa73db8cc1ae3c6d8e87 26e1d22 git tag Git的tag用于给某个分支的某个提交打上标签，可以理解为一个别名，类似于浏览器收藏某个网页作为书签。\n通常tag用于标记某个阶段性的某次提交作为重要节点，比如release了某个版本等。因为commit-id本身很长，不利于记忆，将这个commit打上tag，如v1.0.0等，以后就可以直接搜索这个tag来快速切换到对应的代码。\n1 2 3 4 5 6 // 列出所有标签 git tag // 使用-l或--list查询指定的标签 // 查询条件区分大小写，可以使用通配符，如* git tag -l \u0026#34;v1.0.*\u0026#34; 创建标签如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 创建标签：分为轻量标签（lightweight）和附注标签（annotated） // 轻量标签只是对某个commit的引用 // 附注标签是存在在Git数据库中的一个完整对象，包括了打标签者、打标签时间、标签的附注信息等额外的信息。 // 可以通过git show \u0026lt;标签名\u0026gt;来看到这两种标签的信息 // 创建附注标签 git tag -a \u0026lt;标签名\u0026gt; -m \u0026#34;\u0026lt;备注信息\u0026gt;\u0026#34; // git tag -a v1.4 -m \u0026#34;my version 1.4\u0026#34; // 创建轻量标签，不需要指定任何参数 git tag \u0026lt;标签名\u0026gt; // git tag v1.4 // 上面都是对当前分支最新的commit创建标签，也可以对过去的某个commit打tag git tag -a \u0026lt;标签名\u0026gt; \u0026lt;commit-id\u0026gt; // git tag -a v1.4 26e1d22 其他操作如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // git push默认不会把tag推送到远程库（但是pull默认会获取tag），需要显示推送标签，操作和推送分支一样 // 推送指定的标签到远程库 git push \u0026lt;远程库别名\u0026gt; \u0026lt;本地标签名\u0026gt; // git push origin v1.4 // 使用--tags参数来一次性推送所有不在远程库的标签 git push \u0026lt;远程库别名\u0026gt; --tags // git push origin --tags // 删除标签需要-d参数 git tag -d \u0026lt;标签名\u0026gt; // git tag -d v1.4 // 删除远程库标签有两种方式 // 方式一：将空标签推送到指定的远程库标签 git push \u0026lt;远程库别名\u0026gt; :refs/tags/\u0026lt;标签名\u0026gt; // git push origin :refs/tags/v1.4 // 方式二：使用--delete，需要Git版本大于v1.7.0才能使用 git push \u0026lt;远程库别名\u0026gt; --delete \u0026lt;标签名\u0026gt; // git push origin --delete v1.4 // 检出标签 // tag是快照读，直接检出到指定的tag会使仓库处于detached HEAD状态，此时不能更改代码 // 如果需要回到某个tag并修改代码，需要创建对应的分支。当在该分支上提交后，可能需要一个新的tag来标注最新的提交 git checkout -b \u0026lt;新建分支名\u0026gt; \u0026lt;标签名\u0026gt; // git checkout -b version1.4 v1.4 参考链接 Git远程操作详解 git的add、commit、push的详细介绍 git的hard、soft、mixed参数比较 git_04_回退到上个版本 Git基础操作：将git commit id转成short commit id 2.6 Git 基础 - 打标签 ","permalink":"https://lewky.cn/posts/git-commands/","tags":["Git","版本控制工具"],"title":"Git常用命令"},{"categories":["计算机"],"contents":"IP地址 IP地址由网络号（包括子网号）和主机号组成，网络号（包括子网号）相同意味着在同一网段下。在IPv4中，IP地址是一个32位的整数，对应4个字节，通常用x.x.x.x的点式十进制方式来表示。\n主机号为全0时，代表当前网络地址；主机号为全1时，代表当前网络的广播地址。 当向某个网络的广播地址发送消息时，该网络内的所有主机都能收到该广播消息。\nIP地址可以分为A，B，C，D类地址：\nA类地址以0开头，第一个字节作为网络号，地址范围为：0.0.0.0~127.255.255.255；\nB类地址以10开头，前两个字节作为网络号，地址范围是：128.0.0.0~191.255.255.255;\nC类地址以110开头，前三个字节作为网络号，地址范围是：192.0.0.0~223.255.255.255。\nD类地址以1110开头，地址范围是224.0.0.0~239.255.255.255，D类地址作为组播地址（一对多的通信）；\nE类地址以1111开头，地址范围是240.0.0.0~255.255.255.255，E类地址为保留地址，供以后使用。\n只有A,B,C有网络号和主机号之分，D类地址和E类地址没有划分网络号和主机号。\n255.255.255.255和0.0.0.0 广播地址通常称为直接广播地址，是为了区分受限广播地址（255.255.255.255）。\n受限广播地址只能用于本地网络，路由器不会转发以受限广播地址为目的地址的分组；一般广播地址既可在本地广播，也可跨网段广播。\n0.0.0.0常用于寻找自己的IP地址，例如在我们的RARP，BOOTP和DHCP协议中，若某个未知IP地址的无盘机想要知道自己的IP地址，它就以255.255.255.255为目的地址，向本地范围（具体而言是被各个路由器屏蔽的范围内）的服务器发送IP请求分组。\n回环地址 127.0.0.0/8被用作回环地址，回环地址表示本机的地址，常用于对本机的测试，用的最多的是127.0.0.1。\n这里的/8表示子网掩码的位数。\nA、B、C类私有地址 私有地址(private address)也叫专用地址（即内网IP），只能在局域网使用，不能直接连上互联网，必须通过公网IP（公有地址）上网。\n因为IPv4协议的IP地址不够全球用户使用，所以需要私有地址来解决这个问题。比如运营商分配公网IP给某个局域网，一个局域网中的所有主机使用私有IP来识别，并通过同一个公网IP来上网。\nA类私有地址：10.0.0.0/8，范围是：10.0.0.0~10.255.255.255\nB类私有地址：172.16.0.0/12，范围是：172.16.0.0~172.31.255.255\nC类私有地址：192.168.0.0/16，范围是：192.168.0.0~192.168.255.255\n这就是为什么我们用ipconfig（Linux用的是ifconfig命令）得到的IP地址通常都是172.开头的B类私有地址，或者是192.168.开头的C类私有地址。如果百度IP，则会得到一个公网IP。\n子网掩码 由于IPv4中网络号占位较多，导致主机号数量较少。为了解决这个问题，通过将主机号的高位再次划分为子网络号，以此形成多个子网，提供给不同规模的用户群使用。\n不同子网下的主机不能直接通信，好处是缩小广播域，减少广播风暴，相对安全性能提高，出现问题也更易定位。\n无论是公有地址还是私有地址，都能通过划分为多个子网。子网掩码就是用来划分子网的一个32位二进制地址，1表示网络位，0表示主机位。将一个IP地址与子网掩码进行\u0026amp;运算，主机号会被屏蔽（变成全0），就可以得到网络号地址。\n网关 不同网段的网络无法直接通信，需要经过各自网络的网关来互相通信。网关实质上是一个网络通向其他网络的IP地址。\n网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。网关也被称为IP路由器。\n一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。\nDNS服务器 DNS即域名服务器（Domain Name Server）。由于IP地址都是数字，不方便记忆，于是就有了域名。通过DNS将域名解析为对应的IP，这样就可以通过访问域名来访问到对应的IP地址。\n参考链接 关于公网IP和私有IP的区别 子网的划分 和私有地址的区别和用处的不同在哪 【Network】 计算机网络基础知识总结 IP地址，子网掩码，默认网关，DNS服务器详解 ","permalink":"https://lewky.cn/posts/network/","tags":["计算机网络"],"title":"计算机网络基础"},{"categories":["Java"],"contents":"正则表达式的模式修饰符 在正则表达式前面可以加上(?i)，(?s)和(?m)这三种模式修饰符，用以改变正则表达式的匹配模式。\n(?i)表示匹配时不区分大小写。\n(?s)表示Singleline（单行模式），匹配时会改变.的含义，使其能与换行符（\\r或者\\n，如果是\\r\\n需要用两个.）匹配。\n(?m)表示Multiline（多行模式），匹配时会改变^和$的含义，使其分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。\n这三种模式修饰符可以搭配使用，如：(?im)，(?is)等。\n将模式修饰符加在正则表达式最前面，将会对整个正则表达式生效。可以通过以下写法来限制修饰符的生效范围：\n1 2 3 4 5 6 7 // 待匹配的字符串 String test = \u0026#34;HelloWorld!\u0026#34;; // 方式一 String regex = \u0026#34;(?i)hello(?-i)World!\u0026#34;; // 方式二 String regex = \u0026#34;(?i:hello)World!\u0026#34;; 下面是一个简单的Demo：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // Demo#1 final String test = \u0026#34;a\\nA\u0026#34;; final Pattern pattern = Pattern.compile(\u0026#34;(?is)a.a\u0026#34;); final Matcher matcher = pattern.matcher(test); int count = 0; while (matcher.find()) { System.out.println(++count + \u0026#34;: \u0026#34; + matcher.group()); } // 结果如下： 1: a A // Demo#2 final String test = \u0026#34;a\\nA\u0026#34;; final Pattern pattern = Pattern.compile(\u0026#34;(?im)^a$\u0026#34;); final Matcher matcher = pattern.matcher(test); int count = 0; while (matcher.find()) { System.out.println(++count + \u0026#34;: \u0026#34; + matcher.group()); } // 结果如下： 1: a 2: A matches()和find()区别 matches()是完全匹配，执行该方法后，会改变Matcher对象中的成员变量值，导致继续执行find()时可能无法匹配到正确结果。\nfind()是局部匹配，执行该方法不会改变Matcher对象中的成员变量值，每执行一次该方法都会使内部的游标向右移动到下一个匹配到的位置，通常搭配group()来获取当次局部匹配到的字符串。\nfind()在局部匹配成功后下标从0开始计算，可以通过find(int start)来重置局部匹配的位置。\n如果在匹配字符串时，需要同时使用到matches()和find()，应该在最后使用matches()，避免Matcher对象被修改导致find()结果不正确。或者不使用同一个Matcher对象来调用matches()和find()。\n参考链接 正则前面的 (?i) (?s) (?m) (?is) (?im) 正则表达式 ：(?s)(?i)\u0026rsquo;\\s*+ 前面的(?s)(?i) 表示什么意思 ","permalink":"https://lewky.cn/posts/java-regex-issues/","tags":["Java","正则表达式","工作记录"],"title":"Java正则表达式问题汇总"},{"categories":["MySQL"],"contents":"指定字符集编码 需要在数据库连接中指定两个参数：useUnicode=true\u0026amp;characterEncoding=UTF-8，只有当设置了useUnicode=true时，后续指定的字符集编码才有效。\nMySQL 5.6别名默认不生效问题 在数据库连接中指定参数：useOldAliasMetadataBehavior=true。\nMySQL 8的数据库连接问题 MySQL 8在连接数据库时与5.x版本有较大变化，需要注意如下的一些问题。\n驱动包路径变更 MySQL 8的驱动包路径变更为com.mysql.cj.jdbc.Driver，如果使用旧版本的驱动包路径会报错：\n1 Loading class `com.mysql.jdbc.Driver\u0026#39;. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver\u0026#39;. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary. SSL连接问题 与SSL连接有关，使用SSL连接需要提供服务器证书。如果不在数据库连接中加入useSSL=false的参数，会报错：\n1 Establishing SSL connection without server\u0026#39;s identity verification is not recommended. According to MySQL 5.5.45+, 5.6.26+ and 5.7.6+ requirements SSL connection must be established by default if explicit option isn\u0026#39;t set. For compliance with existing applications not using SSL the verifyServerCertificate property is set to \u0026#39;false\u0026#39;. You need either to explicitly disable SSL by setting useSSL=false, or set useSSL=true and provide truststore for server certificate verification. 时区问题 这是数据库和系统时区不同造成的，需要在数据库连接中指定对应的时区。通常国内都是东八区，如果不在数据库连接中加入serverTimezone=GMT%2B8\u0026amp;amp;的参数，会报错：\n1 java.sql.SQLException: The server time zone value \u0026#39;???ú±ê×??±??\u0026#39; is unrecognized or represents more than one time zone. 这里的GMT%2B8\u0026amp;amp;是指的GMT+8，即东八区，这里的+在URL编码中要转换为%2B，否则不会生效。\n执行sql报错USING BTREE 在执行sql文件时发现报错如下：\n1 You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near ‘USING BTREE.... 这是MySQL的一个bug：\nMySQL 5.1和MySQL 5.0在处理到索引语句时有所区别，我所执行的sql语句是从高版本的MySQL里导出来的。\n当存在UNIQUE KEY的表导出来时，其sql如下：\n1 UNIQUE KEY `idx_name` (`column_name`) USING BTREE 对于该语句，低版本的MySQL是不能识别的，所以就报错了。\n解决方法是将高版本MySQL导出来的sql语句里的column_name调整到USING BTREE后边就行了，如下：\n1 UNIQUE KEY `idx_name` USING BTREE (`column_name`) MySQL终止正在执行的SQL语句 show full processlist可以查询到MySQL正在执行的SQL语句，找到其中想要终止的慢SQL的id，通过kill终止：\n1 2 -- 终止id为3222162404的SQL语句 kill 3222162404 查询时区分大小写 MySQL默认处理文本时是大小写不敏感并且移除前后空格（trim）的，比如查询时（模糊查询、group by等也一样），查询DOUBLE和查询double是一样的结果，原因是建表时字符串字段的排序规则默认使用的utf8_general_ci。\n1 2 3 4 5 6 -- 查询表里字段的各项属性，排序规则看其中的collation show full columns from 表名; -- 本例中查询meta_data表里DATA_TYPE字段的部分查询结果如下： |Field |Type |Collation | |DATA_TYPE |varchar(10) |utf8_general_ci | 如果想要区分大小写并且不被trim，有两种方式：\n使用binary关键字 1 2 3 select DATA_TYPE from meta_data group by binary DATA_TYPE; select * from meta_data where DATA_TYPE binary = \u0026#39; DOUBLE \u0026#39;; select * from meta_data where DATA_TYPE like binary \u0026#39;%DOUBLE%\u0026#39;; 修改字段的排序规则 将字符串字段的collation改为utf8_bin。\n1 2 -- 将meta data表的DATA_TYPE字段改为大小写敏感 alter table meta_data change column DATA_TYPE DATA_TYPE varchar(10) collate utf8_bin; 参考链接 Mysql JDBC Url参数说明useUnicode=true\u0026amp;characterEncoding=UTF-8 https://blog.csdn.net/m0_37520980/article/details/80364884 mysql导入数据时提示 USING BTREE 错误解决办法 查询及停止MySQL正在执行的SQL语句 探讨MySQL中的GROUP BY语句大小写敏感性 ","permalink":"https://lewky.cn/posts/mysql-issues/","tags":["MySQL","工作记录"],"title":"MySQL问题汇总"},{"categories":["Spring"],"contents":"前言 Spring Data除了常用的JPA（Hibernate）关系型数据库的模块外，还有其他用于非关系型数据库的数据交互模块：比如Redis、MongoDB、Elasticsearch等。\n用法和JPA模块类似，都需要定义对应的POJO、Repository，同时也提供了对应的数据库工具模板类：如RedisTemplate、MongoTemplate等。\n本文基于以下版本：\n1 2 3 4 5 6 \u0026lt;!-- 对应的是4.1.1版本的MongoDB --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-mongodb\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这是MongoDB官网用户手册的翻译文档仓库：MongoDB-4.2-Manual\n忽略某个字段 和JPA-Hibernate类似，使用@Transient即可。注意不能使用javax.persistence.Transient，这个是JPA规范的注解，对Spring Data MongoDB无效，需要使用org.springframework.data.annotation.Transient。\n移除_class字段 Spring Data在查询MongoDB时会自动添加_class字段，可以用以下方式移除：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @Configuration public class MongoDBConfig { @Bean public MappingMongoConverter mappingMongoConverter(MongoDbFactory factory, MongoMappingContext context, BeanFactory beanFactory) { DbRefResolver dbRefResolver = new DefaultDbRefResolver(factory); MappingMongoConverter mappingConverter = new MappingMongoConverter(dbRefResolver, context); try { mappingConverter.setCustomConversions(beanFactory.getBean(CustomConversions.class)); } catch (NoSuchBeanDefinitionException ignore) { } // 取消_class字段 mappingConverter.setTypeMapper(new DefaultMongoTypeMapper(null)); return mappingConverter; } } 不支持ZonedDateTime类型 MongoDB不支持ZonedDateTime，因此在读取和写入时需要转换为java.util.Date或LocalDateTime类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Configuration public class MongoDBConfig { @Autowired MongoDbFactory mongoDbFactory; @Bean public MongoTemplate mongoTemplate() throws UnknownHostException { MappingMongoConverter converter = new MappingMongoConverter(new DefaultDbRefResolver(mongoDbFactory), new MongoMappingContext()); converter.setCustomConversions(customConversions()); converter.afterPropertiesSet(); return new MongoTemplate(mongoDbFactory, converter); } public MongoCustomConversions customConversions() { List\u0026lt;Converter\u0026lt;?, ?\u0026gt;\u0026gt; converters = new ArrayList\u0026lt;\u0026gt;(); converters.add(DateToZonedDateTimeConverter.INSTANCE); converters.add(ZonedDateTimeToDateConverter.INSTANCE); return new MongoCustomConversions(converters); } @ReadingConverter enum DateToZonedDateTimeConverter implements Converter\u0026lt;Date, ZonedDateTime\u0026gt; { INSTANCE; public ZonedDateTime convert(Date source) { return source == null ? null : ZonedDateTime.ofInstant(source.toInstant(), ZoneId.systemDefault()); } } @WritingConverter enum ZonedDateTimeToDateConverter implements Converter\u0026lt;ZonedDateTime, LocalDateTime\u0026gt; { INSTANCE; public LocalDateTime convert(ZonedDateTime source) { return source == null ? null : LocalDateTime.ofInstant(source.toInstant(), ZoneId.systemDefault()); } } } The bean ‘xxx’, defined in null, could not be registered. 当同时使用了多个Spring Data模块时，比如混用了Spring Data JPA和Spring Data MongoDB时就会报这种错：\n1 2 3 4 5 6 7 Description: The bean \u0026#39;itemMongoRepository\u0026#39;, defined in null, could not be registered. A bean with that name has already been defined in null and overriding is disabled. Action: Consider renaming one of the beans or enabling overriding by setting spring.main.allow-bean-definition-overriding=true 原因很简单，这些Spring Data模块属于不同的jar，但用的是同一个接口，Spring在运行时不知道当前的bean是绑定的JPA的，还是MongoDB或者Elasticsearch的库。\n此时需要使用注解来声明不同模块对应的包路径，以此区分开这些Repository的bean：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Configuration @EnableMongoRepositories(basePackages = \u0026#34;test.repository.mongodb\u0026#34;) public class MongoConfig { } @Configuration @EnableJpaRepositories(basePackages = \u0026#34;test.repository.jpa\u0026#34;) public class EntityConfig { } @Configuration @EnableElasticsearchRepositories(basePackages = \u0026#34;test.repository.es\u0026#34;) public class ElasticSearchConfig { } 整合多个数据库 现在有两个不同的功能模块，各自对应一个MongoDB，此时需要配置两个不同的数据库配置，并指定不同的MongoTemplate，然后通过调用不同的MongoTemplate来操作不同的MongoDB。\n比如在配置文件中有如下两个数据库：\n1 2 3 4 ## Default MongoDB database spring.data.mongodb.primary.uri=mongodb://localhost:27017/db1 ## Secondary MongoDB database spring.data.mongodb.secondary.uri=mongodb://localhost:27017/db2 此时定义两个MongoConfig的bean，各自对应上述两个不同的数据库。由于定义重复了相同类型的bean对象，需要用@Primary来指明默认注入哪个bean对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Configuration @EnableMongoRepositories(basePackages = \u0026#34;test.repository.mongodb.primary\u0026#34;, mongoTemplateRef = \u0026#34;primaryMongoTemplate\u0026#34;) public class PrimaryMongoConfig { private static final String ENTITY_MONGODB_URL = \u0026#34;spring.data.mongodb.primary.uri\u0026#34;; @Bean(name = \u0026#34;primaryMongoTemplate\u0026#34;) @Primary public MongoTemplate mongoTemplate(Environment env) { return new MongoTemplate(mongoFactory(env)); } @Bean(name = \u0026#34;primaryMongoFactory\u0026#34;) @Primary public MongoDatabaseFactory mongoFactory(Environment env) { return new SimpleMongoClientDatabaseFactory(env.getProperty(ENTITY_MONGODB_URL)); } } @Configuration @EnableMongoRepositories(basePackages = \u0026#34;test.repository.mongodb.secondary\u0026#34;, mongoTemplateRef = \u0026#34;secondaryMongoTemplate\u0026#34;) public class SecondaryMongoConfig { private static final String ENTITY_MONGODB_URL = \u0026#34;spring.data.mongodb.secondary.uri\u0026#34;; @Bean(name = \u0026#34;secondaryMongoTemplate\u0026#34;) public MongoTemplate mongoTemplate(Environment env) { return new MongoTemplate(mongoFactory(env)); } @Bean(name = \u0026#34;secondaryMongoFactory\u0026#34;) public MongoDatabaseFactory mongoFactory(Environment env) { return new SimpleMongoClientDatabaseFactory(env.getProperty(ENTITY_MONGODB_URL)); } } 使用SPEL表达式来动态获取集合的值 Spring Data MongoDB的POJO需要用@Document(collection = \u0026quot;xxx\u0026quot;)来指明映射数据库的某个集合（相当于JPA里的@Table(name = \u0026quot;xxx\u0026quot;)），但有时不想要直接写死集合名字，可以用SPEL表达式来实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 将集合名字作为一个变量，存到一个bean对象中 // @Data是lombok的注解，用来自动生成setter和getter方法 @Bean(name = \u0026#34;entityMongoCollection\u0026#34;) public EntityMongoCollection getEntityMongoCollection() { return new EntityMongoCollection(\u0026#34;myCollection\u0026#34;); } @Data @AllArgsConstructor public class EntityMongoCollection { private String collectionName; } // 用SPEL表达式来获取这个bean里的变量值 @Data @Document(collection = \u0026#34;#{@entityMongoCollection.getCollectionName()}\u0026#34;) public class EntityMongo implements Serializable { @Id @Field(\u0026#34;id\u0026#34;) private String id; @Field(\u0026#34;ref_no\u0026#34;) private String refNo; @Field(\u0026#34;version\u0026#34;) private Interger version; } 查询数据库 可以用官方提供的MongoTemplate来查询数据，也可以使用MongoRepository和@Query注解来实现：\n1 2 3 4 5 6 public interface EntityMongoRepository extends MongoRepository\u0026lt;EntityMongo, String\u0026gt; { @Query(\u0026#34;{\u0026#39;refNo\u0026#39;:?0 , \u0026#39;version\u0026#39;:?1}\u0026#34;) List\u0026lt;EntityMongo\u0026gt; findByRefNoAndVersion(final String refNo, final String version); } 如果只需要查询部分字段，可以用MongoTemplate的Projection来实现：\n1 2 3 4 5 6 7 String collectionName = \u0026#34;test\u0026#34;; Query query = new Query(); query.fields().include(\u0026#34;ref_no\u0026#34;); // 想查询的字段 query.fields().exclude(\u0026#34;version\u0026#34;); // 不想查询的字段 final List\u0026lt;EntityMongo\u0026gt; list = mongoTemplate.find(query, EntityMongo.class, collectionName); 参考链接 Spring Data Mongo中@Transient无效的解决办法 Spring 框架 MongoDB 去掉_class属性字段 Mongo Date Custom Converter not being called when save method of mongo repository is invoked The bean \u0026lsquo;xxxxx\u0026rsquo;, defined in null, could not be registered. A bean with that name has already \u0026hellip; SpringBoot整合MongoDB多数据源 springboot整合MongoDB Cannot resolve bean in SpEL for Spring Data MongoDB collection name ","permalink":"https://lewky.cn/posts/spring-data-mongodb/","tags":["工作记录","MongoDB"],"title":"Spring Data MongoDB问题汇总"},{"categories":["日志框架"],"contents":"日志框架 目前的日志框架可以分为两种：一种是jdk自带的，一种是第三方实现的。\n第三方的日志框架除了提供具体的日志实现外，也有的会提供自身框架的接口。此外，有些日志框架仅仅提供了一套统一的接口，不包含具体的日志实现，可以通过一些桥接包来调用其他的日志框架。（即日志的门面模式）\njdk自带的日志框架 jdk自带的日志是jdk-logging，简称jul（java.util.logging包的简称）。\nTomcat本身的日志实现是tomcat-juli.jar，从jar名就可以看出来，它是对jul的实现，内部对jul进行了一定的封装。\njul的配置文件是logging.properties。下面是jul的一个简单demo，jul的日志级别和第三方的日志框架不太相同：\n1 2 3 4 5 6 7 8 9 10 11 12 import java.util.logging.Level; import java.util.logging.Logger; public class Hello { public static void main(String[] args) { Logger logger = Logger.getGlobal(); logger.info(\u0026#34;start process...\u0026#34;); logger.warning(\u0026#34;memory is running out...\u0026#34;); logger.fine(\u0026#34;ignored.\u0026#34;); logger.severe(\u0026#34;process will be terminated...\u0026#34;); } } 第三方的日志框架 常见的有logback、log4j、log4j2这三大日志框架，其中log4j2是log4j 1.x的升级版，因为改动很大，所以作为一个新的日志框架独立使用。\nlogback的配置文件是logback.xml，log4j的配置文件是log4j.xml，log4j2的配置文件是log4j2.xml。有的日志框架的配置文件也可以是xml以外的文件，比如yaml文件、propertites文件，不过通常会使用xml文件（因人而异）。\n日志门面commons-logging 门面模式（也叫外观模式），由于市面上的第三方框架较多，往往一个项目中可能引入多种日志（比如使用了某个第三方的库，该库又使用了与项目不同的日志），为了方便管理，同时也是为了面向接口编程，于是不再直接使用某个具体的日志实现，而是借由统一的日志接口来调用具体的日志实现，这样就可以实现项目与日志的解耦。而在使用统一的日志接口时，项目中只能引入一种具体的日志实现框架（即门面模式的应用，此时项目不能同时混用多种日志实现，如果是第三方库引入的日志实现则没事），否则门面接口无法知道项目具体应该使用哪一种日志实现，会抛异常。\n最早的日志门面是Apache的commons-logging（简称为jcl），日志门面的用法即为：使用门面接口的API来打印日志，项目会通过Java的SPI机制来自动找到对应的日志实现来完成打印日志的功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.17\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public class Test { private final static Log logger = LogFactory.getLog(getClass()); public static void main(String[] args) { logger.debug(\u0026#34;DEBUG ...\u0026#34;); logger.info(\u0026#34;INFO ...\u0026#34;); logger.error(\u0026#34;ERROR ...\u0026#34;); } } 通常在导入门面接口和具体的日志实现两个依赖后，再添加对应日志框架的配置文件即可。在集成不同的日志实现时，有的可能需要引入额外的桥接包，因为并不是所有日志实现直接实现了门面接口，可能存在着其他的接口，此时需要通过额外的桥接包来将两者适配起来，相当于一个适配器，比如在集成log4j2的时候就需要额外引入log4j-jcl的jar。\n可以看到，项目中无需出现具体的日志框架的代码即可完成日志打印，这意味着在切换日志框架时成本很低，完全不需要改动代码，只需要改变具体的日志依赖和对应的配置文件即可。\n此外，jcl可以有自身的配置文件commons-logging.properties，一般不用这个。因为不同的日志框架有各自不同的特性与优势，最好是使用对应的独立的配置文件来实现解耦。\n日志门面slf4j slf4j是Simple Logging Facade for Java，即简单日志门面，是目前较为流行的门面接口，用法和jcl一样，即使用slf4j自身提供的接口来打印日志：\n1 2 3 4 5 6 7 8 9 import org.slf4j.Logger; import org.slf4j.LoggerFactory; public class Test { public static void main(String[] args) { Logger logger = LoggerFactory.getLogger(getClass()); logger.info(\u0026#34;Test\u0026#34;); } } 目前很流行的Lombok框架，可以通过一个简单的@Slf4j注解来更为简洁方便地来使用Slf4j打印日志：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.16\u0026lt;/version\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; import lombok.extern.slf4j.Slf4j; @Slf4j public class Test { public static void main(String[] args) { log.info(\u0026#34;Test\u0026#34;); } } 无需导包也无需书写Slf4j的接口代码，直接使用log变量即可打印日志。\n参考链接 使用JDK Logging jdk-logging、log4j、logback日志介绍及原理 ","permalink":"https://lewky.cn/posts/log-framework/","tags":["日志框架"],"title":"日志框架与门面模式"},{"categories":["ELK"],"contents":"前言 本文主要基于Elasticsearch 6.5.4版本：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.elasticsearch\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;elasticsearch\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.5.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 修改jvm参数 Elasticsearch是用Java开发的，默认会配置1G的jvm堆的初始值和最大值，该jvm参数被配置在/config/jvm.options里：\n1 2 -Xms1g -Xmx1g 如果只是个人开发小项目，可以把参数改小些（当然不能调整太小，内存对于ES的性能影响较大），比如：\n1 2 -Xms512m -Xmx512m 这个jvm.options用来配置各种jvm参数，比如GC、GC logging、heap dumps等。\n设置远程访问 修改配置文件config/elasticsearch.yml：\n1 2 #network.host: 192.168.0.1 network.host: 0.0.0.0 若设置为127.0.0.1则只能在本地访问。\ntoo_many_clauses问题 Elasticsearch查询时报错如下：\n1 2 \u0026#34;caused_by\u0026#34;:{\u0026#34;type\u0026#34;:\u0026#34;too_many_clauses\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;maxClauseCount is set to 1024\u0026#34;}}}], \u0026#34;caused_by\u0026#34;:{\u0026#34;type\u0026#34;:\u0026#34;query_shard_exception\u0026#34;,\u0026#34;reason\u0026#34;:\u0026#34;failed to create query: 这是bool查询的条件超过了默认的1024上限，可以通过修改全局配置来增加上限，需要注意的是别设置太高，会消耗太多的CPU资源和内存。\n打开ES的配置文件/config/elasticsearch.yml，增加配置：\n1 indices.query.bool.max_clause_count: 2048 修改全局配置后需要重启ES才能生效。如果不允许重启ES集群，就只能从查询语句入手了，要么削减查询条件的数量，要么将查询条件转移到must_not的terms查询中。\nmust_not的terms查询可以超过默认的1024上限，对于肯定条件可以用must_not嵌套must_not来实现。（这种做法是其他博主验证的，这里只提一嘴，在短期内无法重启ES集群时可以作为临时方案使用。）\n不支持BigDecimal类型 Elasticsearch在索引数据时报错如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 java.lang.IllegalArgumentException: cannot write xcontent for unknown value of type class java.math.BigDecimal at org.elasticsearch.common.xcontent.XContentBuilder.unknownValue(XContentBuilder.java:755) at org.elasticsearch.common.xcontent.XContentBuilder.value(XContentBuilder.java:726) at org.elasticsearch.common.xcontent.XContentBuilder.field(XContentBuilder.java:711) at org.elasticsearch.index.query.BaseTermQueryBuilder.doXContent(BaseTermQueryBuilder.java:154) at org.elasticsearch.index.query.AbstractQueryBuilder.toXContent(AbstractQueryBuilder.java:82) at org.elasticsearch.index.query.BoolQueryBuilder.doXArrayContent(BoolQueryBuilder.java:275) at org.elasticsearch.index.query.BoolQueryBuilder.doXContent(BoolQueryBuilder.java:256) at org.elasticsearch.index.query.AbstractQueryBuilder.toXContent(AbstractQueryBuilder.java:82) at org.elasticsearch.common.xcontent.XContentBuilder.value(XContentBuilder.java:779) at org.elasticsearch.common.xcontent.XContentBuilder.value(XContentBuilder.java:772) at org.elasticsearch.common.xcontent.XContentBuilder.field(XContentBuilder.java:764) at org.elasticsearch.search.builder.SearchSourceBuilder.toXContent(SearchSourceBuilder.java:1184) at org.elasticsearch.common.xcontent.XContentHelper.toXContent(XContentHelper.java:349) at org.elasticsearch.search.builder.SearchSourceBuilder.toString(SearchSourceBuilder.java:1558) at org.elasticsearch.search.builder.SearchSourceBuilder.toString(SearchSourceBuilder.java:1553) at java.lang.String.valueOf(String.java:2994) at java.lang.StringBuilder.append(StringBuilder.java:131) at org.elasticsearch.action.search.SearchRequest.toString(SearchRequest.java:516) 从异常信息看，显然ES的接口无法接收BigDecimal类型，经过百度，也确实如此。在一篇博文评论中解释如下：\n应该是客户端代码里将查询的数值定义成了java.math.BigDecimal，而ES不支持这个类型。之所以2.2没有问题，是因为之前的transport client发送数据之前将其序列化成了json，而在5.x以后，使用的内部的transport protocol，数据类型如果不匹配会抛错误。\n所以数据类型的定义上，需要使用ES支持的类型。\n解决方案一：转变成其他ES支持的数据类型 我使用的是6.5.4版本的Elasticsearch，该版本尚不支持BigDecimal或者BigInteger的数据类型，所以在index到Elasticsearch之前，需要转换成其他数据类型，这里要注意不要数据溢出了:\nBigDecimal要转变成Double类型 BigInteger要转变成Long类型 解决方案二：使用更高版本的ES 我在看6.7.1版本的Elasticsearch源码时发现已经可以支持BigDecimal或者BigInteger的数据类型了，所以直接使用该版本或更高版本的就行了。\n下面附上两个版本的支持的数据类型的源码：\n6.5.4版本的Elasticsearch相关源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Map\u0026lt;Class\u0026lt;?\u0026gt;, Writer\u0026gt; writers = new HashMap\u0026lt;\u0026gt;(); writers.put(Boolean.class, (b, v) -\u0026gt; b.value((Boolean) v)); writers.put(Byte.class, (b, v) -\u0026gt; b.value((Byte) v)); writers.put(byte[].class, (b, v) -\u0026gt; b.value((byte[]) v)); writers.put(Date.class, XContentBuilder::timeValue); writers.put(Double.class, (b, v) -\u0026gt; b.value((Double) v)); writers.put(double[].class, (b, v) -\u0026gt; b.values((double[]) v)); writers.put(Float.class, (b, v) -\u0026gt; b.value((Float) v)); writers.put(float[].class, (b, v) -\u0026gt; b.values((float[]) v)); writers.put(Integer.class, (b, v) -\u0026gt; b.value((Integer) v)); writers.put(int[].class, (b, v) -\u0026gt; b.values((int[]) v)); writers.put(Long.class, (b, v) -\u0026gt; b.value((Long) v)); writers.put(long[].class, (b, v) -\u0026gt; b.values((long[]) v)); writers.put(Short.class, (b, v) -\u0026gt; b.value((Short) v)); writers.put(short[].class, (b, v) -\u0026gt; b.values((short[]) v)); writers.put(String.class, (b, v) -\u0026gt; b.value((String) v)); writers.put(String[].class, (b, v) -\u0026gt; b.values((String[]) v)); writers.put(Locale.class, (b, v) -\u0026gt; b.value(v.toString())); writers.put(Class.class, (b, v) -\u0026gt; b.value(v.toString())); writers.put(ZonedDateTime.class, (b, v) -\u0026gt; b.value(v.toString())); writers.put(Calendar.class, XContentBuilder::timeValue); writers.put(GregorianCalendar.class, XContentBuilder::timeValue); 6.7.1版本的Elasticsearch相关源码 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Map\u0026lt;Class\u0026lt;?\u0026gt;, Writer\u0026gt; writers = new HashMap\u0026lt;\u0026gt;(); writers.put(Boolean.class, (b, v) -\u0026gt; b.value((Boolean) v)); writers.put(Byte.class, (b, v) -\u0026gt; b.value((Byte) v)); writers.put(byte[].class, (b, v) -\u0026gt; b.value((byte[]) v)); writers.put(Date.class, XContentBuilder::timeValue); writers.put(Double.class, (b, v) -\u0026gt; b.value((Double) v)); writers.put(double[].class, (b, v) -\u0026gt; b.values((double[]) v)); writers.put(Float.class, (b, v) -\u0026gt; b.value((Float) v)); writers.put(float[].class, (b, v) -\u0026gt; b.values((float[]) v)); writers.put(Integer.class, (b, v) -\u0026gt; b.value((Integer) v)); writers.put(int[].class, (b, v) -\u0026gt; b.values((int[]) v)); writers.put(Long.class, (b, v) -\u0026gt; b.value((Long) v)); writers.put(long[].class, (b, v) -\u0026gt; b.values((long[]) v)); writers.put(Short.class, (b, v) -\u0026gt; b.value((Short) v)); writers.put(short[].class, (b, v) -\u0026gt; b.values((short[]) v)); writers.put(String.class, (b, v) -\u0026gt; b.value((String) v)); writers.put(String[].class, (b, v) -\u0026gt; b.values((String[]) v)); writers.put(Locale.class, (b, v) -\u0026gt; b.value(v.toString())); writers.put(Class.class, (b, v) -\u0026gt; b.value(v.toString())); writers.put(ZonedDateTime.class, (b, v) -\u0026gt; b.value(v.toString())); writers.put(Calendar.class, XContentBuilder::timeValue); writers.put(GregorianCalendar.class, XContentBuilder::timeValue); writers.put(BigInteger.class, (b, v) -\u0026gt; b.value((BigInteger) v)); writers.put(BigDecimal.class, (b, v) -\u0026gt; b.value((BigDecimal) v)); 可以发现，在6.7.1版本的源码里，多出了最后的两种数据类型的支持：BigInteger和BigDecimal。\nLimit of total fields [1000] in index has been exceeded 在索引数据时ES抛出异常：\n1 cause: ElasticsearchException[Elasticsearch exception [type=illegal_argument_exception, reason=Limit of total fields [1000] in index [item] has been exceeded]] 这是由于被索引的文档字段数量超过了默认的1000上限，两种解决方法，要么减少文档的字段，要么增加字段上限。\n增加字段上限可以只设置某个索引，也可以设置为全局的配置，对所有已存在的索引生效，但对之后新建的索引是无效的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 // 只设置test索引的配置 PUT http://localhost:9200/test/_settings { \u0026#34;index.mapping.total_fields.limit\u0026#34;: 5000 } // 全局的配置 PUT http://localhost:9200/_settings { \u0026#34;index.mapping.total_fields.limit\u0026#34;: 5000 } FORBIDDEN/12/index read-only / allow delete (api) 索引数据时报错如下：\n1 cause: ElasticsearchException[Elasticsearch exception [type=cluster_block_exception, reason=blocked by: [FORBIDDEN/12/index read-only / allow delete (api)];]] 这是ES节点的数据目录data磁盘空间使用率超过90%导致的，为了保护数据，ES将索引变为只读模式，只允许删除。\n此时需要增大磁盘的使用空间，有如下多种方法：\n集群增加节点 降低集群的索引副本数量 清理磁盘无用的数据，比如日志等 ES应该尽量别和其他项目部署在一起，磁盘容易被其他项目的日志挤占。此外，ES本身的日志和数据存储目录也可以配置在不同的目录，需要更改配置文件/config/elasticsearch.yml：\n1 2 3 4 5 6 7 8 9 # ----------------------------------- Paths ------------------------------------ # # Path to directory where to store the data (separate multiple locations by comma): # #path.data: /path/to/data # # Path to log files: # #path.logs: /path/to/logs 在增大了磁盘的使用空间后，索引的只读状态需要手动更改回来，可以更改所有索引，也可以只指定某个索引（用对应的索引名字取代_all，_all表示所有索引，如果不指定索引名，也不使用_all，同样表示修改全局配置）：\n1 2 3 4 5 6 7 // curl方式 curl -XPUT -H \u0026#34;Content-Type: application/json\u0026#34; http://localhost:9200/_all/_settings -d \u0026#39;{\u0026#34;index.blocks.read_only_allow_delete\u0026#34;: null}\u0026#39; // RESTful方式 PUT http://localhost:9200/_all/_settings {\u0026#34;index.blocks.read_only_allow_delete\u0026#34;: null} Result window is too large 报错如下：\n1 2 3 4 \u0026#34;root_cause\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;illegal_argument_exception\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;Result window is too large, from + size must be less than or equal to: [10000] but was [80000]. See the scroll api for a more efficient way to request large data sets. This limit can be set by changing the [index.max_result_window] index level setting.\u0026#34; }] ES分页查询（from+size）默认的最大查询结果数量为10000，可以通过修改max_result_window的值来提高上限：\n1 2 3 4 5 6 7 // curl方式 curl -XPUT -H \u0026#34;Content-Type: application/json\u0026#34; http://localhost:9200/_all/_settings -d \u0026#39;{\u0026#34;index.max_result_window\u0026#34; :\u0026#34;100000\u0026#34;}\u0026#39; // RESTful方式 PUT http://localhost:9200/_all/_settings {\u0026#34;index.max_result_window\u0026#34; :\u0026#34;100000\u0026#34;} failed to parse date field 在查询es时报错如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 { \u0026#34;error\u0026#34;: { \u0026#34;root_cause\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;parse_exception\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;failed to parse date field [2021-06-15 00:00:00] with format [strict_date_optional_time||epoch_millis]\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;search_phase_execution_exception\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;all shards failed\u0026#34;, \u0026#34;phase\u0026#34;: \u0026#34;query\u0026#34;, \u0026#34;grouped\u0026#34;: true, \u0026#34;failed_shards\u0026#34;: [{ \u0026#34;shard\u0026#34;: 0, \u0026#34;index\u0026#34;: \u0026#34;inspectbooking_kmt\u0026#34;, \u0026#34;node\u0026#34;: \u0026#34;Its-Juf2QXKEwmYYNu_aBQ\u0026#34;, \u0026#34;reason\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;parse_exception\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;failed to parse date field [2021-06-15 00:00:00] with format [strict_date_optional_time||epoch_millis]\u0026#34;, \u0026#34;caused_by\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;illegal_argument_exception\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;Unrecognized chars at the end of [2021-06-15 00:00:00]: [ 00:00:00]\u0026#34; } } }] }, \u0026#34;status\u0026#34;: 400 } 这是因为es的日期默认使用strict_date_optional_time和epoch_millis的format来匹配，前者是严格的ISO日期格式，后者是毫秒值格式。\n这里由于搜索日期值使用的是2021-06-15 00:00:00这种格式，无法被es的日期解析器解析成上述的两种格式，因此抛出异常。要避免这种异常，要么修改mapping中日期字段的format，比如说用||添加新的格式：\u0026quot;format\u0026quot;: \u0026quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis\u0026quot;；要么修改搜索日期时输入的值。\n由于mapping一旦确定就无法更改，因此更推荐改变被搜索的日期值格式这种做法：\n1 2 3 4 5 DateTimeFormatter dateTimePattern = DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;); // 日期字符串是从db中获取的零时区日期 TemporalAccessor parseDateTime = dateTimePattern.parse(\u0026#34;2021-06-15 00:00:00\u0026#34;); LocalDateTime localDateTime = LocalDateTime.from(parseDateTime); DateTimeFormatter.ISO_LOCAL_DATE_TIME.format(localDateTime); Request size exceeded 104857600 bytes 在使用bulk批处理ES请求时，报错如下：\n1 2 3 4 5 6 URI [/_bulk?timeout=1m], status line [HTTP/1.1 413 Request Entity Too Large] {\u0026#34;Message\u0026#34;:\u0026#34;Request size exceeded 104857600 bytes\u0026#34;} at org.elasticsearch.client.RestClient$SyncResponseListener.get(RestClient.java:926) at org.elasticsearch.client.RestClient.performRequest(RestClient.java:229) at org.elasticsearch.client.RestHighLevelClient.internalPerformRequest(RestHighLevelClient.java:1593) ... ES默认的请求内容最大值为100mb，超过100mb就会报错，可以在/config/elasticsearch.yml中添加如下配置：\n1 http.max_content_length: 200mb 注：AWS的ES似乎没有提供修改ES配置文件的服务，在请求最大值上也只有10mb或者100mb的两种选项。\nAWS Elasticsearch cluster method to update http.max_content_length? 查询区分大小写 Elasticsearch在索引数据时会进行分词，分词器会自动将英文转为小写，这样可以减少分词后的英文词项数量，从而减少内存的使用。\ntext类型会经过上述的分词，keyword类型则会将原本的文本原封不动进行保存。而Elasticsearch在精确查询（term查询）时，又是区分大小写的，这会导致一个情况：\n被查询的字段是text类型，搜索的关键词如果包含大写字母则会搜索不到结果，因为text类型被分词后的词项里全是小写字母。 被查询的字段是keyword类型则没有这个问题。 对于这个问题，如果希望搜索时保持区分大小写，可以把text类型改为keyword类型，这样还可以起到节省内存的效果，因为keyword类型不会分词，相当于索引的词项只有一个原始文本。\n如果只是希望能搜索到结果，又不想改类型，可以在程序中对用户搜索的关键词进行预处理，先将其转换为小写，再进行搜索，但是这样会导致搜索不到keyword类型的文本，因为原始文本可能包含了大写字母。对于这种情况，可以给keyword类型添加一个analysis分析器：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 # 给test_normalizer索引定义一个分析器normalizer # 将定义的分析器配置给keyword类型的字段 PUT test_normalizer { \u0026#34;settings\u0026#34;: { \u0026#34;analysis\u0026#34;: { \u0026#34;normalizer\u0026#34;: { \u0026#34;lowercase\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;custom\u0026#34;, \u0026#34;filter\u0026#34;: [\u0026#34;lowercase\u0026#34;] } } } }, \u0026#34;mappings\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34; }, \u0026#34;foo_normalizer\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;normalizer\u0026#34;: \u0026#34;lowercase\u0026#34; } } } } # 给test_normalizer索引一些测试数据 PUT test_normalizer/_doc/1 { \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;foo_normalizer\u0026#34;: \u0026#34;bar\u0026#34; } PUT test_normalizer/_doc/2 { \u0026#34;foo\u0026#34;: \u0026#34;Bar\u0026#34;, \u0026#34;foo_normalizer\u0026#34;: \u0026#34;Bar\u0026#34; } # 查询测试一 GET test_normalizer/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;:{ \u0026#34;foo\u0026#34;:\u0026#34;BaR\u0026#34; } } } # 查询测试二 GET test_normalizer/_search { \u0026#34;query\u0026#34;: { \u0026#34;term\u0026#34;:{ \u0026#34;foo_normalizer\u0026#34;:\u0026#34;bAr\u0026#34; } } } 由于上述配置了keyword的分析器，会将keyword类型的单词项进行小写处理，这样一来无论是写入ES的数据，还是搜索keyword时的词项都是全小写的，因此查询测试二可以成功搜索到数据。\n此外，text类型实际上会自动添加一个keyword类型的子字段来保存原始文本：\n1 2 3 4 5 6 7 8 9 \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;fields\u0026#34;: { \u0026#34;keyword\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;keyword\u0026#34;, \u0026#34;ignore_above\u0026#34;: 256 } } } 禁止通过某个字段来搜索到整个文档 通常情况下可以ES的全文搜索会通过匹配整个文档中的全部字段，如果不希望通过某个字段来搜索到整个文档，可以将该字段配置为index: false。\n1 2 3 4 5 6 7 8 9 10 # 这里的test是index，_doc是type，修改fieldA的mapping（只能增量更新，不能删改已存在的属性） PUT http://localhost:9200/test/_doc/_mapping { \u0026#34;properties\u0026#34;: { \u0026#34;fieldA\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;text\u0026#34;, \u0026#34;index\u0026#34;: false } } } maximum shards open 初始化索引时报错如下：\n1 2 3 4 5 6 7 8 9 10 11 { \u0026#34;error\u0026#34;: { \u0026#34;root_cause\u0026#34;: [{ \u0026#34;type\u0026#34;: \u0026#34;validation_exception\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;Validation Failed: 1: this action would add [2] total shards, but this cluster currently has [999]/[1000] maximum shards open;\u0026#34; }], \u0026#34;type\u0026#34;: \u0026#34;validation_exception\u0026#34;, \u0026#34;reason\u0026#34;: \u0026#34;Validation Failed: 1: this action would add [2] total shards, but this cluster currently has [999]/[1000] maximum shards open;\u0026#34; }, \u0026#34;status\u0026#34;: 400 } 这是因为从ES 7开始，集群中每个节点默认限制1000个分片，可以调大这个值：\n1 2 3 4 5 6 7 8 PUT /_cluster/settings { \u0026#34;transient\u0026#34;: { \u0026#34;cluster\u0026#34;: { \u0026#34;max_shards_per_node\u0026#34;:10000 } } } 也可以在配置文件config/elasticsearch.yml中进行设置：\n1 cluster.max_shards_per_node: 10000 more than allowed [85.0%] used disk on node ES集群无法分配副本分片，报错如下：\n1 [NO(more than allowed [85.0%] used disk on node, free: [9.81147727054615%])] 这是因为ES默认启用了磁盘分配决策：cluster.routing.allocation.disk.threshold_enabled默认为True。而85%的阈值是cluster.routing.allocation.disk.watermark.low设置的，即允许分配时的磁盘空间最小值，可以设置为比例或绝对值，如85%或者5G。当磁盘占用超过设定的值之后，系统将不会对此节点进行分片分配操作。\ncluster.routing.allocation.disk.watermark.high则表示允许保存分片节点磁盘空间的最大值，默认90%，超过该阈值时系统会把分片迁移到别的节点。也可以设置一个具体的大小值，当空间大于这个值的时候，系统会自动迁移到别的节点。\ncluster.info.update.interval：检查集群中的每个节点的磁盘使用情况的时间间隔，默认30秒。\ncluster.routing.allocation.disk.include_relocations：当计算节点的磁盘使用时需要考虑当前被分片的情况。\n一个临时方案是调大阈值：\n1 2 3 4 5 6 7 8 9 10 11 12 13 PUT /_cluster/settings{ \u0026#34;transient\u0026#34;: { \u0026#34;cluster.routing.allocation.disk.watermark.low\u0026#34;: \u0026#34;95%\u0026#34;, \u0026#34;cluster.routing.allocation.disk.watermark.high\u0026#34;: \u0026#34;20gb\u0026#34;, \u0026#34;cluster.info.update.interval\u0026#34;: \u0026#34;1m\u0026#34; } } 如果想完全解决，需要加数据节点，扩容集群。\n参考链接 ES 问题 ： too_many_clauses maxClauseCount is set to 1024 elastic search 5.4.版本，java api 调用出现：can not write type 【class java.math.BigDecimal】 java.lang.IllegalArgumentException: Limit of total fields 【1000】 in index 索引名称 ES 写索引报错 FORBIDDEN/12/index read-only / allow delete (api)解决方案 ES更改参数max_result_window Elasticsearch date 类型详解 hive向ES中插入数据量过大时出错：HTTP content length exceeded 104857600 bytes. Elasticsearch让 keyword 和 term 忽略大小写 解决ElasticSearch的maximum shards open问题 ElasticsearchIllegalArgumentException 错误 ","permalink":"https://lewky.cn/posts/elk-4/","tags":["Elasticsearch","工作记录"],"title":"ELK系列(4) - Elasticsearch问题汇总"},{"categories":["Hugo系列"],"contents":"前言 本博客使用的是Hugo的LoveIt主题，本文也是基于该主题而写的，不过Hugo的美化步骤应该大同小异，版本如下：\n1 2 3 hugo: v0.74.2/extended windows/amd64 BuildDate: unknown LoveIt: v0.2.10 请注意，本文的所有功能都离不开两个新增加的文件：_custom.scss和custom.js，部分功能还需要jquery，在第一章中会提及如何引入。\n另外本文篇幅太长，阅读体验不好，将其进行分章如下：\nHugo系列(3.0) - LoveIt主题美化与博客功能增强 · 第一章 Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章 Hugo系列(3.2) - LoveIt主题美化与博客功能增强 · 第三章 Hugo系列(3.3) - LoveIt主题美化与博客功能增强 · 第四章 显示最近更新的十篇文章 在归档页面只能看到所有以创建时间递减排序的文章列表，可以用下面的方法在归档页面开头增添十篇最近更新的文章。\n首先在配置文件config.toml中添加新的变量：\n1 2 3 [params.section] # 显示最近更新文章的数量 lastUpdatedSize = 15 接着将/themes/LoveIt/layouts/_default/section.html拷贝到/layouts/_default/section.html，打开拷贝后的文件，找到如下：\n1 {{- /* Paginate */ -}} 在这行代码的上方位置插入下面的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 {{- /* Last Modified */ -}} {{- $lastUpdatedSize := .Site.Params.section.lastUpdatedSize -}} {{- if $lastUpdatedSize -}} {{- if .Pages -}} {{- $pages := .Pages.ByLastmod.Reverse -}} \u0026lt;h3 class=\u0026#34;group-title\u0026#34;\u0026gt;最近更新 \u0026lt;sup\u0026gt;{{- $lastUpdatedSize -}}\u0026lt;/sup\u0026gt;\u0026lt;/h3\u0026gt; {{- range first $lastUpdatedSize $pages -}} \u0026lt;article class=\u0026#34;archive-item\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34; class=\u0026#34;archive-item-link\u0026#34;\u0026gt; {{- .Title -}} \u0026lt;/a\u0026gt; \u0026lt;span class=\u0026#34;archive-item-date2\u0026#34;\u0026gt; {{- \u0026#34;2006-01-02\u0026#34; | .Lastmod.Format -}} \u0026lt;/span\u0026gt; \u0026lt;/article\u0026gt; {{- end -}} {{- end -}} {{- end -}} 然后在/assets/css/_custom.scss中添加如下样式代码：\n1 2 3 .archive-item-date2 { color: #a9a9b3; } 同时为了方便区分开创建时间和最近更新时间，在每篇文章中也新增了最近更新时间这个meta。将/themes/LoveIt/layouts/posts/single.html拷贝到/layouts/posts/single.html，打开拷贝后的文件，找到如下：\n1 2 3 {{- with .Site.Params.dateformat | default \u0026#34;2006-01-02\u0026#34; | .PublishDate.Format -}} \u0026lt;i class=\u0026#34;far fa-calendar-alt fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;time datetime=\u0026#34;{{ . }}\u0026#34;\u0026gt;{{ . }}\u0026lt;/time\u0026gt;\u0026amp;nbsp; {{- end -}} 将上面的代码改为如下：\n1 2 3 4 5 6 {{- with .Site.Params.dateformat | default \u0026#34;2006-01-02\u0026#34; | .PublishDate.Format -}} \u0026lt;i class=\u0026#34;far fa-calendar fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;time datetime=\u0026#34;{{ . }}\u0026#34;\u0026gt;{{ . }}\u0026lt;/time\u0026gt;\u0026amp;nbsp; {{- end -}} {{- with .Site.Params.dateformat | default \u0026#34;2006-01-02\u0026#34; | .Lastmod.Format -}} \u0026lt;i class=\u0026#34;far fa-calendar-plus fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;time datetime=\u0026#34;{{ . }}\u0026#34;\u0026gt;{{ . }}\u0026lt;/time\u0026gt;\u0026amp;nbsp; {{- end -}} 添加抓住猫咪小游戏 在站点的content目录下新建一个文件夹，文件夹名字将被作为一个页面URL，然后在该文件夹下新建一个index.md文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 --- title: \u0026#39;逮住那只猫!\u0026#39; --- ## 游戏规则 1. 点击小圆点，围住小猫。 2. 你点击一次，小猫走一次。 3. 直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。 --- \u0026lt;div align=\u0026#34;center\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;catch-the-cat\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/js/catch-the-cat/phaser.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/js/catch-the-cat/catch-the-cat.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer=\u0026#34;defer\u0026#34; src=\u0026#34;//cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/js/catch-the-cat/game.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 如果文件夹命名为catch-the-cat，则可以通过\u0026lt;你的站点地址\u0026gt;/catch-the-cat/来访问到这个抓住猫咪的游戏页面。\n上述index.md中引入的JavaScript文件，可以下载下来放到你的站点或者其他地方，然后在index.md中改成对应的地址。\n添加鼠标点击文字特效 在custom.js中添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* 鼠标点击文字特效 */ var a_idx = 0; var a_click = 1; var a = new Array(\u0026#34;富强\u0026#34;, \u0026#34;民主\u0026#34;, \u0026#34;文明\u0026#34;, \u0026#34;和谐\u0026#34;, \u0026#34;自由\u0026#34;, \u0026#34;平等\u0026#34;, \u0026#34;公正\u0026#34; ,\u0026#34;法治\u0026#34;, \u0026#34;爱国\u0026#34;, \u0026#34;敬业\u0026#34;, \u0026#34;诚信\u0026#34;, \u0026#34;友善\u0026#34;, \u0026#34;老哥稳\u0026#34;, \u0026#34;带我飞\u0026#34;, \u0026#34;厉害了word哥\u0026#34;, \u0026#34;扎心了老铁\u0026#34;, \u0026#34;蓝瘦香菇\u0026#34;, \u0026#34;还有这种操作?\u0026#34;, \u0026#34;就是有这种操作\u0026#34;, \u0026#34;皮皮虾我们走\u0026#34;, \u0026#34;笑到猪叫\u0026#34;, \u0026#34;石乐志\u0026#34;, \u0026#34;不存在的\u0026#34;, \u0026#34;黑车!\u0026#34;, \u0026#34;我要下车!\u0026#34;, \u0026#34;他还只是个孩子\u0026#34;, \u0026#34;请不要放过他\u0026#34;, \u0026#34;惊不惊喜?\u0026#34;, \u0026#34;意不意外?\u0026#34;, \u0026#34;我有一个大胆的想法\u0026#34;, \u0026#34;你的良心不会痛吗\u0026#34;, \u0026#34;你心里就没点b数吗\u0026#34;, \u0026#34;没有,我很膨胀\u0026#34;, \u0026#34;秀\u0026#34;, \u0026#34;天秀\u0026#34;, \u0026#34;陈独秀\u0026#34;, \u0026#34;蒂花之秀\u0026#34;, \u0026#34;造化钟神秀\u0026#34;, \u0026#34;我去买几个橘子\u0026#34;, \u0026#34;你就站在此地\u0026#34;, \u0026#34;不要走动\u0026#34;, \u0026#34;我可能读了假书\u0026#34;, \u0026#34;贫穷限制了我的想象力\u0026#34;, \u0026#34;打call\u0026#34;, \u0026#34;当然是选择原谅她啊\u0026#34;, \u0026#34;你有freestyle吗\u0026#34;, \u0026#34;北大还行撒贝宁\u0026#34;, \u0026#34;不知妻美刘强东\u0026#34;, \u0026#34;悔创阿里杰克马\u0026#34;, \u0026#34;一无所有王健林\u0026#34;, \u0026#34;普通家庭马化腾\u0026#34;, \u0026#34;别点了\u0026#34;, \u0026#34;求求你别点了\u0026#34;, \u0026#34;你还点\u0026#34;, \u0026#34;你再点!\u0026#34;, \u0026#34;有本事继续点!\u0026#34;, \u0026#34;你厉害\u0026#34;, \u0026#34;我投翔\u0026#34;, \u0026#34;w(·Д·)w\u0026#34;, \u0026#34;(#`O′)\u0026#34;, \u0026#34;（/TДT)/\u0026#34;, \u0026#34;┭┮﹏┭┮\u0026#34;, \u0026#34;_(:3」∠)_\u0026#34;); jQuery(document).ready(function($) { $(\u0026#34;body\u0026#34;).click(function(e) { /* 点击频率，点击几次就换文字 */ var frequency = 2; if (a_click % frequency === 0) { var $i = $(\u0026#34;\u0026lt;span/\u0026gt;\u0026#34;).text(a[a_idx]); a_idx = (a_idx + 1) % a.length; var x = e.pageX, y = e.pageY; $i.css({ \u0026#34;z-index\u0026#34;: 9999, \u0026#34;top\u0026#34;: y - 20, \u0026#34;left\u0026#34;: x, \u0026#34;position\u0026#34;: \u0026#34;absolute\u0026#34;, \u0026#34;font-weight\u0026#34;: \u0026#34;bold\u0026#34;, \u0026#34;color\u0026#34;: randomColor(), \u0026#34;-webkit-user-select\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;-moz-user-select\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;-ms-user-select\u0026#34;: \u0026#34;none\u0026#34;, \u0026#34;user-select\u0026#34;: \u0026#34;none\u0026#34; }); $(\u0026#34;body\u0026#34;).append($i); $i.animate({ \u0026#34;top\u0026#34;: y - 180, \u0026#34;opacity\u0026#34;: 0 }, 1500, function() { $i.remove(); }); } a_click ++; }); }); 首页显示文章最近更新时间 将/themes/LoveIt/layouts/_default/summary.html拷贝到/layouts/_default/summary.html，打开拷贝后的文件，找到如下内容：\n1 2 3 4 5 {{- with .Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34; | .PublishDate.Format -}} \u0026amp;nbsp;\u0026lt;span class=\u0026#34;post-publish\u0026#34;\u0026gt; {{- printf `\u0026lt;time datetime=\u0026#34;%v\u0026#34;\u0026gt;%v\u0026lt;/time\u0026gt;` . . | dict \u0026#34;Date\u0026#34; | T \u0026#34;publishedOnDate\u0026#34; | safeHTML -}} \u0026lt;/span\u0026gt; {{- end -}} 修改成如下：\n1 2 3 4 5 6 7 8 9 10 11 {{- with .Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34; | .PublishDate.Format -}} \u0026amp;nbsp;\u0026lt;span class=\u0026#34;post-publish\u0026#34;\u0026gt; {{- printf `\u0026lt;time datetime=\u0026#34;%v\u0026#34;\u0026gt;%v\u0026lt;/time\u0026gt;` . . | dict \u0026#34;Date\u0026#34; | T \u0026#34;publishedOnDate\u0026#34; | safeHTML -}}, \u0026lt;/span\u0026gt; {{- end -}} {{- with .Site.Params.dateFormat | default \u0026#34;2006-01-02\u0026#34; | .Lastmod.Format -}} \u0026amp;nbsp;\u0026lt;span class=\u0026#34;post-publish\u0026#34;\u0026gt; {{- printf `\u0026lt;time datetime=\u0026#34;%v\u0026#34;\u0026gt;%v\u0026lt;/time\u0026gt;` . . | dict \u0026#34;Date\u0026#34; | T \u0026#34;updatedOnDate\u0026#34; | safeHTML -}}, \u0026lt;/span\u0026gt; {{- end -}} 参考链接 Lists of Content in Hugo ","permalink":"https://lewky.cn/posts/hugo-3-3/","tags":["Hugo","LoveIt主题","主题美化","功能增强"],"title":"Hugo系列(3.3) - LoveIt主题美化与博客功能增强 · 第四章"},{"categories":null,"contents":" O(∩_∩)O~ 万分感谢各位老板的打赏与红包！！ 感谢*政打赏20元！\n打赏文章为Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章#使用Waline替代Valine评论系统\n阅读被打赏文章\r2021-12-28\r感谢*炮打赏5元！\n打赏文章为Hexo系列(2.1) - NexT主题美化与博客功能增强 · 第二章#对文章进行加密\n阅读被打赏文章\r2021-08-23\r感谢布朗姆熊红包5元！\n打赏文章为Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章#使用Waline替代Valine评论系统\n阅读被打赏文章\r2021-08-11\r","permalink":"https://lewky.cn/donation/","tags":null,"title":"打赏榜"},{"categories":["Spring"],"contents":"使用Log4j2日志替代默认的Logback SpringBoot默认使用Logback打印日志，出于性能考虑想要改用Log4j2，需要修改POM中的依赖，移除默认的Logback依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 参考链接 springboot 日志管理logback切换log4j2 ","permalink":"https://lewky.cn/posts/springboot-issues/","tags":["SpringBoot","工作记录"],"title":"SpringBoot问题汇总"},{"categories":["Java"],"contents":"PowerMock报错导致无法运行测试类 在执行单元测试时报错如下：\n1 ScriptEngineManager providers.next(): javax.script.ScriptEngineFactory: Provider jdk.nashorn.api.scripting.NashornScriptEngineFactory not a subtype 在Stack Overflow上找到了同样的错误，该报错是在使用了PowerMock框架后发生的，奇怪的是，某些同样使用该框架的测试类却不会报错，暂时不明白抛出该异常的根本原因，先记录下解决方法。\n在当前测试类里加上一个忽略该异常的注解：@PowerMockIgnore，即可正常运行单元测试，如下：\n1 2 3 4 5 6 7 import org.powermock.core.classloader.annotations.PowerMockIgnore; @RunWith(PowerMockRunner.class) @PowerMockIgnore({\u0026#34;javax.script.*\u0026#34;}) public class VendorTest { //.... } 顺带一提，这里使用的PowerMock框架是2.0.2版本的。\n参考链接 Powermock keeps throwing errors for ScriptEngineManager ","permalink":"https://lewky.cn/posts/powermock-issues/","tags":["PowerMock","工作记录"],"title":"PowerMock问题汇总"},{"categories":["Spring"],"contents":"SpelEvaluationException: EL1030E 运行Spring项目时报错如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 org.springframework.expression.spel.SpelEvaluationException: EL1030E: The operator \u0026#39;ADD\u0026#39; is not supported between objects of type \u0026#39;java.lang.String\u0026#39; and \u0026#39;null\u0026#39; at org.springframework.expression.spel.ExpressionState.operate(ExpressionState.java:240) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:80) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:85) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:83) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:83) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:83) at org.springframework.expression.spel.ast.OpPlus.getValueInternal(OpPlus.java:83) at org.springframework.expression.spel.ast.SpelNodeImpl.getValue(SpelNodeImpl.java:109) at org.springframework.expression.spel.standard.SpelExpression.getValue .... at org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1415) at org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617) at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61) at java.lang.Thread.run(Thread.java:745) 从堆栈信息可以看出，该异常与spel有关。spel指的是Spring Expression Language，结合问题代码进行分析，可以认为该异常与spring表达式有关。而在我的代码里，只有@Cacheable注解里使用到了spel，如下：\n1 2 3 4 5 6 @Cacheable(key = \u0026#34;#root.target.getCacheKeyPrefix() + \u0026#39;::\u0026#39; + + #root.target.getRootDomain() + \u0026#39;-\u0026#39; + #root.target.getLocale() + \u0026#39;-\u0026#39; + #searchLabelKey\u0026#34;) public String getFromRootDomain(final String labelId, final String locale, final String searchLabelKey) { // TODO return null; } 很显然，在使用到该注解时，由于这里的spring表达式有问题，最终在解析时抛出了异常。经过检查发现，这里犯了个很逗的错误，就是连续使用了两个+，导致解析无法通过，改正后如下：\n1 @Cacheable(key = \u0026#34;#root.target.getCacheKeyPrefix() + \u0026#39;::\u0026#39; + #root.target.getRootDomain() + \u0026#39;-\u0026#39; + #root.target.getLocale() + \u0026#39;-\u0026#39; + #searchLabelKey\u0026#34;) 而之所以之前没能发现这个问题，是因为没有启用redis cache，导致避开了这个问题。目前刚开始了解spel这门表达式语言，在此记录下这个问题，方便日后回顾分析，参考链接里顺便贴上官方的一篇中译文档。\n@PathVariable会截断字符串中最后一个. 当使用了@PathVariable接收参数时，如果该参数的值包含有.这个符号，则最后的.以及之后的字符串会被截断。举个简单的例子，代码如下：\n1 2 3 4 5 @GetMapping(value = \u0026#34;/users/{loginId}\u0026#34;, produces = Constants.REQUEST_BODY_TYPE_APP_JSON) public UserDto getLatestUserByLoginId(@PathVariable final String loginId) throws DocumentNotFoundException { final UserDto result = userDocumentService.findDtoByLoginIdAndIsLatest(loginId); return result; } 当请求是/users/lewis.liu时，loginId参数接收到的值是lewis； 当请求是/users/lewis.liu.p时，loginId参数接收到的值是lewis.liu； 当请求是/users/lewis.liu.p.w时，loginId参数接收到的值是lewis.liu.p。 可以发现，@PathVariable注解会自动截断最后一个.以及之后的字符串。这是因为Spring认为最后一个.以及之后的字符串属于文件扩展类型，比如.java之类的，所以就自动将其截断了。\n解决这个问题可以在请求的变量占位符里加上正则表达式，如下：\n1 2 3 4 5 // 原来的写法 @GetMapping(value = \u0026#34;/users/{loginId}\u0026#34;, produces = Constants.REQUEST_BODY_TYPE_APP_JSON) // 改后的写法 @GetMapping(value = \u0026#34;/users/{loginId:.+}\u0026#34;, produces = Constants.REQUEST_BODY_TYPE_APP_JSON) 获取当前项目部署在Tomcat中的路径 1 2 3 4 5 6 7 8 import javax.servlet.ServletContext; import org.springframework.web.context.ContextLoader; import org.springframework.web.context.WebApplicationContext; WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); ServletContext servletContext = webApplicationContext.getServletContext(); String contextPath = servletContext.getContextPath(); 用jasypt加密配置文件中的敏感数据 生成环境的数据库密码等敏感信息是不能直接明文配置的，可以通过集成jasypt这个第三方库来实现配置中敏感数据的加解密。\n假如现在有一个数据库的配置文件jdbc.properties，其中的密码字段原本配置如下：\n1 jdbc.password=test123 由于密码是敏感数据，不能配置为明文，现在用jasypt来实现加密该字段。\n引入pom依赖： 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.jasypt\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jasypt-spring31\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; application.xml配置jasypt的bean 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;bean id=\u0026#34;environmentVariablesConfiguration\u0026#34; class=\u0026#34;org.jasypt.encryption.pbe.config.EnvironmentStringPBEConfig\u0026#34;\u0026gt; \u0026lt;!-- 盐值，用于加密 --\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;A1A26A54353E4BC5BDFCB355EF68FD99\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;configurationEncryptor\u0026#34; class=\u0026#34;org.jasypt.encryption.pbe.StandardPBEStringEncryptor\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;config\u0026#34; ref=\u0026#34;environmentVariablesConfiguration\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;bean id=\u0026#34;propertyConfigurer\u0026#34; class=\u0026#34;org.jasypt.spring31.properties.EncryptablePropertyPlaceholderConfigurer\u0026#34;\u0026gt; \u0026lt;constructor-arg ref=\u0026#34;configurationEncryptor\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;locations\u0026#34;\u0026gt; \u0026lt;list\u0026gt; \u0026lt;value\u0026gt;classpath:jdbc.properties\u0026lt;/value\u0026gt; \u0026lt;/list\u0026gt; \u0026lt;/property\u0026gt; \u0026lt;/bean\u0026gt; 在上述配置中，jasypt的bean指定了盐值和需要扫描的配置文件jdbc.properties。\n获取密文串并配置到配置文件中 在jasypt-1.9.2.jar目录下执行下面命令来获取加密后的密文串：\n1 java -cp jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI algorithm=PBEWithMD5AndDES password=A1A26A54353E4BC5BDFCB355EF68FD99 input=密码明文 上诉命令中algorithm是加密算法，password是盐值，input是明文，执行后结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 D:\\maven\\repository\\org\\jasypt\\jasypt\\1.9.2\u0026gt;java -cp jasypt-1.9.2.jar org.jasypt.intf.cli.JasyptPBEStringEncryptionCLI algorithm=PBEWithMD5AndDES password=A1A26A54353E4BC5BDFCB355EF68FD99 input=test123 ----ENVIRONMENT----------------- Runtime: Oracle Corporation Java HotSpot(TM) 64-Bit Server VM 25.202-b08 ----ARGUMENTS------------------- input: test123 algorithm: PBEWithMD5AndDES password: A1A26A54353E4BC5BDFCB355EF68FD99 ----OUTPUT---------------------- fMrbHTmCSpwVP206IfjYkw== OUTPUT即是输入的明文被加密后的密文，将密文配置到配置文件jdbc.properties中，用ENC()包括起来，取代原本的明文值：\n1 jdbc.password=ENC(fMrbHTmCSpwVP206IfjYkw==) 这样jasypt的bean在扫描到指定的配置文件时，遇到被ENC()包括起来的密文值，会自动解密成明文；也就实现了敏感数据的脱敏。\n解密密文得到明文 如果需要获取明文，可以用下面代码解密：\n1 2 3 4 5 6 7 8 9 10 // 加密时的盐值 String password = \u0026#34;A1A26A54353E4BC5BDFCB355EF68FD99\u0026#34;; // 密文 String encrypt = \u0026#34;fMrbHTmCSpwVP206IfjYkw==\u0026#34;; EnvironmentStringPBEConfig config = new EnvironmentStringPBEConfig(); config.setPassword(password); StandardPBEStringEncryptor encryptor = new StandardPBEStringEncryptor(); encryptor.setConfig(config); String decrypt = encryptor.decrypt(encrypt); System.out.println(\u0026#34;解密后明文：\u0026#34; + decrypt); 结果为：\n1 解密后明文：test123 查看类文件是加载的哪个jar包 通过jdk提供的接口可以打印出来类文件的加载路径：\n1 2 3 4 ProtectionDomain pd = Test.class.getProtectionDomain(); CodeSource codeSource = pd.getCodesource(); URL location = codeSource.getLocation(); System.out.println(location); 但是这个api对于系统类加载器加载的类会获取不到，报错NPE，比如String.class，对于这些类可以通过添加启动参数-verbose，在启动项目时打印出来所有被系统类加载器加载的类文件路径。\n参考链接 8. Spring 表达式语言 (SpEL) Spring MVC @PathVariable with dot (.) is getting truncated java -cp jasypt_SpringBoot使用jasypt加解密密码的实现方法 查看java类是从哪个包加载，并找出包所在路径 ","permalink":"https://lewky.cn/posts/spring-issues/","tags":["工作记录"],"title":"Spring问题汇总"},{"categories":["工作记录"],"contents":"iReport无法正常启动 最近需要用到iReport报表工具，但是在启动客户端时却发现会闪退，无法正常启动。查找了资料，发现是因为iReport无法支持jdk 1.8，必须要修改配置文件，将java版本指定为1.7或之前的版本。目前官网最新的版本是5.6.0，据说有外国大神说是下个版本将会支持jdk 1.8。\n找到iReport的安装目录，然后将etc/ireport.conf打开，可以看到有一行被注释的配置如下：\n1 #jdkhome=\u0026#34;path/to/jdk\u0026#34; 在这行注释下边加上一句：\n1 jdkhome=\u0026#34;C:\\Program Files\\Java\\jdk1.7.0_25\u0026#34; 具体路径以本地安装的jdk目录为准，保存修改后重新启动iReport客户端即可。\n另外补充一句，这个etc目录其实作用和Linux下的etc目录差不多，就是专门用来存放程序所需的整个文件系统的配置文件。etc不是什么缩写，是and so on的意思，来源于法语的et cetera，翻译成中文就是等等的意思。\nPDF导出中文不显示 iReport PDF导出时中文不显示，报错如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Error exporting print... Could not load the following font : pdfFontName : STSong-Light pdfEncoding : UniGB-UCS2-H isPdfEmbedded : true net.sf.jasperreports.engine.JRRuntimeException: Could not load the following font : pdfFontName : STSong-Light pdfEncoding : UniGB-UCS2-H isPdfEmbedded : true at net.sf.jasperreports.engine.export.JRPdfExporter.getFont(JRPdfExporter.java:2117) at net.sf.jasperreports.engine.export.JRPdfExporter.getChunk(JRPdfExporter.java:1906) at net.sf.jasperreports.engine.export.JRPdfExporter.getPhrase(JRPdfExporter.java:1875) at net.sf.jasperreports.engine.export.SimplePdfTextRenderer.getPhrase(SimplePdfTextRenderer.java:89) at net.sf.jasperreports.engine.export.SimplePdfTextRenderer.render(SimplePdfTextRenderer.java:100) at net.sf.jasperreports.engine.export.JRPdfExporter.exportText(JRPdfExporter.java:2238) at net.sf.jasperreports.engine.export.JRPdfExporter.exportElements(JRPdfExporter.java:950) at net.sf.jasperreports.engine.export.JRPdfExporter.exportPage(JRPdfExporter.java:909) at net.sf.jasperreports.engine.export.JRPdfExporter.exportReportToStream(JRPdfExporter.java:786) at net.sf.jasperreports.engine.export.JRPdfExporter.exportReport(JRPdfExporter.java:513) at com.jaspersoft.ireport.designer.compiler.IReportCompiler.run(IReportCompiler.java:1174) at org.openide.util.RequestProcessor$Task.run(RequestProcessor.java:572) at org.openide.util.RequestProcessor$Processor.run(RequestProcessor.java:997) 这是因为使用到了宋体，而iReport的classpath中缺少了字体对应的jar包，需要加入到classpath中。iReport本身已经提供了这个jar包了，就在安装目录下：ireport\\modules\\ext\\iTextAsian.jar\n点击工具 -\u0026gt; 选项 -\u0026gt; 选择Classpath页 -\u0026gt; Add JAR（由于屏幕分辨率的原因可能会看不到这个按钮，可以将当前的窗口页面往右边拉大出去，就会显示这些被隐藏了的按钮。）\n选择上述提及的iTextAsian.jar并确定，接着在Classpath页面中将刚刚添加的jar包打钩，然后重启iReport即可。\n如果在Web应用中需要导出PDF，同样需要把这个jar包添加到Web应用的WEB_INF\\lib中。\n参考链接 关于iReport5.6.0无法正常启动或者闪退或者JDK8不兼容的解决方案 linux下的etc是什么意思 iReport 5.6.0 PDF导出中文不显示问题 解决方案 Jaspersoft iReport Designer 4.7.0 导出pdf 中文不显示的解决办法 ","permalink":"https://lewky.cn/posts/ireport-issues/","tags":["iReport","报表工具"],"title":"iReport问题汇总"},{"categories":["日志框架"],"contents":"isDebugEnabled()的作用 查看公司项目的代码，发现在打印日志的时候会先进行一次判断，如下：\n1 2 3 if (LOGGER.isDebugEnabled()) { LOGGER.debug(\u0026#34;Search parameters: \u0026#34; + searchParams); } 我们使用的是Log4j框架，框架自身提供了类似的许多api，比如isErrorEnabled()，isInfoEnabled()等，每个Level对有对应的一个判断Level是否启用的api，实际上这些api都是调用的另一个api：isEnabled。\n在打印日志之前先进行Level的判断，是因为在执行打印语句时，首先会先将要打印的字符串信息作为参数传递给被调用的方法。如下代码：\n1 LOGGER.debug(\u0026#34;Search parameters: \u0026#34; + searchParams); 首先会执行字符串拼接的操作，会涉及到对象的toString()方法以及StringBuilder的创建，接着把拼接后的字符串传递给debug语句，这时候才会去判断打印日志的级别，来决定是否将这个字符串输入到对应的日志文件里。假如最终该语句并不会把字符串打印出来，那么这个拼接字符串的过程就属于毫无意义的操作，会增加系统性能的损耗。\n因此，在一些必要的地方，我们会先进行一次日志Level的判断，来避免不必要的性能损耗。\n使用{}占位符来打印日志 Log4j在升级到Log4j2后提供了新的打印日志的方式：允许使用{}占位符来打印日志，如下：\n1 LOGGER.debug(\u0026#34;Search parameters: {}\u0026#34;, searchParams); 通过占位符来打印日志有个好处，那就是不需要自己去预先判断日志的级别，其底层已经帮我们去实现这个步骤了。此外，使用占位符来打印日志，对于需要拼接大量变量的场景时，该方式也会更加地直观与优雅。如下：\n1 LOGGER.debug(\u0026#34;Current item id is {}, size is {}, color is {}, pattern is {}.\u0026#34;, id, size, color, pattern); 注意：在Log4j2中，这种占位符打印的方式，最多只能支持到9个变量参数。\n除了Log4j2，其它的日志框架同样支持占位符的写法，比如logback等。\n虽然使用{}占位符来打印日志很方便，但是却有可能引发堆栈溢出的问题，可参考下文。\n神奇的堆栈溢出问题StackOverflowError 自从把公司的系统从Log4j升级到Log4j2后，就总是时不时发生堆栈溢出的问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 java.lang.StackOverflowError: null at java.lang.ClassLoader.findLoadedClass(ClassLoader.java:1033) ~[?:1.8.0_66] at org.eclipse.jetty.webapp.WebAppClassLoader.loadClass(WebAppClassLoader.java:410) ~[?:?] at org.eclipse.jetty.webapp.WebAppClassLoader.loadClass(WebAppClassLoader.java:403) ~[?:?] at org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:65) ~[cbx-mybatis-3.3.0.jar:3.3.0] at com.sun.proxy.$Proxy62.query(Unknown Source) ~[?:?] at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:120) ~[cbx-mybatis-3.3.0.jar:3.3.0] at org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:113) ~[cbx-mybatis-3.3.0.jar:3.3.0] at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:122) ~[cbx-mybatis-3.3.0.jar:3.3.0] at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:64) ~[cbx-mybatis-3.3.0.jar:3.3.0] at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:53) ~[cbx-mybatis-3.3.0.jar:3.3.0] at com.sun.proxy.$Proxy68.findEntitesByCriterion(Unknown Source) ~[?:?] ··· at org.apache.logging.log4j.message.ParameterFormatter.appendMap(ParameterFormatter.java:562) ~[log4j-api-2.11.2.jar:2.11.2] at org.apache.logging.log4j.message.ParameterFormatter.appendPotentiallyRecursiveValue(ParameterFormatter.java:498) ~[log4j-api-2.11.2.jar:2.11.2] at org.apache.logging.log4j.message.ParameterFormatter.recursiveDeepToString(ParameterFormatter.java:456) ~[log4j-api-2.11.2.jar:2.11.2] at org.apache.logging.log4j.message.ParameterFormatter.appendMap(ParameterFormatter.java:573) ~[log4j-api-2.11.2.jar:2.11.2] at org.apache.logging.log4j.message.ParameterFormatter.appendPotentiallyRecursiveValue(ParameterFormatter.java:498) ~[log4j-api-2.11.2.jar:2.11.2] at org.apache.logging.log4j.message.ParameterFormatter.recursiveDeepToString(ParameterFormatter.java:456) ~[log4j-api-2.11.2.jar:2.11.2] at org.apache.logging.log4j.message.ParameterFormatter.appendMap(ParameterFormatter.java:573) ~[log4j-api-2.11.2.jar:2.11.2] at org.apache.logging.log4j.message.ParameterFormatter.appendPotentiallyRecursiveValue(ParameterFormatter.java:498) ~[log4j-api-2.11.2.jar:2.11.2] ··· 可以看到，这个StackOverflowError是由于无限递归调用了ParameterFormatter#recursiveDeepToString()导致的，这个ParameterFormatter是Log4j2里用来支持占位符打印日志的一个API，用法如下：\n1 LOGGER.debug(\u0026#34;Current item id is {}, size is {}, color is {}, pattern is {}.\u0026#34;, id, size, color, pattern); 这行代码是在升级到Log4j2后才改用占位符来打印的，原本的代码如下：\n1 LOGGER.debug(\u0026#34;Current item id is \u0026#34; + id + \u0026#34;, size is \u0026#34; + size + \u0026#34;, color is \u0026#34; + color + \u0026#34;, pattern is \u0026#34; + pattern + \u0026#34;.\u0026#34;); 当使用这种带多个参数的占位符语法去打印日志时，Log4j2就会调用ParameterFormatter#recursiveDeepToString()来格式化参数，并最终替换掉对应位置的占位符。\n可能是占位符打印日志的API设计问题，当被用于格式化的参数是一个复杂的对象时，比如POJO之类的，即上述例子中的size、color、pattern，就有可能由于重写了toString()方法，或者懒加载等原因而触发StackOverflowError。\n这个堆栈溢出并不会立刻抛出并结束，而是会在项目运行中卡死页面无响应十几分钟！经过测试，重新改回原本的写法便可避免该异常。网上也找不到类似的案例，只能将原因归结于Log4j2框架的ParameterFormatter#recursiveDeepToString()的bug了。\n在使用占位符打印日志时，要注意参数的类型，最好只使用简单的一些字符串来作为参数，尽量避免直接将一个复杂的对象作为参数，否则有可能引发预料之外的堆栈溢出问题。\nNoSuchMethodError: com.lmax.disruptor.dsl.Disruptor 项目使用了Log4j2，由于使用了全局异步打印日志的方式，还需要引入disruptor的依赖：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- log4j2 AsyncLogger need disruptor--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.lmax\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;disruptor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在项目启动类通过代码来启用全局异步打印日志(需要在第一次使用到log4j2的logger之前)：\n1 2 // use asyncLogger for log4j2 framework System.setProperty(\u0026#34;Log4jContextSelector\u0026#34;, \u0026#34;org.apache.logging.log4j.core.async.AsyncLoggerContextSelector\u0026#34;); 然而在启动项目后报错如下：\n1 2 3 4 java.lang.NoSuchMethodError: com.lmax.disruptor.dsl.Disruptor.\u0026lt;init\u0026gt;(Lcom/lmax/disruptor/EventFactory;ILjava/util/concurrent/ThreadFactory;Lcom/lmax/disruptor/dsl/ProducerType;Lcom/lmax/disruptor/WaitStrategy;)V at org.apache.logging.log4j.core.async.AsyncLoggerDisruptor.start(AsyncLoggerDisruptor.java:97) at org.apache.logging.log4j.core.async.AsyncLoggerContext.start(AsyncLoggerContext.java:75) at ....... 该问题是因为Disruptor的版本较低导致，将版本改用较新版本的即可：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.lmax\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;disruptor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; PatternLayout的格式化参数 1 2 3 4 5 6 7 8 9 10 11 12 13 Log4J采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下： 1）%t 用来输出生成该日志事件的线程的名称 2）%p 用于输出日志事件的优先级，即DEBUG，INFO，WARN，ERROR，FATAL 3）%r 用于输出从layout（布局）的构建到日志事件创建所经过的毫秒数 4）%c 用于输出日志事件的category（类别），通常就是所在类的全名 5）%F 用于输出被发出日志记录请求，其中的文件名 6）%d 用于输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d{yyyy-MM-dd HH:mm:ss,SSS} 7）%L 用于输出日志事件的发生位置，即在代码中的行数。 8）%l 用于输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。 9）%% 用于输出％标志，%即为转义标志 10）%M 用于输出打印该条日志的方法名 11）%m 用于输出代码中指定的消息 12）%n 用于输出一个回车换行符，Windows平台为“rn”，Unix平台为“n” 输出的日志信息可能长短不一，可以通过格式修饰符来对齐。 格式修饰符：可以控制输出字段的最小字段宽度、最大字段宽度、字段对齐格式，如下所示：\n格式修饰符 对齐方式 最小宽度 最大宽度 备注（对%c来使用格式修饰符，所以改变的是类别名称） %-20c 左对齐 20 none 用空格右垫，如果类别名称少于20个字符长 %20c 右对齐 20 none 用空格左垫，如果类别名称少于20个字符长 %.30c 左对齐 none 30 从开始截断，如果类别名称超过30个字符长 %-20.30c 左对齐 20 30 用空格右侧垫，如果类别名称短于20个字符。但是，如果类别名称长度超过30个字符，那么从开始截断。 %20.30c 右对齐 20 30 用空格左侧垫，如果类别名称短于20个字符。但是，如果类别名称长度超过30个字符，那么从开始截断。 启用热部署 在configuration标签里可以通过设置monitorInterval属性来配置热部署功能，即扫描当前配置文件的间隔时间。单位为秒，不配置则默认值为0；官方文档提及如果配置了值，则会有个最小值5。\n具体细节可以参考这篇文章，里面有源码分析：Log4j和Log4j2怎么动态加载配置文件\n下面是一个简要的demo：\n1 2 3 4 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration xmlns:xi=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34; monitorInterval=\u0026#34;30\u0026#34; status=\u0026#34;error\u0026#34;\u0026gt; .... \u0026lt;/configuration\u0026gt; configuration标签里还有个status属性，用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出。这里设置成error后则只能看到log4j2自身error级以上级别的日志信息。\n在脚本中指定配置文件路径 通常项目会通过bat或者shell脚本来运行，而配置文件又存放在其他路径，需要在脚本中另外指定配置文件的路径。\nLog4j的配置文件路径参数为-Dlog4j.configuration，在用java命令执行项目时加入改参数即可：\n1 java com.test.Test -Dlog4j.configuration=config/log4j.xml Log4j2的配置文件路径参数为-Dlog4j.configurationFile，如下：\n1 java com.test.Test -Dlog4j.configurationFile=config/log4j2.xml 使用XInclude来引入参数文件 Log4j2的配置文件可以设置一些参数变量，方便下文使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration monitorInterval=\u0026#34;30\u0026#34;\u0026gt; \u0026lt;Properties\u0026gt; \u0026lt;Property name=\u0026#34;logstash.host\u0026#34;\u0026gt;udp:localhost\u0026lt;/Property\u0026gt; \u0026lt;Property name=\u0026#34;logstash.port\u0026#34;\u0026gt;4567\u0026lt;/Property\u0026gt; \u0026lt;/Properties\u0026gt; \u0026lt;Appenders\u0026gt; \u0026lt;!-- This appender is used for indexing CommandLog into Elasticsearch by ELK. --\u0026gt; \u0026lt;Gelf name=\u0026#34;logstash-gelf\u0026#34; host=\u0026#34;${logstash.host}\u0026#34; port=\u0026#34;${logstash.port}\u0026#34; version=\u0026#34;1.1\u0026#34; ignoreExceptions=\u0026#34;true\u0026#34; extractStackTrace=\u0026#34;true\u0026#34; filterStackTrace=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;/Gelf\u0026gt; \u0026lt;/Appenders\u0026gt; \u0026lt;Loggers\u0026gt; \u0026lt;Logger name=\u0026#34;elk\u0026#34; level=\u0026#34;info\u0026#34; additivity=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;logstash-gelf\u0026#34;/\u0026gt; \u0026lt;/Logger\u0026gt; \u0026lt;Root level=\u0026#34;error\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;logfile\u0026#34; /\u0026gt; \u0026lt;/Root\u0026gt; \u0026lt;/Loggers\u0026gt; \u0026lt;/configuration\u0026gt; 有时候这个参数，不只是某个项目的配置文件使用，可能多个项目之间都是共享同样的变量值，这时候可以通过将公共的参数变量定义到一个单独的文件中，然后通过XInclude来引入参数文件：\n首先定义一个单独的参数文件，假如命名为log4j-xinclude-properties.xml：\n1 2 3 4 5 6 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Properties\u0026gt; \u0026lt;Property name=\u0026#34;logstash.host\u0026#34;\u0026gt;udp:localhost\u0026lt;/Property\u0026gt; \u0026lt;Property name=\u0026#34;logstash.port\u0026#34;\u0026gt;4567\u0026lt;/Property\u0026gt; \u0026lt;/Properties\u0026gt; 然后在原本的配置文件log4j2.xml中引入XInclude，注意需要在文件头里引入该标签：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration xmlns:xi=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34; monitorInterval=\u0026#34;30\u0026#34;\u0026gt; \u0026lt;xi:include href=\u0026#34;log4j-xinclude-properties.xml\u0026#34; /\u0026gt; \u0026lt;Appenders\u0026gt; \u0026lt;!-- This appender is used for indexing CommandLog into Elasticsearch by ELK. --\u0026gt; \u0026lt;Gelf name=\u0026#34;logstash-gelf\u0026#34; host=\u0026#34;${logstash.host}\u0026#34; port=\u0026#34;${logstash.port}\u0026#34; version=\u0026#34;1.1\u0026#34; ignoreExceptions=\u0026#34;true\u0026#34; extractStackTrace=\u0026#34;true\u0026#34; filterStackTrace=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;/Gelf\u0026gt; \u0026lt;/Appenders\u0026gt; \u0026lt;Loggers\u0026gt; \u0026lt;Logger name=\u0026#34;elk\u0026#34; level=\u0026#34;info\u0026#34; additivity=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;logstash-gelf\u0026#34;/\u0026gt; \u0026lt;/Logger\u0026gt; \u0026lt;Root level=\u0026#34;error\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;logfile\u0026#34; /\u0026gt; \u0026lt;/Root\u0026gt; \u0026lt;/Loggers\u0026gt; \u0026lt;/configuration\u0026gt; 当然，XInclude不只是可以引入其他文件的Properties节点，实际上也可以引入公共的Appenders或者Loggers节点，注意它只能引入这种一级节点，且一级节点是不能重复定义的，也就是说如果引入了一个Properties节点，那么原本的配置文件中就不能定义该节点了，否则会冲突或者报错。\n此外，配置中的变量占位符${key}可以用${key:-defaultValue}的形式来设置默认值：\n1 2 ${logstash.host:-udp:localhost} ${logstash.port:-4567} NDC和MDC功能 NDC（Nested Diagnostic Context）和MDC（Mapped Diagnostic Context）是Log4j提供的一个线程共享的变量容器，NDC对应Stack，MDC对应Map，可以将变量存入其中，然后在打印日志时通过PatternLayout来将变量值打印出来，比如打印当前用户的用户id等。\n从功能来看，其实跟Java提供的ThreadLocal差不多。NDC和MDC都是线程独立的，子线程会从父线程拷贝上下文。用法很简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // NDC 1.开始调用 NDC.push(message); 2.删除栈顶消息 NDC.pop(); 3.清除全部的消息，必须在线程退出前显示的调用，否则会导致内存溢出。 NDC.remove(); 4.输出模板，注意是小写的[%x] log4j.appender.stdout.layout.ConversionPattern=[%d{yyyy-MM-dd HH:mm:ssS}] [%x] : %m%n // MDC 1.保存信息到上下文 MDC.put(key, value); 2.从上下文获取设置的信息 MDC.get(key); 3.清楚上下文中指定的key的信息 MDC.remove(key); 4.清除所有 clear() 5.输出模板，注意是大写[%X{key}] log4j.appender.consoleAppender.layout.ConversionPattern = %-4r [%t] %5p %c %x - %m - %X{key}%n // PatternLayout %X 输出Map中全部数据 %X{key} 指定输出Map中的key的值 %x 输出Stack中的全部内容 而到了Log4j2中，将MDC和NDC合并到了一个新的类ThreadContext中，不过API和PatternLayout还是和NDC、MDC的用法一样。去查看底层源码，会发现内置了一个Stack和Map：\n1 2 3 4 public final class ThreadContext { private static ThreadContextMap contextMap; private static ThreadContextStack contextStack; } IllegalStateException: No factory method found for class 在使用Log4j2时，虽然可以正确读取配置文件并生成log文件，但偶然发现控制台打印了异常信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 2018-12-31 17:28:14,282 Log4j2-TF-19-ConfiguratonFileWatcher-6 ERROR Unable to invoke factory method in class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile: java.lang.IllegalStateException: No factory method found for class org.apache.logging.log4j.core.appender.RollingFileAppender java.lang.IllegalStateException: No factory method found for class org.apache.logging.log4j.core.appender.RollingFileAppender at org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.findFactoryMethod(PluginBuilder.java:235) at org.apache.logging.log4j.core.config.plugins.util.PluginBuilder.build(PluginBuilder.java:135) at org.apache.logging.log4j.core.config.AbstractConfiguration.createPluginObject(AbstractConfiguration.java:959) at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:899) at org.apache.logging.log4j.core.config.AbstractConfiguration.createConfiguration(AbstractConfiguration.java:891) at org.apache.logging.log4j.core.config.AbstractConfiguration.doConfigure(AbstractConfiguration.java:514) at org.apache.logging.log4j.core.config.AbstractConfiguration.initialize(AbstractConfiguration.java:238) at org.apache.logging.log4j.core.config.AbstractConfiguration.start(AbstractConfiguration.java:250) at org.apache.logging.log4j.core.LoggerContext.setConfiguration(LoggerContext.java:547) at org.apache.logging.log4j.core.LoggerContext.onChange(LoggerContext.java:670) at org.apache.logging.log4j.core.config.ConfiguratonFileWatcher$ReconfigurationRunnable.run(ConfiguratonFileWatcher.java:68) at java.lang.Thread.run(Thread.java:748) 将控制台的所有信息都复制出来，仔细查找，又发现了相关的异常信息：\n1 2 3 4 5 6 7 8 9 10 11 12 2018-12-31 17:28:14,241 Log4j2-TF-19-ConfiguratonFileWatcher-6 ERROR Unable to create file logs/${ctx:domainId}/CNTCore.log java.io.IOException: The filename, directory name, or volume label syntax is incorrect at java.io.WinNTFileSystem.canonicalize0(Native Method) at java.io.WinNTFileSystem.canonicalize(WinNTFileSystem.java:428) at java.io.File.getCanonicalPath(File.java:618) at .... 2018-12-31 17:28:14,280 Log4j2-TF-19-ConfiguratonFileWatcher-6 ERROR Could not create plugin of type class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile: java.lang.IllegalStateException: ManagerFactory [...] unable to create manager for [logs/${ctx:domainId}/CNTCore.log] with data [...] java.lang.IllegalStateException: ManagerFactory [...] unable to create manager for [logs/${ctx:domainId}/CNTCore.log] with data [...] at org.apache.logging.log4j.core.appender.AbstractManager.getManager(AbstractManager.java:115) at org.apache.logging.log4j.core.appender.OutputStreamManager.getManager(OutputStreamManager.java:114) at org.apache.logging.log4j.core.appender.rolling.RollingFileManager.getFileManager(RollingFileManager.java:188) at .... 看起来是因为配置文件里的RollingFile使用到了${ctx:domainId}导致了这个问题。百度了下，发现了Log4j2的jira issue：Unable to invoke factory method in class class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile\n该问题和我遇到的一样，而在jira里有comment如下：\n1 Question: Does system property logfile have a value? 结合项目的配置文件log4j2.xml:\n1 2 3 4 5 6 7 8 9 \u0026lt;RollingFile name=\u0026#34;logfile\u0026#34; immediateFlush=\u0026#34;true\u0026#34; fileName=\u0026#34;logs/${ctx:domainId}/CNTCore.log\u0026#34; filePattern=\u0026#34;logs/${ctx:domainId}/CNTCore.log.%d{yyyy-MM-dd-a}.gz\u0026#34; append=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;PatternLayout\u0026gt; \u0026lt;pattern\u0026gt;%d %t %p %X{TracingMsg} %c - %m%n\u0026lt;/pattern\u0026gt; \u0026lt;/PatternLayout\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy modulate=\u0026#34;true\u0026#34; interval=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; 可以看出，这个异常是由于RollingFile使用到了${ctx:domainId}，而该变量值是null，导致无法创建对应的RollingFile文件到磁盘。但是这个domainId是通过ThreadContext把值put进去的，不可能是null，从最终的效果来看，这个变量其实也是拿到了值的，因为对应的日志文件已经存在于磁盘上了。\n既然如此，为什么还会出现这个异常呢？通过观察控制台可以发现，每过一段时间就会出现一次该异常。从异常中可以看到ConfiguratonFileWatcher，好像有些明白为什么了。\nConfiguratonFileWatcher是用来扫描配置文件是否被改动过的，在配置文件中设置的扫描间隔是30s：\n1 2 3 \u0026lt;configuration monitorInterval=\u0026#34;30\u0026#34;\u0026gt; .... \u0026lt;/configuration\u0026gt; 由于扫描文件时另外起一个线程去扫描的，而${ctx:domainId}的值是存放于ThreadContext中的，ThreadContext是线程安全的，同一个key对应的value在不同线程中是不一定相同的。而对于新启动的线程来说，并没有将domainId的值存放进去，于是新线程在扫描配置文件的RollingFile时，自然是无法获取到${ctx:domainId}的值，故而每隔一段时间就会报上边的异常。\n解决方案一 既然问题是因为扫描配置文件是否改动造成的，那么只要将动态加载的功能关闭就行了，如下：\n1 2 3 \u0026lt;configuration monitorInterval=\u0026#34;0\u0026#34;\u0026gt; .... \u0026lt;/configuration\u0026gt; 解决方案二 如果希望不关闭动态加载配置文件的功能，可以将domainId的值存放到System.properties里：\n1 System.setProperty(\u0026#34;domainId\u0026#34;, \u0026#34;xxx\u0026#34;); 然后通过${sys:xxx}的方式来获取该properties的值：\n1 2 3 4 5 6 7 8 9 \u0026lt;RollingFile name=\u0026#34;logfile\u0026#34; immediateFlush=\u0026#34;true\u0026#34; fileName=\u0026#34;logs/${sys:domainId}/CNTCore.log\u0026#34; filePattern=\u0026#34;logs/${sys:domainId}/CNTCore.log.%d{yyyy-MM-dd-a}.gz\u0026#34; append=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;PatternLayout\u0026gt; \u0026lt;pattern\u0026gt;%d %t %p %X{TracingMsg} %c - %m%n\u0026lt;/pattern\u0026gt; \u0026lt;/PatternLayout\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy modulate=\u0026#34;true\u0026#34; interval=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; 在log4j2中关于这些变量取值有以下这些种类：\nPrefix Context bundle Resource bundle. The format is ${bundle:BundleName:BundleKey}. The bundle name follows package naming conventions, for example: ${bundle:com.domain.Messages:MyKey}. ctx Thread Context Map (MDC) date Inserts the current date and/or time using the specified format env System environment variables. The formats are ${env:ENV_NAME} and ${env:ENV_NAME:-default_value}. jndi A value set in the default JNDI Context. jvmrunargs A JVM input argument accessed through JMX, but not a main argument; see RuntimeMXBean.getInputArguments(). Not available on Android. log4j Log4j configuration properties. The expressions ${log4j:configLocation} and ${log4j:configParentLocation} respectively provide the absolute path to the log4j configuration file and its parent folder. main A value set with MapLookup.setMainArguments(String[]) map A value from a MapMessage sd A value from a StructuredDataMessage. The key \u0026ldquo;id\u0026rdquo; will return the name of the StructuredDataId without the enterprise number. The key \u0026ldquo;type\u0026rdquo; will return the message type. Other keys will retrieve individual elements from the Map. sys System properties. The formats are ${sys:some.property} and ${sys:some.property:-default_value}. 解决方案三 不要在RollingFile的fileName和filePattern属性里使用到${ctx:domainId}等NDC和MDC的写法，这样会导致在log4j2异步扫描重加载配置文件的时候报错。\n可以使用另一种Appender来实现这种把日志分别打印到不同文件的效果，那就是路由日志RoutingAppender。有兴趣的可以去了解下这个，还是挺有意思的。\nLogj4 1.x怎么使用异步日志 异步日志是Log4j2引入的新特性，但可以通过导入一个桥接包log4j-1.2-api-2.6.jar，这样就可以用旧版本的Log4j 1.x的API来调用Log4j2的实现。\n当然更推荐的做法是，直接升级Log4j到2.x版本。\n回滚策略 RollingFile标签里可以配置回滚策略Policies，有两种类型：一种是基于体积回滚日志，一种是基于日期。可以同时配置多个回滚策略：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;RollingFile name=\u0026#34;cntCorelog\u0026#34; immediateFlush=\u0026#34;true\u0026#34; fileName=\u0026#34;logs/CNTCore.log\u0026#34; filePattern=\u0026#34;logs/%d{yyyy/MM/dd}/CNTCore.log.%d{yyyy-MM-dd-HH}-%i.gz\u0026#34; append=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;PatternLayout\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS}:%p %t %X{TracingMsg} %c - %m%n\u0026lt;/pattern\u0026gt; \u0026lt;/PatternLayout\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;SizeBasedTriggeringPolicy size=\u0026#34;100MB\u0026#34; /\u0026gt; \u0026lt;TimeBasedTriggeringPolicy modulate=\u0026#34;true\u0026#34; interval=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;DefaultRolloverStrategy max=\u0026#34;30\u0026#34;/\u0026gt; \u0026lt;/RollingFile\u0026gt; TimeBasedTriggeringPolicy标签的interval表示回滚间隔，1表示每经过一个单位的最小时间粒度就回滚一次。modulate表示回滚的时间点是否校准为零点整。\n回滚日志的最小时间粒度由filePattern决定，比如%d{yyyy-MM-dd-HH}表示最小时间粒度为小时，以最后一个符号为准。\nDefaultRolloverStrategy无效，超出上限的日志没有被删除 默认的DefaultRolloverStrategy的max默认值是7，如下：\n1 \u0026lt;DefaultRolloverStrategy max=\u0026#34;7\u0026#34;/\u0026gt; 这里的max属性并非指日志的保留上限，而是指filePattern的计数器%i的最大值，max属性必须和这个计数器%i搭配使用才有效果，此外filePattern的最小时间粒度为分钟。如下：\nRollingFile会自动按照filePattern的最小时间粒度进行日志的切割回滚。\n1 2 3 4 5 6 7 8 9 10 \u0026lt;RollingFile name=\u0026#34;cntCorelog\u0026#34; immediateFlush=\u0026#34;true\u0026#34; fileName=\u0026#34;logs/CNTCore.log\u0026#34; filePattern=\u0026#34;logs/%d{yyyy/MM/dd}/CNTCore.log.%d{yyyy-MM-dd-HH}-%i.gz\u0026#34; append=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;PatternLayout\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS}:%p %t %X{TracingMsg} %c - %m%n\u0026lt;/pattern\u0026gt; \u0026lt;/PatternLayout\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy modulate=\u0026#34;true\u0026#34; interval=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;DefaultRolloverStrategy max=\u0026#34;30\u0026#34;/\u0026gt; \u0026lt;/RollingFile\u0026gt; 上述配置的回滚日志会存放到名字为日期格式的子目录里，因此max统计的是子目录里的数量。如果需要统计所有的子目录里的日志数量，则需要对DefaultRolloverStrategy进行特殊配置：\n1 2 3 4 5 6 7 \u0026lt;DefaultRolloverStrategy max=\u0026#34;30\u0026#34;\u0026gt; \u0026lt;Delete basePath=\u0026#34;logs/%d{yyyy/MM/dd}/\u0026#34; maxDepth=\u0026#34;2\u0026#34;\u0026gt; \u0026lt;IfFileName glob=\u0026#34;*.gz\u0026#34; /\u0026gt; \u0026lt;!--7天--\u0026gt; \u0026lt;IfLastModified age=\u0026#34;168H\u0026#34; /\u0026gt; \u0026lt;/Delete\u0026gt; \u0026lt;/DefaultRolloverStrategy\u0026gt; Delete标签内决定了删除过期文件的规则：\nIfLastModified的age的时间粒度要和filePattern的一致，此外age填写的数字最好大于2，否则可能造成删除的时候IfLastModified的age的时间粒度要和filePattern的一致，此外age填写的数字最好大于2，否则可能造成删除的时候, 最近的文件还处于被占用状态,导致删除不成功。 maxDepth是递归统计的目录深度，basePath是需要处理的目录，maxDepth=\u0026quot;1\u0026quot;表示当前目录，即basePath。 路由日志RoutingAppender 如果想要将日志文件生成到指定的目录里，这个目录是动态的，由程序来控制具体的值，比如说，对于不同的用户，可以将这些用户专属的日志存放到各自的目录里进行分类，方便后续跟踪。\n这种时候，就需要使用到路由日志RoutingAppender，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 \u0026lt;Appenders\u0026gt; \u0026lt;Routing name=\u0026#34;domainAppender\u0026#34;\u0026gt; \u0026lt;Routes pattern=\u0026#34;$${ctx:domainId}\u0026#34;\u0026gt; \u0026lt;!-- This route is chosen if ThreadContext has no value for key domainId. --\u0026gt; \u0026lt;Route key=\u0026#34;$${ctx:domainId}\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;!-- This route is chosen if ThreadContext has value \u0026#39;/\u0026#39; for key domainId. --\u0026gt; \u0026lt;Route key=\u0026#34;/\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;\u0026#34; /\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;!-- This route is chosen if ThreadContext has value(besides \u0026#39;/\u0026#39;) for key domainId. --\u0026gt; \u0026lt;Route\u0026gt; \u0026lt;RollingFile name=\u0026#34;${ctx:domainId}-cntCorelog\u0026#34; immediateFlush=\u0026#34;true\u0026#34; fileName=\u0026#34;logs/${ctx:domainId}/CNTCore.log\u0026#34; filePattern=\u0026#34;logs/${ctx:domainId}/CNTCore.log.%d{yyyy-MM-dd-a}.gz\u0026#34; append=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;PatternLayout\u0026gt; \u0026lt;pattern\u0026gt;%d %t %p %X{TracingMsg} %c - %m%n\u0026lt;/pattern\u0026gt; \u0026lt;/PatternLayout\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy modulate=\u0026#34;true\u0026#34; interval=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;/Route\u0026gt; \u0026lt;/Routes\u0026gt; \u0026lt;/Routing\u0026gt; \u0026lt;/Appenders\u0026gt; $${}这里的两个$$是对$进行了转义，这里表示动态计算占位符${}的值。如果是${}占位符，只会计算第一次然后替换为对应的值，而$${}每一次都会计算值。换句话说，${}只能生效一次，后续就算改变了变量值也无效。\n而$${ctx:domainId}指的是存放于MDC中的一个变量domainId的值，在上述配置中不同用户的domainId是不一样的，这样就可以实现对不同用户的日志进行归类。\nLog4j升级到Log4j2 由于公司老项目的日志管理十分混乱，大部分地方使用自定制的打印类工具来打印，小部分地方用的slf4j+log4j。Log4j在高并发场景下，也会有引发线程阻塞的情况。\n为了便于管理，以及提高日志打印的性能，决定将日志从Log4j升级到Log4j2。并且统一使用slf4j+log4j2的方式来打印日志，关于slf4j等日志门面，可以看这篇文章：日志框架与门面模式\n首先是移除低版本的Log4j日志依赖：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-log4j12\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; 然后是添加Log4j2的依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- web工程需要包含log4j-web，非web工程不需要 --\u0026gt; \u0026lt;!-- 用来释放日志资源（关闭数据库连接，关闭文件等） --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- log4j2的异步日志AsyncLogger需要disruptor--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.lmax\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;disruptor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 关于log4j-web这个jar包，可以看看这个问答：web项目中log4j2的log4j-web包如果不添加，会影响哪些日志输出？\n接着是添加slf4j的依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 桥接slf4j和log4j2 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-slf4j-impl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 下面的桥接包都是为了兼容第三方库的日志打印 --\u0026gt; \u0026lt;!-- 将jcl桥接为slf4j --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jcl-over-slf4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- 将log4j桥接为slf4j --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-over-slf4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 最后是改变日志的配置文件，将log4j.properties替换成log4j2.xml。\n下面是Log4j官方网站的迁移文档说明：\nMigrating from Log4j 1.x\nSpringBoot项目使用Log4j2 SpringBoot项目默认使用commons-logging + Logback，可以用下面的方式改为使用Log4j2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!-- use log4j2 instead of logback --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-logging\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-log4j2\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 路由日志引发的OOM 生产上在分配了2g最大内存的机器上发生了OOM，分析dump后推测可能跟log4j2内存泄漏有关。由于项目使用了路由日志，将每笔交易日志自动路由到对应的日志中，如果发生了一百笔不同的交易，则会生成一百个不同的交易日志文件。在GitHub上找到相关的一个内存泄漏issue ，其中提及Log4j Core 2.17.1和更早以前的版本存在内存泄漏的问题，只要运行时间足够久，迟早引发OOM，解决方案是升级到2.20.0版本。\n因为项目中使用的SpringBoot和异步打印，因此需要升级两个依赖为如下版本：\n1 2 \u0026lt;log4j2.version\u0026gt;2.20.0\u0026lt;/log4j2.version\u0026gt; \u0026lt;com.lmax.disruptor.version\u0026gt;3.4.2\u0026lt;/com.lmax.disruptor.version\u0026gt; 如果不想升级版本，那就只能扩大内存，并放弃使用路由日志了。另外提一嘴，交易量大的时候，由于需要同时处理大量的路由日志文件，线程池的线程会频繁地切换上下文导致CPU飙升，同时线程内部的ThreadLocal缓存也占用了大量内存，在升级到新版本后该问题得以改善。\n参考链接 Java日志框架中真的需要判断log.isDebugEnabled()吗？ Unable to invoke factory method in class class org.apache.logging.log4j.core.appender.RollingFileAppender for element RollingFile Property Substitution Can i run my log asynchronously using log4j 1.x with log4j.properties file? Log4j2中RollingFile的文件滚动更新机制 log4j2定期生成和删除过期日志文件的配置 Log4j2进阶使用(按大小时间备份日志) log4j（二）——如何控制日志信息的输出？ Log4j2配置文件详解 Log4j2 File Inclusion : and similar to Logback Java日志Log4j或者Logback的NDC和MDC功能 使用Slf4j集成Log4j2构建项目日志系统的完美解决方案 ","permalink":"https://lewky.cn/posts/log4j2-issues/","tags":["Log4j","Log4j2","工作记录"],"title":"Log4j、Log4j2问题汇总"},{"categories":["工作记录"],"contents":"前言 本文基于2021-2版本的IDEA。\n无法搜索或者下载插件 File -\u0026gt; Settings... -\u0026gt; Plugins可以打开插件市场，搜索想要下载的插件，但是可能由于网络问题而无法成功搜索或者下载插件。此时需要设置代理来解决。\n点击插件界面里的齿轮图标（在Marketplace、Installed的右边），选择HTTP Proxy Settings...，勾选Auto-detect proxy settings以及Automatic proxy configuration URL:，然后点击最下方的Check connection，在弹出框里输入官方插件网站https://plugins.jetbrains.com/idea，点击OK，一般都是可以连接成功的。之后就可以正常的搜索和下载插件了。\n如果上述的代理设置也不能成功，那只能自己去官方的插件市场网站搜索下载插件了：https://plugins.jetbrains.com/idea\n这个版本的IDEA已经自带了Lombok插件。\n破解2021-2版本的IDEA 目前用的是无限重置30天试用的方法：\n去官网下载2021-2版本的IDEA：https://www.jetbrains.com/idea/download/ 如果有安装过旧版本的IDEA，要先卸载掉旧版本的，卸载时记得勾选删除旧版本IDEA的缓存和本地历史 安装新版本的IDEA并运行 初次运行时选择免费试用：Evaluate for free -\u0026gt; Evaluate，然后继续启动 打开IDEA后新建一个Java项目，然后将无限重置30天试用期的补丁ide-eval-resetter-2.1.6.zip拖动到IDEA的界面中。补丁请去这篇文章中的公众号里下载：https://www.exception.site/essay/how-to-free-use-intellij-idea-2019-3 安装补丁后重启IDEA，点击Help菜单，若列表中出现Eval Reset选项，则代表安装成功。每次启动IDEA时会自动重置试用期，也可以手动点击刚刚的选项来重置。 该重置插件的作者会持续更新，可以在插件市场中更新该重置试用期的插件版本。 这里顺便提供个IDEA注册码的网站：http://idea.lanyus.com/\n插件推荐 Codota代码智能提示插件 CodeGlance显示代码缩略图插件 Lombok插件（新版本IDEA自带了） Alibaba Java Coding Guidelines 阿里巴巴代码规范检查插件 MybatisX 高效操作Mybatis插件 Save Actions格式化代码插件 Rainbow Brackets彩虹括号插件 常用的快捷键 shift shift 连按两次shift键可以搜索文件，可以选择搜索范围。\nctrl + h 查找一个类的继承关系树。\nctrl + d 复制光标选中的文本。\nctrl + y 删除光标选中的行。\nctrl + f 在当前文件查找文本。\nctrl + shift + f 所有文件中查找文本，不包括jar包里的文件。\nctrl + r 在当前文件替换文本。\nalt + ← 跳转到文件栏左边的文件。\nalt + → 跳转到文件栏左边的文件。\nalt + shift + ← 跳转到上一步操作。\nalt + shift + → 跳转到下一步操作。\nshift + enter 在光标所在行的下一行创建一行空白行。\nctrl + / 单行注释或多行注释或取消注释。\nctrl + f12 查看当前类的所有方法，可以选择显示父类的方法。\nctrl + space 基础代码补全。\nctrl + g 跳转到第几行代码。\nctrl + alt + L格式化代码。\n启动时选择工作空间 File -\u0026gt; Settings... -\u0026gt; Appearance \u0026amp; Behavior -\u0026gt; System Settings -\u0026gt; 不勾选Reopen projects on startup\n全局配置优化 优化导包 File -\u0026gt; Settings... -\u0026gt; Editor -\u0026gt; General -\u0026gt; Auto import：\n勾选Add unambiguous imports on the fly（自动导包） 勾选Optimize imports on the fly（自动删除无用的包） 取消tab页单行显示 可以多行显示tab页，方便查看文件。\nFile -\u0026gt; Settings... -\u0026gt; Editor -\u0026gt; General -\u0026gt; Editor Tabs -\u0026gt; 取消勾选Show tabs in one row\n代码提示、搜索时取消匹配大小写 在代码提示、搜索时默认匹配大小写，比如输入s是无法提示String的，需要取消匹配大小写：\nFile -\u0026gt; Settings... -\u0026gt; Editor -\u0026gt; General -\u0026gt; Code completion -\u0026gt; 取消勾选Match Case:\n双斜杠注释改成紧跟代码头 File -\u0026gt; Settings... -\u0026gt; Editor -\u0026gt; Code Style -\u0026gt; Java -\u0026gt; Code Generation -\u0026gt; Comment Code：\n取消勾选Line comment at first column Add a space at comment start 改完后使用双斜杠注释时，会跟在代码前面：\n1 2 3 4 5 6 public class Test { public static void main(String[] args) { // System.out.println(\u0026#34;helloworld.\u0026#34;); } } 自定义live template代码模板 在Eclipse中输入syso加上回车键，就会自动输入System.out.println();，这个功能在IDEA中也可以实现：\nFile -\u0026gt; Settings... -\u0026gt; Editor -\u0026gt; Live Templates：\n点击右边的加号+，可以选择新建一个分组或者新的模板，分组可以重命名。模板名字由Abbreviation决定，就是用来输入提示的字母组合。 这里输入syso，然后在Template text:里输入System.out.println($END$); 点击Define，勾选Java，这样在写Java代码时就可以通过输入syso来快速输入设定号的代码模板。 可以按照个人习惯多定义一些模板，如下：\nAbbreviation: apr\nTemplate text:\n1 2 @Autowired private $VAR$ $END$; $END$表示光标的位置。\n优化版本控制的目录颜色展示 代码改变时，目录颜色会跟着变化：\nFile -\u0026gt; Settings... -\u0026gt; Version Control -\u0026gt; 勾选Show directories with changed descendants\n创建文件时，自动生成作者信息和日期等文本模板 File -\u0026gt; Settings... -\u0026gt; Editor -\u0026gt; File and Code Templates -\u0026gt; Includes -\u0026gt; File Header填写文本模板即可。默认提供的File Header模板，是在左边的Files页面里的Class、Interface等通过#parse(\u0026quot;File Header.java\u0026quot;)引入的。\n可以依样画葫芦，自己定义一个模板文件，然后在想要引入的文件里通过#parse来引入。需要注意的是，最好在模板文件的最后一行多加一行空白行，不然在创建新类时，可能会报错而创建失败。下面是一个例子：\n新建了一个模板文件Comment Header：\n1 2 3 4 5 6 7 // Copyright (c) 1998-${YEAR} Core Solutions Limited. All rights reserved. // ============================================================================ // CURRENT VERSION CNT.5.0.1 // ============================================================================ // CHANGE LOG // CNT.5.0.1 : ${YEAR}-XX-XX, ${USER}, creation // ============================================================================ 修改Files页面里的Class为：\n1 2 3 4 5 #parse(\u0026#34;Comment Header.java\u0026#34;) #if (${PACKAGE_NAME} \u0026amp;\u0026amp; ${PACKAGE_NAME} != \u0026#34;\u0026#34;)package ${PACKAGE_NAME};#end #parse(\u0026#34;File Header.java\u0026#34;) public class ${NAME} { } 修改默认的${USER}的值 默认值是操作系统的当前用户名，可以指定为其他名字。\nHelp -\u0026gt; Edit Custom VM Options...，添加一行新的参数：-Duser.name=lewis.liu，这里的名字自行定义。\n还可以在这里修改IDEA的内存参数：\n1 2 -Xms2048m -Xmx2048m 显示行号和方法分割线 File -\u0026gt; Settings... -\u0026gt; Editor -\u0026gt; General -\u0026gt; Appearance：\n勾选Show line numbers 勾选Show method separators 编辑器中光标变为Insert状态 在编辑器中光标变为Insert状态，此时无法进行复制黏贴等操作。这个问题有两种可能性：\n可能跟IDEA本身的配置有关：File -\u0026gt; Settings... -\u0026gt; Editor -\u0026gt; General -\u0026gt; Appearance -\u0026gt; 取消勾选Use block caret 也可能跟IdeaVim插件有关：File -\u0026gt; Settings... -\u0026gt; Plugins -\u0026gt; Installed -\u0026gt; 搜索ideavim，取消勾选该插件 分屏浏览两个文件 在文件栏里右键一个打开的文件标签，选择Move Right可以实现左右分屏浏览，选择Move Down可以实现上下分屏浏览。\n鼠标悬停显示JavaDoc 连续按两下Shift打开搜索框，输入Show quick documentation on mouse move，这时候可以看到一个开关，打开这个开关即可。\nCommand line is too long. 启动项目时报错如下：\n1 2 Error running xxx. Command line is too long. Shorten the command line via JAR manifest or via a classpath file and rerun. 该报错是因为项目启动时需要打印的环境变量太长，超过了限制，需要缩短命令行来启动项目。\n按照报错提示，修改当前项目的配置：\n在启动或者Debug图标左侧打开当前项目的配置页面，在Configuration页签里的Shorten command line:选项里选择JAR manifest或者classpath file，然后保存并重启项目即可。\nimport语句去掉* File -\u0026gt; Settings... -\u0026gt; Editor -\u0026gt; Code Style -\u0026gt; Java -\u0026gt; Scheme:选择Default -\u0026gt; 选择Imports这个tab：\n找到General这一栏，勾选Use single class import 将Class count to use import with '*'改为较大的值，如99 将Names count to use static import with '*'改为较大的值，如99 找到Package to Use import with '*'这一栏，将里面勾选的选项全部取消掉 全局搜索不到真实存在的文件或文本内容 有时候idea无法搜索到一个真实存在的文件或者文本内容，是idea本身的缓存未刷新导致的，解决方法是使旧缓存失效并重启idea，这时候就可以搜索到了：\nFile -\u0026gt; Invalidate Caches / Restart...\n参考链接 IDEA常用快捷键整理 IntelliJ IDEA 2021.2激活破解教程（亲测有用，永久激活，长期更新） intellij idea 启动时怎么选择工作空间 完美解决idea无法搜索下载插件的问题 idea如何修改默认的${user}值 IntelliJ IDEA高效使用教程，让你的工作效率提升10倍！ idea编译器光标变为insert状态 idea 鼠标变量_IntelliJ IDEA鼠标悬停方法显示Java Doc idea2021版本后项目运行报错——Error running xxx : Command line is too long.Shorten command line ..解决方法 idea import 去掉* ","permalink":"https://lewky.cn/posts/idea-issues/","tags":["IDEA"],"title":"IDEA问题汇总"},{"categories":["Blog"],"contents":"前言 博客园支持皮肤的高度定制化，本文主要简单介绍下博客园的SimpleMemory皮肤的定制化。感谢皮肤作者以及定制化皮肤的作者！\n个人使用的是BNDong大大开源的基于SimpleMemory原皮的定制化皮肤，下面是相关的一些链接。\n项目地址：https://github.com/BNDong/Cnblogs-Theme-SimpleMemory 文档地址：https://bndong.github.io/Cnblogs-Theme-SimpleMemory/v2/#/ 原作者：https://www.cnblogs.com/bndong/ 使用指南 官方文档里已经有很详细的教程了，这里只进行简单的记录，方便日后回顾。本文基于v2版本的安装配置教程。\n使用该定制化皮肤，需要JS权限，这个要自行申请。申请也很简单，在博客园的设置中找到申请JS权限按钮，在弹窗里编写申请理由，下面是个简单的模板：\n尊敬的博客园管理员： 您好，我希望用JS美化下我的博客页面，麻烦通过下我的JS权限申请。 感谢您的帮助。\n一般情况下，一小时内就能申请通过。\n然后在设置中的博客皮肤要选择SimpleMemory，接着前往项目的仓库地址下载代码文件（是个ZIP文件），解压之后得到css文件：/dist/simpleMemory.css。将该文件的内容整个复制到博客园设置中的页面定制CSS代码框中，要勾选禁用模板默认CSS。\n有能力的同学可以自己修改定制这里的CSS样式。\n该皮肤使用公告这个控件进行了功能扩展，所以需要在选项中的侧边栏控件的公告勾选上！\n下面则是个人的公告控件代码，用来填写在博客园设置中的博客侧边栏公告框中，以下代码仅供参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; window.cnblogsConfig = { info: { name: \u0026#39;雨临Lewis\u0026#39;, // 用户名 startDate: \u0026#39;2018-04-19\u0026#39;, // 入园时间，年-月-日。入园时间查看方法：鼠标停留园龄时间上，会显示入园时间 avatar: \u0026#39;https://pic.cnblogs.com/avatar/1380444/20180423203245.png\u0026#39;, // 用户头像 blogIcon: \u0026#39;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/favicon.ico\u0026#39; }, banner: { home: { title: [ \u0026#39;赵子龙一身是胆，程序猿遍体皆肝\u0026#39;, \u0026#39;不想当写手的码农不是好咸鱼_(xз」∠)_\u0026#39;, \u0026#39;男人至死都是少年\u0026#39; ], background: [ \u0026#34;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/background/saber1.jpg\u0026#34;, \u0026#34;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/background/saber2.jpg\u0026#34; ], } }, sidebar: { infoBackground: \u0026#39;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/background/wlop.jpg\u0026#39; }, footer: { style: 1, text: { left: \u0026#39;好好学习\u0026#39;, right: \u0026#39;天天摸鱼\u0026#39; } }, links: { footer: [ [\u0026#34;我的个人站点\u0026#34;, \u0026#39;https://lewky.cn/\u0026#39;], [\u0026#34;Java学习笔记\u0026#34;, \u0026#39;https://javanote.doc.lewky.cn/\u0026#39;], [\u0026#34;我的GitHub\u0026#34;, \u0026#39;https://github.com/lewky\u0026#39;], [\u0026#34;我的CSDN\u0026#34;, \u0026#39;https://blog.csdn.net/lewky_liu\u0026#39;] ] }, consoleList: [ [\u0026#34;我的个人站点\u0026#34;, \u0026#39;https://lewky.cn/\u0026#39;], [\u0026#34;Java学习笔记\u0026#34;, \u0026#39;https://javanote.doc.lewky.cn/\u0026#39;], [\u0026#34;我的GitHub\u0026#34;, \u0026#39;https://github.com/lewky\u0026#39;], [\u0026#34;我的博客园\u0026#34;, \u0026#39;https://www.cnblogs.com/yulinlewis/\u0026#39;], [\u0026#34;我的CSDN\u0026#34;, \u0026#39;https://blog.csdn.net/lewky_liu\u0026#39;], [\u0026#39;我的Email\u0026#39;, \u0026#39;1019175915@qq.com\u0026#39;] ] } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/BNDong/Cnblogs-Theme-SimpleMemory@v2.0.5/dist/simpleMemory.js\u0026#34; defer\u0026gt;\u0026lt;/script\u0026gt; 参考链接 SimpleMemory文档 博客园申请JS权限教程 ","permalink":"https://lewky.cn/posts/cnblogs-skin/","tags":["博客园"],"title":"博客园SimpleMemory皮肤定制化"},{"categories":["前端"],"contents":"修改npm全局安装的路径 在cmd输入命令：\n1 2 npm config set prefix \u0026#34;D:\\software\\nodejs\\node_global\u0026#34; npm config set cache \u0026#34;D:\\software\\nodejs\\node_cache\u0026#34; 之后可以执行npm config ls来查看是否设置成功了。\n为了方便全局安装的模块能通过命令行来运行，可以将上述设置的两个路径添加到环境变量PATH中。\n配置淘宝npm镜像 官方的npm下载模块可能较慢，可以配置淘宝的npm镜像，之后就可以通过cnpm install来安装对应的模块：\n1 npm install -g cnpm --registry=https://registry.npm.taobao.org npm常用操作命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 安装模块到当前目录，但不写入package.json npm install xx // 安装全局模块 npm install -g xx // 安装并写入package.json的\u0026#34;dependencies\u0026#34;中 npm install xx --save // 安装并写入package.json的\u0026#34;devDependencies\u0026#34;中 npm install xx --save-dev // 删除模块 npm uninstall xx // 删除全局模块 npm uninstall -g xx JavaScript heap out of memory 用npm启动前端项目时报错如下：\n1 FATAL ERROR: Ineffective mark-compacts near heap limit Allocation failed - JavaScript heap out of memory 这是npm在使用JavaScript时堆内存溢出了，需要增大内存，有两种方式。\n方式一 在Node启动时调整内存大小：\n1 2 3 node --max-old-space-size=1700 test.js // 单位为MB // 或者 node --max-new-space-size=1024 test.js // 单位为KB 方式二 直接配置一个全局的环境变量NODE_OPTIONS，可以在cmd中输入如下命令：\n1 setx NODE_OPTIONS --max_old_space_size=4096 这里的单位为MB，新配置的环境变量要在新打开的cmd窗口中才能生效。\n参考链接 修改npm全局安装模式的路径 致命错误：使用任何“NPM”命令时JavaScript堆将耗尽内存 基于node的前端项目编译时内存溢出问题 如果npm太慢，设置 淘宝npm镜像使用方法 ","permalink":"https://lewky.cn/posts/npm-issues/","tags":["工作记录","npm"],"title":"npm问题汇总"},{"categories":["Maven"],"contents":"设置阿里云国内镜像 从Maven的中央仓库下载jar包速度很慢，可以通过在settings.xml中配置一个国内镜像来提高下载速度，一般用阿里云镜像。注意，如果你同时有多个配置文件，必须要修改当前用户目录下的~/.m2下的settings.xml才有效。\n1 2 3 4 5 6 7 8 \u0026lt;mirrors\u0026gt; \u0026lt;mirror\u0026gt; \u0026lt;id\u0026gt;alimaven\u0026lt;/id\u0026gt; \u0026lt;name\u0026gt;aliyun maven\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.aliyun.com/nexus/content/groups/public/\u0026lt;/url\u0026gt; \u0026lt;mirrorOf\u0026gt;central\u0026lt;/mirrorOf\u0026gt; \u0026lt;/mirror\u0026gt; \u0026lt;/mirrors\u0026gt; 修改配置后，需要重新打开命令行窗口，或者重启IDE才能生效。通常公司会在内网中自己架设一个Nexus私服，项目成员将镜像节点配置为公司的私服，这样无需连接外网也可以下载Jar包，而且速度更快。阿里云镜像实际上就是一个对外公开的Nexus私服仓库。\n指定编译的JDK版本 在settings.xml中配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-1.8\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;jdk\u0026gt;1.8\u0026lt;/jdk\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;1.8\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; 这是一种全局配置，当Maven项目的pom中没有指定编译插件的jdk版本时，会自动使用全局配置的版本。\noffline节点的作用 企业项目通常更新很快，每天都会出一个snapshot包，在当天里第一次启动项目时，如果中央仓库里的snapshot包更新了，则会自动下载到本地。\n如果你此时在本地更改了项目代码并打包过一次，在启动项目时恰巧中央仓库的jar包更新了，就会把本地打包好的jar包给替换掉了。此时必须重新打包一次，才能使用你之前修改的项目代码。为了避免这种情况，可以将settings.xml中的offline设为true。\n1 \u0026lt;offline\u0026gt;true\u0026lt;/offline\u0026gt; 离线模式下的Maven是不会自动帮你从远处库下载项目依赖，该配置只建议在本地使用，因为如果pom中引入了新的依赖，此时Maven无法自动下载该依赖，会导致项目编译报错，如下：\n1 Caused by: org.eclipse.aether.transfer.ArtifactNotFoundException: Cannot access spring-releases (https://repo.spring.io/libs-release) in offline mode and the artifact org.springframework.boot:spring-boot-loader-tools:jar:2.0.5.RELEASE has not been downloaded from it before. 这种时候需要重新将offline节点改为false。\noptional标签 当不需要将某个依赖向外传递时，可以通过将optional标签设置为true来实现，比如当前项目使用的Lombok依赖不需要被其他项目所使用到：\n1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.16\u0026lt;/version\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; 编码GBK的不可映射字符 执行mvn clean package时报错：编码GBK的不可映射字符，该问题是因为字符集编码不同导致的，需要在pom中设置统一的编码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;demo\u0026lt;/finalName\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;source\u0026gt;1.7\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.7\u0026lt;/target\u0026gt; \u0026lt;encoding\u0026gt;utf8\u0026lt;/encoding\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 这里的source和target的1.7指的是编译时使用jdk1.7版本；而encoding指定了utf8编码（我测试了下，发现写utf-8也可以）。\n打war包的方式 首先要了解Maven的流程：\nmvn clean：清除target目录 mvn compile：编译文件 mvn package：打包项目 mvn install：把打包后的项目安装到本地仓库，包含了compile和package mvn deploy：把打包后的项目上传到远程仓库（比如自行搭建的私服），包含了install 关于打war包，有多种方式，如下：\n使用Maven本身的打包方式，把mvn packaging设为war，即可使用package命令打成war包。 使用maven的war命令：mvn war:exploded或者mvn war:war，后一个命令会打包出一个war包以及war包解压后的目录文件，前一个命令只会打包出war包解压后的目录文件。 * 使用tomcat7插件命令打包：mvn tomcat7:exec-war或者mvn tomcat7:exec-war-only，如下： 1 2 3 4 5 6 7 8 9 \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.tomcat.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;tomcat7-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; tomcat7插件支持以下命令：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 查看帮助信息 tomcat7:help // 把WAR部署到Tomcat tomcat7:deploy // 把WAR部署到Tomcat，但是不管理包的生命周期 tomcat7:deploy-only // 重新部署WAR到Tomcat tomcat7:redeploy // 重新部署WAR到Tomcat，但是不管理包的生命周期 tomcat7:redeploy-only // 从Tomcat中卸载WAR tomcat7:undeploy // 使用内嵌的Tomcat服务把当前应用作为动态web应用运行 tomcat7:run // 使用内嵌的Tomcat服务运行当前应用的打包文件war tomcat7:run-war // 使用内嵌的Tomcat服务运行当前应用的打包文件war，但是不管理包的生命周期 tomcat7:run-war-only // 创建一个可执行的jar文件，其中包含了Apache Tomcat，只要执行java -jar xxx.jar即可运行web应用 tomcat7:exec-war // 创建一个可执行的jar文件，但是不管理包的生命周期 tomcat7:exec-war-only // 关闭所有的可执行的服务 tomcat7:shutdown // 创建一个可执行的war文件 tomcat7:standalone-war // 创建一个可执行的war文件 tomcat7:standalone-war-only 最后两个命令在mvn tomcat7:help中的解释是一模一样的，暂时不知道和exec-war有何区别。\nmvn clean package的执行顺序 使用清理插件maven-clean-plugin清理已有的target目录（使用了clean才有这一步） 使用资源插件maven-resources-plugin处理资源文件 使用编译插件maven-compiler-plugin编译所有源文件生成class文件到target/classes目录下 使用资源插件maven-resources-plugin处理测试用的资源文件 使用编译插件maven-compiler-plugin编译测试用的源码正常class文件到target/test-classes目录下 使用测试插件maven-surefire-plugin运行测试用例 使用打包插件maven-jar-plugin对编译后生成的文件进行打包，包名和配置的finalName一致，打包后的文件存放在target目录下 不管是compile、package还是install等，前三个步骤都是必不可少的。\n设置下载源码和文档 方法很多，这里说下3种。\n使用Maven命令 在项目根目录下执行：\n1 2 mvn dependency:sources mvn dependency:resolve -Dclassifier=javadoc 修改配置文件进行全局配置 打开当前用户目录下的全局配置文件/.m2/settings.xml，添加如下配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;profiles\u0026gt; \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;downloadSources\u0026lt;/id\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;downloadSources\u0026gt;true\u0026lt;/downloadSources\u0026gt; \u0026lt;downloadJavadocs\u0026gt;true\u0026lt;/downloadJavadocs\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; \u0026lt;/profiles\u0026gt; \u0026lt;activeProfiles\u0026gt; \u0026lt;activeProfile\u0026gt;downloadSources\u0026lt;/activeProfile\u0026gt; \u0026lt;/activeProfiles\u0026gt; 在IDE工具中配置 可以在IDE工具，诸如Eclipse、idea等中修改Maven插件的一些配置，在Eclipse中配置如下：\nWindow -\u0026gt; Preferences -\u0026gt; Maven -\u0026gt; 勾选Download Artifact Sources和Download Artifact JavaDoc\nMaven聚合工程怎么变回普通的Maven工程 Maven聚合工程的父工程的packaging是pom，如果我们将其改为jar，会立刻报错：\n1 Project build error: \u0026#39;packaging\u0026#39; with value \u0026#39;jar\u0026#39; is invalid. Aggregator projects require \u0026#39;pom\u0026#39; as packaging. 对于聚合工程来说，所有的子工程会被放置到父工程的目录下，然后在父工程的pom文件里会有如下的节点：\n1 2 3 \u0026lt;modules\u0026gt; \u0026lt;module\u0026gt;test-child\u0026lt;/module\u0026gt; \u0026lt;/modules\u0026gt; 这些modules节点正是引用了父工程pom文件的子工程。\n解决方法 将父工程的modules节点全部去掉，注释掉也行，再将packaging的值从pom改成jar或者war，接着保存，修改成功。\n虽然修改成功了，但是去父工程的目录下 ，你会发现那些子工程依然存在着。不过这些工程已经很父工程没有关系了，因为父工程已经不再是聚合工程了，可以将这些子工程移除掉。\njava.lang.StackOverflowError 服务器上的Jenkins在集成项目时报错如下：\n1 2 3 4 error compiling: java.lang.StackOverflowError -\u0026gt; [Help 1] [ERROR] [ERROR] To see the full stack trace of the errors, re-run Maven with the -e switch. [ERROR] Re-run Maven using the -X switch to enable full debug logging. 错误很明显，堆栈溢出，要么是jvm设置的线程栈太小，要么是代码有问题。而服务器每天晚上都会自动集成，jvm参数也不会有人去改过，很明显是最近提交的代码有问题。\n审查了代码，发现是某个测试类中有段代码里调用了一个API，该API又调用了四百多个API。这个API的目的是检测pojo里的字段是否和数据库的字段匹配，一个字段对应一个API，总共有四百多字段。Jenkins在跑单元测试跑到这里就堆栈溢出了。\n毕竟是测试类的代码，改动时逻辑照旧，只不过不继续在一个API去直接调用四百个API，而是将其分成两个新的方法，每个方法各自调用两百个API，然后原本的API调用新增的两个方法。\n之后提交代码，重新让Jenkins集成代码，发现不再报错。\n当然了，也可以直接在启动脚本里简单粗暴调大线程栈大小：\n1 2 3 set MAVEN_OPTS=-Xss4096k 或者 set MAVEN_OPTS=-Xss2m 这里顺便贴一下项目脚本原本设置的参数：\n1 2 3 4 5 echo off setlocal set MAVEN_DEBUG_OPTS=-Duser.timezone=GMT+8 -Xdebug -Xmx4096M -XX:PermSize=128M -XX:MaxPermSize=512M -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8088,server=y,suspend=n mvn spring-boot:run endlocal 无法下载2.1.7.js7版本的itext依赖 编译项目时报错如下：\n1 2 3 Failed to collect dependencies at net.sf.jasperreports:jasperreports:jar:6.10.0 -\u0026gt; com.lowagie:itext:jar:2.1.7.js7: Failed to read artifact descriptor for com.lowagie:itext:jar:2.1.7.js7: Could not transfer artifact com.lowagie:itext:pom:2.1.7.js7 一开始以为是网络不好连接不上远程库，或者远程库没有该jar包，后来发现在Maven中央仓库里也没找到2.1.7.js7版本的itext依赖。在Stack Overflow上查询后发现有不少人遇到同样的问题，都是由于使用了某个版本的jasperreports，最终导致了该错误。\n由于在jasperreports的pom文件里指定了2.1.7.js7版本的itext依赖，而目前的Maven中央仓库或其他镜像仓库里是不存在这种带有js7等后缀版本。该版本是jasperreports为了修复一些bug而打上了补丁的版本，但是并没有release到中央库里，不过这些bug在更高版本里也被修复了，可以使用更高版本的itext来避免这些bug。\n解决方法 排除jasperreports中的itext依赖并自行指定版本，pom如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.sf.jasperreports\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jasperreports\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.10.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;com.lowagie\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;itext\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.lowagie\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;itext\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 这里的itext版本根据自身实际情况指定，目前itext已停止维护，并从4.2.2之后的版本开始从com.lowagie.itext迁移到com.itextpdf.itextpdf，有需要的话可以使用更高版本的itextpdf依赖，pom如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jasperreports\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jasperreports\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;6.10.0\u0026lt;/version\u0026gt; \u0026lt;!--(or higher)--\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;com.lowagie\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;itext\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.itextpdf\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;itextpdf\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.5.13\u0026lt;/version\u0026gt; \u0026lt;!--(or higher)--\u0026gt; \u0026lt;/dependency\u0026gt; java.awt.FontFormatException: bad table, tag= Java加载外部字体时报错FontFormatException，Maven在编译项目时使用-X开启debug模式同样可以看到该异常。原因是使用了resource插件的filtering功能，filtering为true时可以使用系统变量或者启动参数来替换资源文件的占位符${}的值。但也会导致Maven打包时对资源文件重新进行编译，而这些资源文件自身有着特定的编码，被Maven重新编码后文件损坏，于是就会触发该异常。\n处理方式很简单，不再过滤特定的资源文件，如字体、excel等，避免对其重新编码。下面是demo：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-resources-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 过滤后缀不需要转码的文件后缀名.crt/.ttf--\u0026gt; \u0026lt;nonFilteredFileExtensions\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;ttf\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;xlsx\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;xls\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;zip\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;cer\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;pfx\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;nonFilteredFileExtension\u0026gt;py\u0026lt;/nonFilteredFileExtension\u0026gt; \u0026lt;/nonFilteredFileExtensions\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; 这个nonFilteredFileExtensions标签和exclude是不同的，前者依然会打包文件，只是不对其进行重新编译；后者是在打包时直接排除对应的文件。\ninclude是指定打包时需要哪些文件，但include和exclude的配置冲突时，以后者为准。\n引入本地jar包 两种方式，一种是把jar包安装到本地仓库后再引入；一种是直接用systemPath直接引入一个外部的jar包。如果只是本地开发，可以用前一种方式；如果是协同开发，个人更倾向于后一种方式。\n方式一：安装到本地仓库 下面是将jar包安装到本地的命令：\n1 mvn install:install-file -Dfile=D:\\lib\\test.jar -DgroupId=com.test -DartifactId=test -Dversion=0.0.1 -Dpackaging=jar -Dfile指明需要被安装的jar包路径。\n-DgroupId和-DartifactId指定jar包的唯一依赖路径，注意别跟其他的本地依赖路径冲突就行。\n-Dversion指定依赖的版本。\n-Dpackaging指明打包方式。\n安装到本地仓库后可以像普通依赖那样引入：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.test\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 方式二：systemPath直接引入 1 2 3 4 5 6 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.test\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;system\u0026lt;/scope\u0026gt; \u0026lt;systemPath\u0026gt;${basedir}/src/main/resources/lib/test.jar\u0026lt;/systemPath\u0026gt; \u0026lt;/dependency\u0026gt; ${basedir}是Maven的内置属性，代表项目根目录。\n压缩js+css代码 借助yuicompressor插件来完成：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 \u0026lt;!-- Maven全局属性，统一编码 --\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;!-- 构建相关配置 --\u0026gt; \u0026lt;build\u0026gt; \u0026lt;!-- maven插件配置 --\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;!-- YUI Compressor Maven压缩插件 --\u0026gt; \u0026lt;groupId\u0026gt;net.alchim31.maven\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;yuicompressor-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.0\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!-- 读取js,css文件采用UTF-8编码 --\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;!-- 不显示js可能的错误 --\u0026gt; \u0026lt;jswarn\u0026gt;false\u0026lt;/jswarn\u0026gt; \u0026lt;!-- 若存在已压缩的文件，会先对比源文件是否有改动。有改动便压缩，无改动就不压缩 --\u0026gt; \u0026lt;force\u0026gt;false\u0026lt;/force\u0026gt; \u0026lt;!-- 在指定的列号后插入新行 --\u0026gt; \u0026lt;linebreakpos\u0026gt;-1\u0026lt;/linebreakpos\u0026gt; \u0026lt;!-- 压缩之前先执行聚合文件操作 --\u0026gt; \u0026lt;preProcessAggregates\u0026gt;true\u0026lt;/preProcessAggregates\u0026gt; \u0026lt;!-- 压缩后保存文件后缀 --\u0026gt; \u0026lt;suffix\u0026gt;.min\u0026lt;/suffix\u0026gt; \u0026lt;!-- 源目录，即需压缩的根目录 --\u0026gt; \u0026lt;sourceDirectory\u0026gt;${basedir}/mobile\u0026lt;/sourceDirectory\u0026gt; \u0026lt;!-- 压缩js和css文件 --\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.js\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;**/*.css\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;!-- 以下目录和文件不会被压缩 --\u0026gt; \u0026lt;excludes\u0026gt; \u0026lt;exclude\u0026gt;**/*.min.js\u0026lt;/exclude\u0026gt; \u0026lt;exclude\u0026gt;**/*.min.css\u0026lt;/exclude\u0026gt; \u0026lt;exclude\u0026gt;scripts/data/*.js\u0026lt;/exclude\u0026gt; \u0026lt;/excludes\u0026gt; \u0026lt;!-- 压缩后输出文件目录 --\u0026gt; \u0026lt;outputDirectory\u0026gt;${basedir}/mobile\u0026lt;/outputDirectory\u0026gt; \u0026lt;!-- 聚合文件 --\u0026gt; \u0026lt;aggregations\u0026gt; \u0026lt;aggregation\u0026gt; \u0026lt;!-- 合并每一个文件后插入一新行 --\u0026gt; \u0026lt;insertNewLine\u0026gt;true\u0026lt;/insertNewLine\u0026gt; \u0026lt;!-- 需合并文件的根文件夹 --\u0026gt; \u0026lt;inputDir\u0026gt;${basedir}/mobile/scripts\u0026lt;/inputDir\u0026gt; \u0026lt;!-- 最终合并的输出文件 --\u0026gt; \u0026lt;output\u0026gt;${basedir}/mobile/scripts/app/app.js\u0026lt;/output\u0026gt; \u0026lt;!-- 把以下js文件合并成一个js文件，是按顺序合并的 --\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;app/core.js\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;app/mlmanager.js\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;app/tmpl.js\u0026lt;/include\u0026gt; \u0026lt;include\u0026gt;app/ui.js\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;/aggregation\u0026gt; \u0026lt;/aggregations\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 跳过测试案例 有两种方式，一个是启动时添加参数：-DskipTests；一种是添加参数-Dmaven.test.skip=true。\n前者不执行测试用例，但是会编译测试类到target/test-classes目录。\n后者既不执行测试用例，也不编译测试类。\n参考链接 maven(八)，阿里云国内镜像，提高jar包下载速度 Maven命令行使用：mvn clean package（打包） maven 编码GBK的不可映射字符 Maven执行install命令出现Exception in thread \u0026ldquo;main\u0026rdquo; java.lang.StackOverflowError java读取字体文件tff，报错java.awt.FontFormatException: bad table, tag=一串数字 人生苦短，你需要maven，resource、filter、include、exclude简单说明及使用 maven设置下载源码 Dependency error in jasper-reports from itext IText, A Free Java PDF Library 在maven中引入本地jar包的方法 maven实现JS+CSS自动压缩 eclipse maven 打war包的几种方式 Maven之Tomcat Maven中-DskipTests和-Dmaven.test.skip=true的区别 ","permalink":"https://lewky.cn/posts/maven-issues/","tags":["Maven","工作记录"],"title":"Maven问题汇总"},{"categories":["工作记录"],"contents":"前言 SpringFox是一个开源的用于生成API文档接口的框架，支持多种API文档的格式。可以用SpringFox来整合Spring和Swagger，本文使用的Swagger和SpringFox版本如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.springfox\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springfox-swagger-ui\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 隐藏指定的接口 使用@ApiIgnore 在想要隐藏的方法上添加@ApiIgnore注解即可，该注解还可以添加在类上和方法参数上。\n使用SpringFox提供的Docket类的paths()来定制 paths()支持两种表达式，一种是Java的正则表达式，一种是Spring框架的Ant表达式。\n通过Docket类的链式调用来实现：new Docket().select().apis().paths().build()。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @Bean public Docket api() { return new Docket(DocumentationType.SWAGGER_2) .groupName(\u0026#34;api\u0026#34;) .apiInfo(metaData()) .ignoredParameterTypes(Authentication.class) .select() .apis(RequestHandlerSelectors.basePackage(\u0026#34;com.test\u0026#34;)) .paths(PathSelectors.regex(\u0026#34;/api/.*\u0026#34;)) .build() .securitySchemes(Collections.singletonList(securitySchema())) .securityContexts(Collections.singletonList(securityContext())); } private ApiInfo metaData() { return new ApiInfoBuilder() .title(\u0026#34;Test API\u0026#34;) .description(\u0026#34;Test Application\u0026#34;) .version(\u0026#34;0.0.1\u0026#34;) .contact(new Contact(\u0026#34;Lewky\u0026#34;, \u0026#34;lewky.cn\u0026#34;, \u0026#34;lewky@test.com\u0026#34;)) .build(); } private OAuth securitySchema() { final List\u0026lt;AuthorizationScope\u0026gt; authorizationScopeList = new ArrayList\u0026lt;\u0026gt;(); authorizationScopeList.add(new AuthorizationScope(\u0026#34;read\u0026#34;, \u0026#34;read all\u0026#34;)); authorizationScopeList.add(new AuthorizationScope(\u0026#34;trust\u0026#34;, \u0026#34;trust all\u0026#34;)); authorizationScopeList.add(new AuthorizationScope(\u0026#34;write\u0026#34;, \u0026#34;access all\u0026#34;)); final List\u0026lt;GrantType\u0026gt; grantTypes = new ArrayList\u0026lt;\u0026gt;(); final GrantType creGrant = new ResourceOwnerPasswordCredentialsGrant(\u0026#34;/oauth/token\u0026#34;); grantTypes.add(creGrant); return new OAuth(\u0026#34;oauth2schema\u0026#34;, authorizationScopeList, grantTypes); } private SecurityContext securityContext() { return SecurityContext.builder() .securityReferences(defaultAuth()).forPaths(PathSelectors.ant(\u0026#34;/api/**\u0026#34;)) .build(); } 下面是ant表达式的写法，用的是AntPathMatcher来匹配文档路径：\n?匹配一个字符 *匹配0个或多个字符 **匹配0个或多个目录 1 2 3 4 5 6 7 8 9 10 11 12 13 @Bean public Docket oauthApi() { return new Docket(DocumentationType.SWAGGER_2) .groupName(\u0026#34;oauth\u0026#34;) .apiInfo(metaData()) .ignoredParameterTypes(Authentication.class) .select() .apis(RequestHandlerSelectors.any()) .paths(PathSelectors.ant(\u0026#34;/oauth/**\u0026#34;)) .build() .securitySchemes(Collections.singletonList(securitySchema())) .securityContexts(Collections.singletonList(securityContext())); } 定义Response中Model的map字段显示 Swagger2在显示一个接口的Response时，如果Model中存在map类型的字段（比如下面的customFields），则会在Example Value中显示为：\n1 2 3 4 5 \u0026#34;customFields\u0026#34;: { \u0026#34;additionalProp1\u0026#34;: {}, \u0026#34;additionalProp2\u0026#34;: {}, \u0026#34;additionalProp3\u0026#34;: {} } 这个map里的字段是动态生成的，如果想要显示成对应的字段，需要实现ModelPropertyBuilderPlugin接口，然后重写supports()和apply()这两个方法，可以参考框架提供的实现类ApiModelPropertyPropertyBuilder来写。\n对于自定义的类，需要注意的是注入的顺序，需要在框架的默认实现类之后注入。可以使用@Order来控制注入顺序，默认是最低优先级的注入顺序。\n功能需求：map对象的字段是由Hibernate的hbm.xml配置的动态table，需要读取这个xml里的字段，然后将其转为对应的pojo中的字段。\nMap对象的字段重写的具体思路如下：\n在map字段上添加@ApiModelProperty(notes = \u0026quot;xxx\u0026quot;)。使用notes属性的原因是，该字段被Swagger废弃了，这里用来实现自定义的功能就不会与原框架的功能产生冲突。 读取注解中notes的值，解析Hibernate的hbm.xml，根据notes值找到对应的结点并解析。 将解析得到的结点用javassist生成一个类，同一个类生成一次即可，别反复生成，浪费性能。 将生成的类作为当前map字段的解析类型，swagger是用的fasterxml来将pojo转化为json的。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 @Component @Order @Slf4j public class HashMapModelPropertyBuilder implements ModelPropertyBuilderPlugin { @Autowired private TypeResolver typeResolver; @Override public boolean supports(final DocumentationType delimiter) { return true; } @Override public void apply(final ModelPropertyContext context) { Optional\u0026lt;ApiModelProperty\u0026gt; annotation = Optional.absent(); if (context.getAnnotatedElement().isPresent()) { annotation = annotation.or(findApiModePropertyAnnotation(context.getAnnotatedElement().get())); } if (context.getBeanPropertyDefinition().isPresent()) { annotation = annotation.or(findPropertyAnnotation( context.getBeanPropertyDefinition().get(), ApiModelProperty.class)); } // 只有在map类型的字段上使用了ApiModelProperty注解，并使用了notes属性才进行字段的解析 if (annotation.isPresent() \u0026amp;\u0026amp; context.getBeanPropertyDefinition().isPresent()) { final String tableName = annotation.get().notes(); if (StringUtils.isBlank(applyToEntity)) { return; } final BeanPropertyDefinition beanPropertyDefinition = context.getBeanPropertyDefinition().get(); if (!HashMap.class.equals(beanPropertyDefinition.getField().getRawType())) { return; } // 最关键的功能实现：解析xml并生成对应的类，再设置为当前的Map字段的解析类型 context.getBuilder().type(typeResolver.resolve(createRefModel(tableName))); } } // Dynamic generated class package prefix for HashMap model. private final static String BASE_PACKAGE_RPEFIX = \u0026#34;com.test.swagger.model.\u0026#34;; private Class createRefModel(final String name) { final ClassPool pool = ClassPool.getDefault(); final String className = BASE_PACKAGE_RPEFIX + name; CtClass ctClass = pool.getOrNull(className); Class result = null; if (ctClass == null) { // Create new public class. ctClass = pool.makeClass(BASE_PACKAGE_RPEFIX + name); ctClass = loadCustomTableHbmXml(name, ctClass); try { result = ctClass.toClass(); } catch (final CannotCompileException e) { log.error(\u0026#34;Cannot create ref model.\u0026#34;, e); } } else { try { result = Class.forName(className); } catch (final ClassNotFoundException e) { log.error(\u0026#34;Cannot load Class: {}.\u0026#34;, className, e); } } return result; } private CtClass loadCustomTableHbmXml(final String entityName, final CtClass ctClass) { // 解析hbm.xml final Resource resource = new ClassPathResource(\u0026#34;hibernate/CustomTable.hbm.xml\u0026#34;); final SAXReader saxReader = new SAXReader(); Document doc = null; try { doc = saxReader.read(resource.getInputStream()); } catch (final Exception e) { log.error(\u0026#34;Failed to read CustomTable.hbm.xml.\u0026#34;, e); } final Element rootElement = doc.getRootElement(); final Iterator\u0026lt;Element\u0026gt; iterator = rootElement.elementIterator(\u0026#34;class\u0026#34;); Element target = null; while(iterator.hasNext()) { final Element element = iterator.next(); if (StringUtils.equals(entityName, element.attributeValue(\u0026#34;entity-name\u0026#34;, StringUtils.EMPTY))) { target = element; break; } } if (target == null) { return ctClass; } List\u0026lt;Element\u0026gt; elements = new ArrayList\u0026lt;\u0026gt;(); final List\u0026lt;Element\u0026gt; properties = target.elements(\u0026#34;property\u0026#34;); final List\u0026lt;Element\u0026gt; components = target.elements(\u0026#34;component\u0026#34;); elements.addAll(properties); elements.addAll(components); try { for (final Element element : elements) { createField(element, ctClass); } } catch (final Exception e) { log.error(\u0026#34;Cannot create ref model.\u0026#34;, e); } return ctClass; } private CtField createField(final Element element, final CtClass ctClass) throws NotFoundException, CannotCompileException { final String key = element.attributeValue(\u0026#34;name\u0026#34;, StringUtils.EMPTY); // 过滤掉一些不需要的结点 if (IsIgnoreElement(key)) { return null; } // 属于业务逻辑，获取到字段的类型：String、LocalDate等 final CustomFieldType customFieldType = CustomFieldType.findTypeByColumnName(key).orElse(null); if (customFieldType == null) { return null; } CtClass fieldType = null; CtField ctField = null; final ClassPool pool = ClassPool.getDefault(); // 这里可以根据需要将字段名字替换为其他名字 final String jsonKey = key; switch (customFieldType) { case SELECTION: fieldType = pool.get(EmbedCodelistListDemo.class.getName()); break; default: fieldType = pool.get(customFieldType.getType().getName()); break; } ctField = new CtField(fieldType, jsonKey, ctClass); ctField.setModifiers(Modifier.PUBLIC); ctClass.addField(ctField); return ctField; } private boolean IsIgnoreElement(final String key) { boolean result = false; switch (key) { case \u0026#34;domain_id\u0026#34;: case \u0026#34;ref_entity_name\u0026#34;: result = true; break; default: break; } return result; } // Demo model static class EmbedCodelistListDemo extends ArrayList\u0026lt;EmbedCodelist\u0026gt; { private static final long serialVersionUID = 1L; } } 这里唯一需要强调的一点是：如果Map中存在List类型的字段，比如List\u0026lt;xxDto\u0026gt;，若要在Swagger的文档中也将这个xxDto也显示到Example Value里，可以定义一个类，继承List\u0026lt;xxDto\u0026gt;，如上述代码中最后定义的静态内部类EmbedCodelistListDemo。\n之所以这样实现是因为javassist来生成一个泛型List太困难（可能是我没找到正确的接口），还是直接定义这样一个类，让Java自己帮我们搞定类型来得更简单准确。\n按类中字段定义的顺序展示字段 Swagger默认按照首字母顺序来显示接口和字段。\n字段可以通过@ApiModelProperty的position属性来指定顺序，而接口相关的注解@ApiOperation则不行。但不管如何，直接靠人工添加注解来排序是不现实的；可以通过重写插件来便捷地解决这个问题。\n可以通过实现ModelPropertyBuilderPlugin重写字段顺序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 package test; import static springfox.documentation.schema.Annotations.findPropertyAnnotation; import static springfox.documentation.swagger.schema.ApiModelProperties.findApiModePropertyAnnotation; import java.lang.reflect.Field; import org.apache.commons.lang3.ArrayUtils; import org.springframework.core.annotation.Order; import org.springframework.stereotype.Component; import com.fasterxml.jackson.databind.introspect.AnnotatedField; import com.fasterxml.jackson.databind.introspect.BeanPropertyDefinition; import com.google.common.base.Optional; import io.swagger.annotations.ApiModelProperty; import lombok.extern.slf4j.Slf4j; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spi.schema.ModelPropertyBuilderPlugin; import springfox.documentation.spi.schema.contexts.ModelPropertyContext; @Component @Order @Slf4j public class CustomApiModelPropertyPositionBuilder implements ModelPropertyBuilderPlugin { @Override public boolean supports(final DocumentationType delimiter) { return true; } @Override public void apply(final ModelPropertyContext context) { final Optional\u0026lt;BeanPropertyDefinition\u0026gt; beanPropertyDefinitionOpt = context.getBeanPropertyDefinition(); Optional\u0026lt;ApiModelProperty\u0026gt; annotation = Optional.absent(); if (context.getAnnotatedElement().isPresent()) { annotation = annotation.or(findApiModePropertyAnnotation(context.getAnnotatedElement().get())); } if (context.getBeanPropertyDefinition().isPresent()) { annotation = annotation.or(findPropertyAnnotation(context.getBeanPropertyDefinition().get(), ApiModelProperty.class)); } if (beanPropertyDefinitionOpt.isPresent()) { final BeanPropertyDefinition beanPropertyDefinition = beanPropertyDefinitionOpt.get(); if (annotation.isPresent() \u0026amp;\u0026amp; annotation.get().position() != 0) { return; } final AnnotatedField field = beanPropertyDefinition.getField(); final Class\u0026lt;?\u0026gt; clazz = field.getDeclaringClass(); final Field[] declaredFields = clazz.getDeclaredFields(); Field declaredField; try { declaredField = clazz.getDeclaredField(field.getName()); } catch (NoSuchFieldException | SecurityException e) { log.error(\u0026#34;Error.\u0026#34;, e); return; } final int indexOf = ArrayUtils.indexOf(declaredFields, declaredField); if (indexOf != -1) { context.getBuilder().position(indexOf); } } } } 参考链接 重新认识Swagger和Springfox Swagger2 @ApiIgnore注解忽略接口在swagger-ui.html中显示 spring boot集成swagger之springfox-boot-starter配置指定paths()（四） swagger扩展为按代码定义顺序展示接口和字段 ","permalink":"https://lewky.cn/posts/swagger-issues/","tags":["Swagger","SpringFox"],"title":"Swagger问题汇总"},{"categories":["Java"],"contents":"基本概念 树（Tree）不是线性表，而是一种描述非线性层次关系的数据结构，描述的是一对多的数据结构。\n● 结点：Node，有的资料也叫做节点。\n● 根结点（Root）：没有父结点的结点，一棵树只能有一个根结点。\n● 兄弟结点（Siblings）：拥有同一个父结点的结点，它们是父结点的子结点。\n● 孩子、双亲（Child、Parent）：结点的子树的根称为该结点的孩子，相应地，该结点称为孩子的双亲。\n● 结点的度（Degree）：一个结点所包含的子树的数量，即子结点的数量。\n● 树的度：该树所有结点中最大的度。\n● 叶子结点（Leaf）：树中度为零的结点，也叫终端结点。\n● 分支（Branch）：至少有一个孩子的结点，也叫非终端结点。\n● 祖先（Ancestor）：结点的祖先是从根到该结点所经分支上的所有结点。\n● 后代（Descendant）：以某结点为根的子树中的任一结点都称为该结点的后代。\n● 边（Edge）：一个结点和另一个结点之间的连接被称为边。\n● 路径（Path）：连接结点和其后代的结点之间的（结点，边）的序列\n● 层次（Level）：从根结点开始算，根结点是第一层，依次往下。（也可以把根结点作为第0层）\n● 结点的高度（Height of node）：该结点和某个叶子之间存在的最长路径上的边的个数。\n● 树的高度（Height of tree）：树的高度是其根结点的高度。\n● 结点的深度（Depth of node）：从树的根结点到该结点的边的个数。和高度的区别在于，深度是从根结点开始往下到自身结点；高度是从自身结点往下到叶子结点。\n● 树的深度（Depth of tree）：树中结点的最大层次。树的高度等于树的深度。\n● 无序树：树中任意结点的子结点之间没有顺序关系，这种树称为无序树，也称为自由树。\n● 有序树：树中各结点的子结点之间从左到右按一定次序排列的树。\n● 森林：n(n\u0026gt;=0)棵互不相交的树的集合。\n树的存储结构 ● 双亲表示法：在每个结点的结构中，通过一个字段来记录双亲结点在数组中的位置。\n● 孩子表示法：每个结点有多个指针域，其中每个指针都指向一颗子树的根结点。\n● 孩子兄弟表示法：任意一棵树，其结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，通过设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。\n双亲表示法可以和孩子表示法合并组合成双亲孩子表示法。\n孩子兄弟表示法可以把一颗复杂的树变成一颗二叉树。\n树的双亲表示法，孩子表示法以及孩子兄弟表示法 二叉树（Binary Tree） 每个结点最多只能有两个子结点的树，即为二叉树。也就是说，二叉树中不存在度大于2的结点；且二叉树的子树有左右之分，其次序不能颠倒。\n二叉树的性质 ● 若二叉树的层次从1开始，则在二叉树的第i层至多有2^(i-1)个结点(i\u0026gt;=0)\n● 若空树的高度为0，高度为k的二叉树最多有2^k - 1个结点(k\u0026gt;=-1)。\n● 对任何一棵二叉树，如果其叶子结点（度为0）数为m, 度为2的结点数为n, 则m = n + 1\n前两个性质其实就是二进制数的性质。\n斜树 所有结点都只有左子树的二叉树，叫左斜树。相对地，所有结点都只有右子树的二叉树，叫右斜树。斜树相当于树结构退化成了链表。\n完美二叉树（Perfect Binary Tree） 有些资料将完美二叉树翻译为满二叉树，区别于完满二叉树。\n一棵树除了叶子结点外的其他结点的度都为2，且叶子结点都在同一深度，即叶子结点必然都在最后一层。\nA Perfect Binary Tree (PBT) is a tree with all leaf nodes at the same depth. All internal nodes have degree 2.\n完美二叉树拥有最多的结点数量。\n完全二叉树（Complete Binary Tree） 完全二叉树从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，且叶子结点必须全部靠左对齐。\n换言之，完美二叉树是一棵完全二叉树，反之则未必。\nA Complete Binary Tree (CBT) is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.\n完满二叉树（Full Binary Tree） 完满二叉树的所有非叶子结点的度都是2，换言之，如果一个结点有子结点，则必然是两个子结点。\n完美二叉树也叫Strictly Binary Tree。完美二叉树是一棵完满二叉树，反之则未必。\nA Full Binary Tree (FBT) is a tree in which every node other than the leaves has two children.\n二叉树的遍历 先序遍历（前序遍历）：先访问根结点，然后左子树，最后右子树。\n中序遍历：先访问左子树，然后根结点，最后右子树。\n后序遍历：先访问左子树，然后右子树，最后根结点。\n层序遍历：从上到下，从左到右依次遍历每一层中的每一个结点。\n深度优先搜索（DFS） DFS是Depth-First-Search的简称，思路是从根结点开始，沿着一条路径走到底，如果不能到达目标解，则返回上一个结点，然后沿着另一条路径走到底。\nDFS通过栈来实现，一次压栈代表遍历一个结点，沿着路径走到底，通过出栈来返回上一个结点，然后继续将邻接的尚未遍历的结点压栈来继续走到底，一直到找到目标解或者遍历所有结点为止。\nDFS易于用递归实现，时间消耗较小，但容易发生爆栈。虽然可以寻找有解，但无法找到最优解。\n广度优先搜索（BFS） BFS是Breadth-First-Search的简称，思路是从根结点开始，沿着宽度来遍历邻近的结点，即遍历根结点的子结点，如果没有找到目标解，则继续遍历这些结点的尚未遍历的子结点，直到找到目标解或者遍历所有结点为止。\nBFS通过队列来实现，每次遍历结点时将其入队，然后遍历队列头部的结点所有邻接的尚未遍历的结点并入队，然后将头部结点出队。一直循环这个过程，直到找到目标解或遍历完全部结点。\nBFS可以找到最短路径，但如果树的层次较大、结点数较多，BFS会内存消耗十分严重。\n动态查找树 二叉查找树（排序二叉树） 二叉查找树，即Binary Search Tree，也叫二叉搜索树、有序二叉树（ordered binary tree）或排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：\n● 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；\n● 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；\n● 任意结点的左、右子树也分别为二叉查找树；\n● 没有键值相等的结点；\n● 二叉查找树是动态查找表，在查找的过程中可见添加和删除相应的元素，在这些操作中需要保持二叉查找树的以上性质。\n二叉查找树的优势在于查询、插入的时间复杂度较低，为O(logn)。但是当插入的数据为一系列有序的数据时，此时的树为斜树，树结构会退化成链表，此时查询、插入效率大大降低，为O(n)。\n二叉树的旋转 二叉树可以通过旋转来来修改树的深度，以此调节二叉树的平衡度。旋转分为左旋和右旋。\n对某个结点进行左旋，就是把该结点旋转为左结点。右旋与之相对，就是把结点旋转为右结点。旋转之后要依然保持二叉查找树的性质，效果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 z x / \\ / \\ --(对x结点左旋)--\u0026gt; x b y z / \\ / \\ y a a b y x / \\ / \\ --(对x结点右旋)--\u0026gt; a x y z / \\ / \\ b z a b 平衡二叉树（AVL树） 保持二叉查找树的平衡并不容易，为了避免二叉查找树在某些极端情况下退化为链表，就有了平衡二叉树的概念。\n平衡二叉树（Balanced Binary Tree），是自平衡的二叉查找树（Self-balancing binary search tree），其性质如下：\n● 要么是棵空树，要么其根结点左右子树的深度之差的绝对值不超过1；\n● 其左右子树也都是平衡二叉树；\n● 二叉树结点的平衡因子定义为该结点的左子树的深度减去右子树的深度。则平衡二叉树的所有节点的平衡因子只可能是-1,0,1。\n在插入或者删除结点时，为了满足平衡二叉树的性质，就需要进行自平衡操作，即二叉树的旋转。\nAVL树是最早发明的自平衡二叉查找树，是最原始典型的平衡二叉树。AVL指的是发明该树的两个作者名字的简称，通常说的平衡二叉树指的是AVL树。AVL树的每个结点都保存着一个额外的值：结点的平衡因子，即为左子树减去右子树的深度。\n也可以这样理解：如果一个结点A只存在左结点，则结点A的平衡因子为1；若只存在右结点，则结点A的平衡因子为-1；若不存在子结点，或者左右子结点都存在，则平衡因子为0。\nAVL树的旋转 AVL树的旋转类型有4种：LL（left-left）旋转、LR（left-righ）旋转、RR（right-right）旋转和RL（right-left）旋转。\nLL型表示在结点X的左结点的左结点上添加的新的结点A，此时通过对结点X进行单次右旋即可实现平衡。\n1 2 3 4 5 6 7 8 y x / \\ / \\ --(对x结点右旋)--\u0026gt; a x y z / / \\ / \\ （新结点）A b z a b / A（新结点） RR型表示在结点X的右结点的右结点上添加的新的结点A，此时通过对结点X进行单次左旋即可实现平衡。\n1 2 3 4 5 6 7 8 z x / \\ / \\ --(对x结点左旋)--\u0026gt; x b y z / \\ \\ / \\ y a A（新结点） a b \\ A（新结点） LR型双旋转表示在结点X的左结点的右结点上添加的新的结点A，此时通过先对结点y进行左旋（RR型旋转），再对结点x右旋（LL型旋转）即可实现平衡。\n1 2 3 4 5 6 7 8 x b x / \\ / \\ / \\ --(对y结点左旋)--\u0026gt; b z --(对x结点右旋)--\u0026gt; y x y z / \\ / / \\ / \\ y A（新结点） a A z a b / （新结点） \\ a A（新结点） RL型双旋转表示在结点X的右结点的左结点上添加的新的结点A，此时通过先对结点y进行左旋，再对结点b右旋即可实现平衡。也就是说，先对祖父结点左旋（RR型旋转），再对父节点右旋（RR型旋转）。\n1 2 3 4 5 6 7 8 x a x / \\ / \\ / \\ --(对z结点右旋)--\u0026gt; y a --(对x结点左旋)--\u0026gt; x z y z / \\ / \\ \\ / \\ （新结点）A z y A b a b \\ （新结点） / b A（新结点） 平衡二叉查找树（AVL）的构建——左旋右旋 红黑树（Red-Black Tree） 红黑树也是一种自平衡的二叉查找树，在二叉查找树的基础上给每个结点增加了一个颜色属性，结点的颜色只能是红色或黑色。其性质如下：\n1）结点是红色或黑色；\n2）根结点只能是黑色；\n3）红黑树中所有的叶子结点后面再接上左右两个黑色的空结点（NIL结点），此时空结点变成了叶子结点。也就是说，红黑树的叶子结点都是黑色的空结点；\n4）红色结点的父结点和左右孩子结点都是黑色，也就是说，从每个叶子到根的所有路径上不能有两个连续的红色节点；\n5）在任何一棵子树中，从根结点向下走到空结点的路径上所经过的黑结点的数目相同，从而保证是一个平衡二叉树。\n红黑树的自平衡操作有两种：变色和旋转。红黑色的自平衡比较复杂，不同的插入、删除结点场景对应的操作各有不同。\n在插入新结点时，新结点的颜色为红色，这是为了不影响到上述的性质5。接着为了满足性质4就需要进行变色，有时候只靠变色是无法保持平衡的，此时就还需要进行旋转，需要具体情况具体分析。\n平衡二叉树（AVL树）是严格平衡的二叉查找树，平衡因子不大于1，以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN)的查找时间复杂度。而红黑树则不同，它是相对接近平衡的二叉树，只需要确保没有一条路径会比其他路径长出俩倍即可。\n30张图带你彻底理解红黑树 红黑树是一种应用很广的数据结构，Java的TreeSet和TreeMap底层就使用了红黑树。红黑树是一棵完满二叉树。\n哈夫曼树（最优二叉树） 哈夫曼树是Huffman Tree的音译，是一种带权路径长度最短的二叉树，也叫最优二叉树。哈夫曼编码就是对哈夫曼树的一种应用。\n如果一个结点拥有权值，则该结点的带权路径长度WPL为其权值乘以根结点到该结点路径的积。对于哈夫曼树，权值较大的结点离根较近。\n构建方式如下：\n1）将所有左，右子树都为空的作为根结点。\n2）在森林中选出两棵根节点的权值最小的树作为一棵新树的左，右子树，且置新树的附加根节点的权值为其左，右子树上根节点的权值之和。注意，左子树的权值应小于右子树的权值。\n3）从森林中删除这两棵树，同时把新树加入到森林中。\n4）重复2，3步骤，直到森林中只有一棵树为止，此树便是哈夫曼树。\n结构（哈夫曼树） 多路查找树（muitl-way search tree） 对于在内存中查找结构来说，红黑树的效率已经很好了。但内存中的树节点存储的元素数量是有限的，在查找数据量非常大的场景下，不可能将所有数据都存放到内存中，必须在磁盘中建立查询结构，这样查询时还会涉及到磁盘I/O操作。并且对于二叉查找树结构，在数据量很大时会导致树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下。\n也就是说，所有的二叉查找树结构在磁盘中都是低效的，因此就有了多路查找树。\n多路查找树的每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。多路查找树适用于读写相对大的数据块的存储系统，例如磁盘。\nB树（B-tree） B树是平衡多路查找树，英文名是B-tree，有的翻译为B-树，B就是balanced。B树满足以下性质：\n1）根结点至少有两个子女。\n2）每个中间结点都包含k-1个元素和k个孩子，其中 m/2 \u0026lt;= k \u0026lt;= m\n3）每一个叶子结点都包含k-1个元素，其中 m/2 \u0026lt;= k \u0026lt;= m\n4）所有的叶子结点都位于同一层。\n5）每个结点中的元素从小到大排列，结点当中k-1个元素正好是k个孩子包含的元素的值域分划。\n相比于磁盘I/O的速度，内存中的耗时几乎可以省略，所以只要B树的高度足够低，I/O次数足够小，就可以提升查询性能。\nB树的增加删除同样遵循自平衡的性质，有旋转和换位。\nB树的应用是文件系统及部分非关系型数据库索引。\nB+树 B+树的特点是能够保持数据稳定有序，其插入与修改拥有较稳定的对数时间复杂度；所以通常用于关系型数据库（如MySQL）和操作系统的文件系统中。B+ 树元素自底向上插入，这与二叉树恰好相反。\nB+树是B树的一种变体，在B树的基础上，为叶子结点增加链表指针（B树+叶子有序链表），所有关键字都在叶子结点 中出现，非叶子结点作为叶子结点的索引。这意味着B+树的查找效率更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。因此同一颗B+树中，任何关键字的查找比较次数都是一样的。而B树就不一定了，可能查找到某一个非终结点就结束了。\nB+树的非叶子结点不保存数据，只保存子树的临界值（最大或者最小），所以同样大小的结点，B+树相对于B树能够有更多的分支，使得这棵树更加矮胖，查询时做的I/O操作次数也更少。通过最大化在每个内部节点内的子节点的数目减少树的高度，平衡操作不经常发生，而且效率增加了。\nB*树 B*树是B+树的变体，在B+树的基础上，为非根结点和非叶子结点再增加指向兄弟的指针。\nR树 R树是用来做空间数据存储的树状数据结构。例如给地理位置，矩形和多边形这类多维数据建立索引。R指的就是Rectangle矩形。\n参考链接 数据结构复习之树 完美二叉树, 完全二叉树和完满二叉树 基本算法——深度优先搜索（DFS）和广度优先搜索（BFS） 数据结构之树 ","permalink":"https://lewky.cn/posts/java-tree.html/","tags":["Java"],"title":"Java - 数据结构之树"},{"categories":null,"contents":"游戏规则 点击小圆点，围住小猫。 你点击一次，小猫走一次。 直到你把小猫围住（赢），或者小猫走到边界并逃跑（输）。 ","permalink":"https://lewky.cn/funny/catch-the-cat/","tags":null,"title":"逮住那只猫!"},{"categories":["Hexo系列"],"contents":"前言 网上有不少相关的帖子，不过版本会比较旧，而不同版本可能存在代码不同的问题，不过大部分还是大同小异，本系列就不啰嗦重复了，基本只会按照本人所使用的版本以及个人所使用到的内容来进行介绍。\n该系列是对我所使用的Next主题进行个性化定制，涉及到js和css等的修改，还有各种插件的使用，包括使用过程中的一些踩坑记录；另外也会对Next主题进行一些写作技巧的介绍与运用，希望能对大家有所帮助。有疑问的朋友可以给我留言，我会尽可能回复O(∩_∩)O。\n我所使用的Hexo和NexT的版本如下：\n1 2 hexo: 3.7.1 next: 5.1.4 另外本文篇幅太长，阅读体验不好，将其进行分章如下：\nHexo系列(2.0) - NexT主题美化与博客功能增强 · 第一章 Hexo系列(2.1) - NexT主题美化与博客功能增强 · 第二章 添加评论系统 Hexo的NexT主题本身就集成了一些评论系统，多说啊之类的已经关闭服务的略过不提，目前比较多人用的有畅言、来必力livere、Gitment、Gitalk、Disqus等。\n我刚用的评论系统的时候，网易云跟贴和多说已经gg了，畅言需要备案，Disqus需要FQ，Gitment和Gitalk类似，都需要GitHub账号。经过搜集资料和考虑，我最终还是决定使用Gitment。只是在用了一段时间后，终于还是放弃了Gitment，转而使用来必力livere。\nGitment的优缺点 最初我选择使用Gitment的原因如下：\nGitment是一个基于GitHub的issue来开发的评论插件，本身很有创意，对于我这种没事看看GitHub的也很有吸引力。 使用Gitment进行评论需要有GitHub账号，这无形中过滤掉了一些评论者，毕竟不是谁都有GitHub账号的，也不是谁都能登陆上GitHub的。 GitHub的评论数据存放在GitHub的issue里，基本不用担心数据丢失或者GitHub关闭服务，毕竟GitHub可是全球最大同性交友社区(滑稽)。 当我美滋滋地享受了Gitment一段时间后，开始发现一些问题：\nGitHub是个神奇的网站，有时候会登陆不上去，这导致我的个人站点加载页面时无法把Gitment加载出来，这使得我的页面长时间处于一片空白的状态，用户体验极差，而且最后页面加载出来了，Gitment评论模块依然没有加载出来。 我希望我的站点可以不分国界，所以我将站点分别部署到了Coding.net和GitHub上，这样可以国内外都快速访问到站点(这个需要域名才能实现)。由于国内有些地区在有些时段是无法访问到GitHub的，这将导致我的页面长时间假死。 Gitment的使用太繁琐，每一篇文章都必须先初始化一遍，才能使用评论系统，如果你有一百篇文章，你就需要手动初始化一百次！虽然后来有脚本一键初始化，但还是很麻烦。 issue的滥用。因为Gitment是建立的issue之上的，当你的文章越来越多，你会发现你的站点仓库里的issue会越来越多，这就不太友好了。 综上所述，我还是放弃了Gitment，转投了来必力的怀抱。虽然现在没有使用Gitment了，但这里还是记录下使用流程和当初遇到的问题，方便回顾或者大家解决类似的困难。\n安装模块 使用Gitment需要安装模块：\n1 npm i --save gitment 申请应用ID与密钥 因为Gitment需要GitHub的授权，所以需要先去New OAuth App申请一个密钥，需要填写的内容如下：\n1 2 3 4 Application name:随便写 Homepage URL:这个也可以随意写,就写你的博客地址就行 Application description:描述,也可以随意写 Authorization callback URL:这个必须写你的博客地址 这里只有最后一个callback必须写准确，申请成功后你可以看到ClientID和Client Secret，这个会被使用到，另外注意不要把这个ID和密钥告诉别人\u0026ndash;\n在主题配置文件中启用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Gitment # Introduction: https://imsun.net/posts/gitment-introduction/ gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide \u0026#39;Powered by ...\u0026#39; on footer, and more language: # Force language, or auto switch by theme github_user: {you github user id} github_repo: 随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issue client_id: {刚才申请的ClientID} client_secret: {刚才申请的Client Secret} proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 这里的配置，只有github_user，github_repo，client_id，client_secret是必须填准确的，其他的可以不使用。\n初始化Gitment 到这里为止已经全部配置完毕，接下来只需要登陆你的个人站点，然后手动给每篇文章初始化Gitment就行了。初始化也很简单，打开每篇文章，在下方的评论模块那里点一下初始化就行，以后就可以直接评论了。据说由一键初始化所有文章的脚本，我没用过，不清楚。\nGitment踩坑记录 这里说一下当初折腾了我很久的一个地方，在主题配置文件里有个github_user，这个由于注释写的是Your Github ID，我误以为是要填写的不是用户昵称，而是一串数字id。于是就去了GitHub的api里查看了自己的id，然后填了一串数字进去，之后花费了我几个小时的时间，始终有授权失败的错误，最后终于发现，这个ID其实是要填的用户昵称\u0026hellip;orz\nGitHub的api地址：https://api.github.com/users/xxx 把这里的xxx随便改成某个用户名，可以拿到对方的json数据，里边有各种用户首页上的数据信息。\n更多Gitment踩坑相关的文章可以参考：Gitment评论功能接入踩坑教程\n另一个评论系统：来必力livere的使用 来必力的使用就简单多了，直接去官网注册个账号，拿到来必力City版安装代码里的data-uid，把这个uid填写到主题配置文件里的livere_uid后就行，记得id要和前边的冒号之间有一个空格，否则在启用hexo服务的时候会解析出错。\n这样我们的来必力就使用成功了，平时可以去来必力的后台系统查看站点的评论数据等。\n如果不会注册安装来必力的，可以看看这篇文章\n如何令文章目录显示序号 NexT主题会自动为每一篇文章生成目录，这个目录可以通过配置来控制是否生成对应的序号。毕竟有时候我们会给文章的小标题写上序号，有时候又会懒得去写，这个时候这个配置就很重要了。\n有两种方法来实现这个效果，一种是全局生效，一种是对具体某篇文章生效。\n全局生效 在NexT的主题配置文件 _config.yml中启用如下配置：\n1 2 3 4 5 6 7 8 # Table Of Contents in the Sidebar # 侧栏文章目录设置 toc: enable: true # Automatically add list number to toc. # 自动为文章目录添加行号 number: true 设置为true后就可以对站点下所有文章自动添加序号，如果想取消这个功能，再设置为false即可。\n对具体某篇文章生效 如果你在文章的小标题中已经使用了序号，那么自动为文章目录添加序号的功能会导致你的文章目录出现了赘余的序号，解决方法很简单，在你的文章的文件头添加一行代码即可，如下：\n1 2 3 4 5 --- title: XXX date: XXX toc_number: false --- 这样这篇文章就不会被自动添加序号到文章目录里了。\n网页标题崩溃特效 该特效为：当用户离开站点相关的页面时，网页的标题会变成“已崩溃”，网站图标也会改变；当用户重新回到站点页面时才会恢复正常。\n实现方式如下：\n在themes/next/source/js/src/custom.js里加入如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* 离开当前页面时修改网页标题，回到当前页面时恢复原来标题 */ window.onload = function() { var OriginTitile = document.title; var titleTime; document.addEventListener(\u0026#39;visibilitychange\u0026#39;, function() { if(document.hidden) { $(\u0026#39;[rel=\u0026#34;icon\u0026#34;]\u0026#39;).attr(\u0026#39;href\u0026#39;, \u0026#34;/failure.ico\u0026#34;); $(\u0026#39;[rel=\u0026#34;shortcut icon\u0026#34;]\u0026#39;).attr(\u0026#39;href\u0026#39;, \u0026#34;/failure.ico\u0026#34;); document.title = \u0026#39;喔唷，崩溃啦！\u0026#39;; clearTimeout(titleTime); } else { $(\u0026#39;[rel=\u0026#34;icon\u0026#34;]\u0026#39;).attr(\u0026#39;href\u0026#39;, \u0026#34;/favicon-32x32.ico\u0026#34;); $(\u0026#39;[rel=\u0026#34;shortcut icon\u0026#34;]\u0026#39;).attr(\u0026#39;href\u0026#39;, \u0026#34;/favicon-32x32.ico\u0026#34;); document.title = \u0026#39;咦，页面又好了！\u0026#39;; titleTime = setTimeout(function() { document.title = OriginTitile; }, 2000); } }); } 然后在站点根目录的/source目录下添加failure.ico，作为网站崩溃时显示的图标；如下：\nfailure.ico\r这里的favicon-32x32.ico是你个人站点的图标，改成你自己的图标就好。\n对文章进行加密 添加JavaScript代码 打开 themes\\next\\layout\\_partials\\head.swig，在文件的开头位置找到如下代码：\n1 2 3 4 \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;/\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1, maximum-scale=1\u0026#34;/\u0026gt; \u0026lt;meta name=\u0026#34;theme-color\u0026#34; content=\u0026#34;{{ theme.android_chrome_color }}\u0026#34;\u0026gt; 在上边代码的末尾添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;script\u0026gt; (function(){ if(\u0026#39;{{ page.password }}\u0026#39;){ if (prompt(\u0026#39;请输入文章密码\u0026#39;) !== \u0026#39;{{ page.password }}\u0026#39;){ alert(\u0026#39;密码错误！\u0026#39;); if (history.length === 1) { window.opener = null; window.open(\u0026#39;\u0026#39;, \u0026#39;_self\u0026#39;); window.close(); } else { history.back(); } } } })(); \u0026lt;/script\u0026gt; 注意：网上其他的帖子是在这里选择输入密码错误后进行回退历史的操作，代码如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; (function(){ if(\u0026#39;{{ page.password }}\u0026#39;){ if (prompt(\u0026#39;请输入文章密码\u0026#39;) !== \u0026#39;{{ page.password }}\u0026#39;){ alert(\u0026#39;密码错误！\u0026#39;); history.back(); } } })(); \u0026lt;/script\u0026gt; 我经过测试发现，这段代码有问题：如果当前页面是新打开的窗口，其历史页面只有一个，也就是history.length === 1时，就算不输入密码或者输入错误的密码，也会在提示密码错误之后成功进入文章页面！！！\n所以我们使用改良后的JS代码。\n给某篇文章设置密码 添加完脚本代码，接下来在想要加密的文章的文件头加上 password 属性就行了，如下：\n1 2 3 4 5 6 7 8 9 --- title: XXX date: XXX tags: - XXX categories: - XXX password: 123 --- 这样在打开这篇文章时只有输入了123这个密码才可以打开成功。\n启用搜索功能 安装搜索插件 在站点根目录使用 git bash 执行命令：\n1 npm install hexo-generator-searchdb --save 修改配置文件 打开主题配置文件 _config.yml，修改如下配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Local search # Dependencies: https://github.com/flashlab/hexo-generator-search # 本地搜索，需要安装 hexo-generator-search # 站点根目录执行：npm install hexo-generator-searchdb --save local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button # auto表示改变输入就自动触发搜索 # manual表示按下回车键或搜索按钮才触发搜索 trigger: auto # show top n results per article, show all results by setting to -1 # 这里的数字n表示显示每篇文章搜索到的n个结果 # -1表示显示每篇文章搜索到的全部结果(不建议) top_n_per_article: 1 让所有的文章链接在新窗口打开 打开 themes\\next\\layout\\_macro\\post-collapse.swig，修改这里的超链的target：\n1 2 3 4 5 6 7 \u0026lt;a class=\u0026#34;post-title-link\u0026#34; href=\u0026#34;{{ url_for(post.path) }}\u0026#34; itemprop=\u0026#34;url\u0026#34;\u0026gt; {% if post.type === \u0026#39;picture\u0026#39; %} {{ post.content }} {% else %} \u0026lt;span itemprop=\u0026#34;name\u0026#34;\u0026gt;{{ post.title | default(__(\u0026#39;post.untitled\u0026#39;)) }}\u0026lt;/span\u0026gt; {% endif %} \u0026lt;/a\u0026gt; 接着打开 themes\\next\\layout\\_macro\\post.swig，修改这里的超链的target：\n1 2 3 \u0026lt;a class=\u0026#34;post-title-link\u0026#34; href=\u0026#34;{{ url_for(post.path) }}\u0026#34; itemprop=\u0026#34;url\u0026#34;\u0026gt;{# #}{{ post.title | default(__(\u0026#39;post.untitled\u0026#39;))}}{# #}\u0026lt;/a\u0026gt; 在这两个超链里添加 target=\u0026quot;_blank\u0026quot; ，最终修改如下：\ntarget_blank.jpg\r使用FontAwesome 5 NexT主题集成的是4.6.2版本的fontawesome，现在已经出了更高版本的了，修改fontawesome的版本有两种方式。\n方式一：直接修改主题配置文件 打开主题配置文件 _config.yml，修改如下配置：\n1 2 3 # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: 在这里的 fontawesome: 后面直接添加上 fontawesome 的 CDN 就行了；不过不推荐这种改法，因为版本5的 fontawesome 改变了不少，直接在这里添加 fontawesome 5的 CDN 会导致原本的图标全部显示不出来。\n推荐方式二的改法。\n方式二：修改页面头文件的模板 打开 themes\\next\\layout\\_partials\\head.swig，找到如下代码：\n1 2 3 4 {% if theme.vendors.fontawesome %} {% set font_awesome_uri = theme.vendors.fontawesome %} {% endif %} \u0026lt;link href=\u0026#34;{{ font_awesome_uri }}\u0026#34; rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; /\u0026gt; 在上边的代码后插入 fontawesome 5 的 CDN：\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://use.fontawesome.com/releases/v5.0.13/css/all.css\u0026#34; integrity=\u0026#34;sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; 如果这里的CDN链接无效，请去官网复制CDN链接：https://fontawesome.com/get-started\nfontawesome-CDN\r添加文章置顶功能 安装插件及其使用方法 在站点根目录执行命令：\n1 2 npm uninstall hexo-generator-index --save npm install hexo-generator-index-pin-top --save 接下来在需要置顶的文章头部添加 top: true 或者 top: n，这里的n是数字，数字越大表示置顶等级越高。\n1 2 3 4 5 6 7 title: XXX tags: - XXX categories: - XXX date: XXX top: 100 在文章标题下方添加置顶样式 打开 themes/next/layout/_macro/post.swig，在 \u0026lt;div class=\u0026quot;post-meta\u0026quot;\u0026gt; 下方添加如下代码：\n1 2 3 4 5 6 7 {% if post.top %} \u0026lt;span class=\u0026#34;post-meta-item-icon\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-thumb-tack\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;font color=\u0026#34;red\u0026#34;\u0026gt;置顶\u0026lt;/font\u0026gt; \u0026lt;span class=\u0026#34;post-meta-divider\u0026#34;\u0026gt;|\u0026lt;/span\u0026gt; {% endif %} encrypt.jpg\r文章启用字数统计、阅读时长 安装 wordcount 插件 在站点根目录打开 git bash，输入：\n1 npm i --save hexo-wordcount 该插件的具体使用方法可以参考 GitHub 上的仓库：https://github.com/willin/hexo-wordcount\n在主题配置文件启用该插件 NexT主题本身就集成了该插件，在安装了该插件后直接启用就行了。 进入主题配置文件 _config.yml，修改如下配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount # 文章字数展示设置 post_wordcount: # 文本显示 item_text: true # 文章字数统计 wordcount: true # 阅读时长 min2read: true # 站点总字数统计 totalcount: false # 该post_wordcount的所有设置另起一行显示 separated_meta: true 自定义字数计数的显示样式 启用了该插件后的显示样式也是可以自己修改的，进入 themes\\next\\layout\\post.swig，找到如下代码，这里可以修改字数统计的样式：\n1 2 3 4 5 6 7 8 9 10 11 12 {% if not theme.post_wordcount.separated_meta %} \u0026lt;span class=\u0026#34;post-meta-divider\u0026#34;\u0026gt;|\u0026lt;/span\u0026gt; {% endif %} \u0026lt;span class=\u0026#34;post-meta-item-icon\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-file-word-o\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/span\u0026gt; {% if theme.post_wordcount.item_text %} \u0026lt;span class=\u0026#34;post-meta-item-text\u0026#34;\u0026gt;{{ __(\u0026#39;post.wordcount\u0026#39;) }}\u0026amp;#58;\u0026lt;/span\u0026gt; {% endif %} \u0026lt;span title=\u0026#34;{{ __(\u0026#39;post.wordcount\u0026#39;) }}\u0026#34;\u0026gt; {{ wordcount(post.content) }} \u0026lt;/span\u0026gt; 下边是阅读时长的代码：\n1 2 3 4 5 6 7 8 9 10 11 {% if theme.post_wordcount.min2read %} \u0026lt;span class=\u0026#34;post-meta-item-icon\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fa fa-clock-o\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026lt;/span\u0026gt; {% if theme.post_wordcount.item_text %} \u0026lt;span class=\u0026#34;post-meta-item-text\u0026#34;\u0026gt;{{ __(\u0026#39;post.min2read\u0026#39;) }} \u0026amp;asymp;\u0026lt;/span\u0026gt; {% endif %} \u0026lt;span title=\u0026#34;{{ __(\u0026#39;post.min2read\u0026#39;) }}\u0026#34;\u0026gt; {{ min2read(post.content) }} \u0026lt;/span\u0026gt; {% endif %} 改完样式后，再去 themes\\next\\languages 目录下找到你所使用的语言对应的 yml 文件，修改要显示的文本。比如我使用的语言是 zh-Hans，就修改 zh-Hans.yml里的文本：\n1 2 3 4 post: wordcount: 本文共计 min2read: 阅文耗时 totalcount: Site words total count 修改行内代码块的样式 打开 themes\\next\\source\\css\\_custom\\custom.styl，添加如下样式：\n1 2 3 4 5 6 7 /* 行内代码块的自定义样式 */ code { color: #d500fc; background: rgba(78, 240, 233, 0.42); margin: 2px; border: 1px solid #d6d6d6; } 效果图\ncode-block.jpg\r修改文章内的超链样式 打开 themes\\next\\source\\css\\_custom\\custom.styl，添加如下样式：\n1 2 3 4 5 6 7 8 9 10 11 12 /* 文章内链接文本样式 */ .post-body p a, .post-body li a { color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; \u0026amp;:hover { color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; } } 这里选择 .post-body p a 是为了不影响文章标题和首页 阅读全文》 的样式，选择 .post-body li a 是为了对列表内的超链也有效果。\n总之，我们可以随意定义这里的具体样式。\na:link 效果图\nlink.jpg\ra:hover 效果图\nhover.jpg\r修改永久链接的默认格式 Hexo的永久链接的默认格式是 :year/:month/:day/:title/，比如访问站点下某一篇文章时，其路径是 2018/04/12/xxxx/，如果我们的文章标题是中文的，那么该路径就会出现中文字符。在路径中出现了中文字符很容易引发各种问题，而且也不利于seo，因为路径包含了年月日三个层级，层级太深不利于百度蜘蛛抓取。\n解决办法就是利用其它的插件来生成唯一的路径，这样就算我们的文件标题随意修改，而不会导致原本的链接失效而造成站点下存在大量的死链。\n安装插件 在站点根目录使用 git bash 执行命令：\n1 npm install hexo-abbrlink --save 修改站点配置文件 打开根目录下的 _config.yml 文件，修改如下配置：\n1 2 3 4 5 6 # permalink: :year/:month/:day/:title/ # permalink_defaults: permalink: posts/:abbrlink.html abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 这里将页面都添加了 .html 的后缀，用来伪装成静态页面(虽说Hexo的页面本身就是静态页面)，这样可以直接从路径就知道这是个静态页面，方便seo。\n接下来重新部署三连，可以看到我们的文章路径变成了 /posts/xxxxx.html，接下来就算我们将文字标题命名为中文也没问题了。\n参考链接 Hexo 使用Gitment评论功能 Gitalk：一个基于 Github Issue 和 Preact 开发的评论插件 添加网易云跟帖(跟帖关闭，已失效，改为来必力) ","permalink":"https://lewky.cn/posts/hexo-2.1.html/","tags":["Hexo","NexT主题","主题美化","功能增强"],"title":"Hexo系列(2.1) - NexT主题美化与博客功能增强 · 第二章"},{"categories":["Hugo系列"],"contents":"前言 本博客使用的是Hugo的LoveIt主题，本文也是基于该主题而写的，不过Hugo的美化步骤应该大同小异，版本如下：\n1 2 3 hugo: v0.74.2/extended windows/amd64 BuildDate: unknown LoveIt: v0.2.10 请注意，本文的所有功能都离不开两个新增加的文件：_custom.scss和custom.js，部分功能还需要jquery，在第一章中会提及如何引入。\n另外本文篇幅太长，阅读体验不好，将其进行分章如下：\nHugo系列(3.0) - LoveIt主题美化与博客功能增强 · 第一章 Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章 Hugo系列(3.2) - LoveIt主题美化与博客功能增强 · 第三章 Hugo系列(3.3) - LoveIt主题美化与博客功能增强 · 第四章 添加归档、分类页面里的文章数量统计 在list.html里添加sup标签 文章数量统计实际上就是添加html里的sup标签，借助hugo提供的变量来获取对应的文章数量，即可实现该功能。\n拷贝\\themes\\LoveIt\\layouts\\taxonomy\\list.html到\\layouts\\taxonomy\\list.html，打开拷贝后的文件，找到如下内容：\n1 2 3 4 5 {{- if eq $taxonomy \u0026#34;category\u0026#34; -}} \u0026lt;i class=\u0026#34;far fa-folder-open fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;{{ .Title }} {{- else if eq $taxonomy \u0026#34;tag\u0026#34; -}} \u0026lt;i class=\u0026#34;fas fa-tag fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;{{ .Title }} {{- else -}} 改成如下：\n1 2 3 4 5 {{- if eq $taxonomy \u0026#34;category\u0026#34; -}} \u0026lt;i class=\u0026#34;far fa-folder-open fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;{{ .Title }}\u0026lt;sup\u0026gt;{{ len .Pages }}\u0026lt;/sup\u0026gt; {{- else if eq $taxonomy \u0026#34;tag\u0026#34; -}} \u0026lt;i class=\u0026#34;fas fa-tag fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;{{ .Title }}\u0026lt;sup\u0026gt;{{ len .Pages }}\u0026lt;/sup\u0026gt; {{- else -}} 继续找到如下内容：\n1 2 {{- range $pages.PageGroups -}} \u0026lt;h3 class=\u0026#34;group-title\u0026#34;\u0026gt;{{ .Key }}\u0026lt;/h3\u0026gt; 改成如下：\n1 2 {{- range $pages.PageGroups -}} \u0026lt;h3 class=\u0026#34;group-title\u0026#34;\u0026gt;{{ .Key }} \u0026lt;sup\u0026gt;{{ len .Pages }}\u0026lt;/sup\u0026gt;\u0026lt;/h3\u0026gt; 原本主题的文章是按照年份来分组的，如果想按照月份来分组，找到下面的内容：\n1 2 3 {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \u0026#34;2006\u0026#34; -}} 改成如下：\n1 2 3 {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \u0026#34;2006-01\u0026#34; -}} 在terms.html里添加sup标签 拷贝\\themes\\LoveIt\\layouts\\taxonomy\\terms.html到\\layouts\\taxonomy\\terms.html，打开拷贝后的文件，找到如下内容：\n1 2 3 4 5 \u0026lt;div class=\u0026#34;page archive\u0026#34;\u0026gt; {{- /* Title */ -}} \u0026lt;h2 class=\u0026#34;single-title animated pulse faster\u0026#34;\u0026gt; {{- .Params.Title | default (T $taxonomies) | default $taxonomies | dict \u0026#34;Some\u0026#34; | T \u0026#34;allSome\u0026#34; -}} \u0026lt;/h2\u0026gt; 改成如下：\n1 2 3 4 5 \u0026lt;div class=\u0026#34;page archive\u0026#34;\u0026gt; {{- /* Title */ -}} \u0026lt;h2 class=\u0026#34;single-title animated pulse faster\u0026#34;\u0026gt; {{- .Params.Title | default (T $taxonomies) | default $taxonomies | dict \u0026#34;Some\u0026#34; | T \u0026#34;allSome\u0026#34; -}}\u0026lt;sup\u0026gt;{{ len .Pages }}\u0026lt;/sup\u0026gt; \u0026lt;/h2\u0026gt; 找到如下内容：\n1 2 3 4 5 \u0026lt;h3 class=\u0026#34;card-item-title\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;far fa-folder fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;{{ .Page.Title }} \u0026lt;/a\u0026gt; \u0026lt;/h3\u0026gt; 改成如下：\n1 2 3 4 5 \u0026lt;h3 class=\u0026#34;card-item-title\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;far fa-folder fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;{{ .Page.Title }} \u0026lt;sup\u0026gt;{{ len .Pages }}\u0026lt;/sup\u0026gt; \u0026lt;/a\u0026gt; \u0026lt;/h3\u0026gt; 在section.html里添加sup标签 拷贝\\themes\\LoveIt\\layouts\\_default\\section.html到\\layouts\\_default\\section.html，打开拷贝后的文件，找到如下内容：\n1 2 3 4 5 \u0026lt;div class=\u0026#34;page archive\u0026#34;\u0026gt; {{- /* Title */ -}} \u0026lt;h2 class=\u0026#34;single-title animated pulse faster\u0026#34;\u0026gt; {{- .Params.Title | default (T .Section) | default .Section | dict \u0026#34;Some\u0026#34; | T \u0026#34;allSome\u0026#34; -}} \u0026lt;/h2\u0026gt; 改成如下：\n1 2 3 4 5 \u0026lt;div class=\u0026#34;page archive\u0026#34;\u0026gt; {{- /* Title */ -}} \u0026lt;h2 class=\u0026#34;single-title animated pulse faster\u0026#34;\u0026gt; {{- .Params.Title | default (T .Section) | default .Section | dict \u0026#34;Some\u0026#34; | T \u0026#34;allSome\u0026#34; -}}\u0026lt;sup\u0026gt;{{ len .Pages }}\u0026lt;/sup\u0026gt; \u0026lt;/h2\u0026gt; 找到如下内容：\n1 2 {{- range $pages.PageGroups -}} \u0026lt;h3 class=\u0026#34;group-title\u0026#34;\u0026gt;{{ .Key }}\u0026lt;/h3\u0026gt; 改成如下：\n1 2 {{- range $pages.PageGroups -}} \u0026lt;h3 class=\u0026#34;group-title\u0026#34;\u0026gt;{{ .Key }} \u0026lt;sup\u0026gt;{{ len .Pages }}\u0026lt;/sup\u0026gt;\u0026lt;/h3\u0026gt; 这里同样是按照年份来分组的，如果想按照月份来分组，找到下面的内容：\n1 2 3 {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \u0026#34;2006\u0026#34; -}} 改成如下：\n1 2 3 {{- /* Paginate */ -}} {{- if .Pages -}} {{- $pages := .Pages.GroupByDate \u0026#34;2006-01\u0026#34; -}} 修改侧边栏目录样式 默认侧边栏的目录是全展开的，如果文章太长，小标题太多，就会导致目录非常长，看起来不方便。可以改成只展开当前正在查看的小标题对应的目录，在_custom.scss里添加如下样式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* 目录 */ nav#TableOfContents ol { padding-inline-start: 30px; \u0026amp; ol { padding-inline-start: 25px; display: none; } \u0026amp; li.has-active ol { display: block; } } 添加文章过期提醒 配置文件添加相关变量 在config.toml添加如下变量：\n1 2 3 4 5 6 # Display a message at the beginning of an article to warn the readers that it\u0026#39;s content may be outdated. # 在文章末尾显示提示信息，提醒读者文章内容可能过时。 [params.outdatedInfoWarning] enable = true hint = 90 # Display hint if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示提醒 warn = 180 # Display warning if the last modified time is more than these days ago. # 如果文章最后更新于这天数之前，显示警告 这里是对全局文章生效，也可以在每篇文章的文件头里添加如下变量来控制是否启用该功能：\n1 outdatedInfoWarning: false 添加变量到国际化文件 将\\themes\\LoveIt\\i18n\\zh-CN.toml拷贝到\\i18n\\zh-CN.toml，然后将该文件重命名为zh-cn.toml。因为站点配置文件里的中文语言代码应该是全小写的zh-cn，如下：\n1 defaultContentLanguage = \u0026#34;zh-cn\u0026#34; 打开拷贝后的文件，添加如下内容：\n1 2 3 4 5 [outdatedInfoWarningBefore] other = \u0026#34;本文最后更新于 \u0026#34; [outdatedInfoWarningAfter] other = \u0026#34;，文中内容可能已过时，请谨慎使用。\u0026#34; 如果你的国际化文件是用的yaml格式，则如下：\n1 2 3 4 5 outdatedInfoWarningBefore: other: \u0026#34;本文最后更新于 \u0026#34; outdatedInfoWarningAfter: other: \u0026#34;，文中内容可能已过时，请谨慎使用。\u0026#34; 如果有配置了其他语言，可以添加上面两个变量到对应的国际化文件里，自行修改other所对应的值即可。\n添加模板文件outdated-info-warning.html 新建模板文件/layouts/partials/single/outdated-info-warning.html，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 {{- if or .Params.outdatedInfoWarning (and .Site.Params.outdatedInfoWarning.enable (ne .Params.outdatedInfoWarning false)) }} {{- $daysAgo := div (sub now.Unix .Lastmod.Unix) 86400 }} {{- $hintThreshold := .Site.Params.outdatedInfoWarning.hint | default 30 }} {{- $warnThreshold := .Site.Params.outdatedInfoWarning.warn | default 180 }} {{- $updateTime := .Lastmod }} {{- if .GitInfo }} {{- if lt .GitInfo.AuthorDate.Unix .Lastmod.Unix }} {{- $updateTime := .GitInfo.AuthorDate }} {{- end }} {{- end -}} {{- if gt $daysAgo $hintThreshold }} {{- $iconDetails := \u0026#34;fas fa-angle-right fa-fw\u0026#34; -}} {{- if gt $daysAgo $warnThreshold }} {{- $type := \u0026#34;warning\u0026#34; -}} {{- $icon := \u0026#34;fas fa-exclamation-triangle fa-fw\u0026#34; -}} \u0026lt;div class=\u0026#34;details admonition {{ $type }} open\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;details-summary admonition-title\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;icon {{ $icon }}{{ $type }}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;{{ T $type }}\u0026lt;i class=\u0026#34;details-icon {{ $iconDetails }}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; {{- else }} {{- $type := \u0026#34;note\u0026#34; -}} {{- $icon := \u0026#34;fas fa-pencil-alt fa-fw\u0026#34; -}} \u0026lt;div class=\u0026#34;details admonition {{ $type }} open\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;details-summary admonition-title\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;icon {{ $icon }}{{ $type }}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;{{ T $type }}\u0026lt;i class=\u0026#34;details-icon {{ $iconDetails }}\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; {{- end }} \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;details-content\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;admonition-content\u0026#34;\u0026gt; {{ T \u0026#34;outdatedInfoWarningBefore\u0026#34; -}} \u0026lt;span class=\u0026#34;timeago\u0026#34; datetime=\u0026#34;{{ dateFormat \u0026#34;2006-01-02T15:04:05\u0026#34; $updateTime }}\u0026#34; title=\u0026#34;{{ dateFormat \u0026#34;January 2, 2006\u0026#34; $updateTime }}\u0026#34;\u0026gt; {{- dateFormat \u0026#34;January 2, 2006\u0026#34; $updateTime -}} \u0026lt;/span\u0026gt;{{ T \u0026#34;outdatedInfoWarningAfter\u0026#34; -}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} {{- end -}} 修改模板文件single.html 将/themes/LoveIt/layouts/posts/single.html拷贝到/layouts/posts/single.html，打开拷贝后的文件，找到如下内容：\n1 2 3 4 {{- /* Content */ -}} \u0026lt;div class=\u0026#34;content\u0026#34; id=\u0026#34;content\u0026#34;\u0026gt; {{- dict \u0026#34;Content\u0026#34; .Content \u0026#34;Ruby\u0026#34; $params.ruby \u0026#34;Fraction\u0026#34; $params.fraction \u0026#34;Fontawesome\u0026#34; $params.fontawesome | partial \u0026#34;function/content.html\u0026#34; | safeHTML -}} \u0026lt;/div\u0026gt; 修改成如下：\n1 2 3 4 5 6 \u0026lt;div class=\u0026#34;content\u0026#34; id=\u0026#34;content\u0026#34;\u0026gt; {{- dict \u0026#34;Content\u0026#34; .Content \u0026#34;Ruby\u0026#34; $params.ruby \u0026#34;Fraction\u0026#34; $params.fraction \u0026#34;Fontawesome\u0026#34; $params.fontawesome | partial \u0026#34;function/content.html\u0026#34; | safeHTML -}} {{- /* Outdated Info Warning */ -}} {{- partial \u0026#34;single/outdated-info-warning.html\u0026#34; . -}} \u0026lt;/div\u0026gt; 菜单栏支持子菜单 修改模板代码 将主题的/themes/LoveIt/layouts/partials/header.html拷贝一份到layouts/partials/header.html，找到如下代码，一共有两个地方，分别对应网页端和手机端：\n1 2 3 4 5 6 7 8 9 {{- range .Site.Menus.main -}} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u0026lt;a class=\u0026#34;menu-item{{ if $.IsMenuCurrent `main` . | or ($.HasMenuCurrent `main` .) | or (eq $.RelPermalink $url) }} active{{ end }}\u0026#34; href=\u0026#34;{{ $url }}\u0026#34;{{ with .Title }} title=\u0026#34;{{ . }}\u0026#34;{{ end }}{{ if (urls.Parse $url).Host }} rel=\u0026#34;noopener noreffer\u0026#34; target=\u0026#34;_blank\u0026#34;{{ end }}\u0026gt; {{- .Pre | safeHTML }} {{ .Name }} {{ .Post | safeHTML -}} \u0026lt;/a\u0026gt; {{- end -}} 将上述代码改为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 {{- range .Site.Menus.main -}} {{ if .HasChildren }} \u0026lt;div class=\u0026#34;dropdown\u0026#34;\u0026gt; \u0026lt;a {{ if .URL }}href=\u0026#34;{{ .URL }}\u0026#34;{{ else }}href=\u0026#34;javascript:void(0);\u0026#34;{{ end }} class=\u0026#34;menu-item menu-more dropbtn\u0026#34; title=\u0026#34;{{ .Title }}\u0026#34; {{ if eq .Post \u0026#34;_blank\u0026#34; }}target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;{{ end }}\u0026gt; {{- .Pre | safeHTML }} {{ .Name }} {{ if ne .Post \u0026#34;_blank\u0026#34; }}{{ .Post | safeHTML -}}{{ end }} \u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;menu-more-content dropdown-content\u0026#34;\u0026gt; {{- range .Children -}} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u0026lt;a href=\u0026#34;{{ $url }}\u0026#34; title=\u0026#34;{{ .Title }}\u0026#34; {{ if eq .Post \u0026#34;_blank\u0026#34; }}target=\u0026#34;_blank\u0026#34; rel=\u0026#34;noopener\u0026#34;{{ end }}\u0026gt;{{- .Pre | safeHTML }} {{ .Name }} {{ if ne .Post \u0026#34;_blank\u0026#34; }}{{ .Post | safeHTML -}}{{ end }}\u0026lt;/a\u0026gt; {{- end -}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ else }} {{- $url := .URL | relLangURL -}} {{- with .Page -}} {{- $url = .RelPermalink -}} {{- end -}} \u0026lt;a class=\u0026#34;menu-item{{ if $.IsMenuCurrent `main` . | or ($.HasMenuCurrent `main` .) | or (eq $.RelPermalink $url) }} active{{ end }}\u0026#34; href=\u0026#34;{{ $url }}\u0026#34;{{ with .Title }} title=\u0026#34;{{ . }}\u0026#34;{{ end }}{{ if (urls.Parse $url).Host }} rel=\u0026#34;noopener noreffer\u0026#34; target=\u0026#34;_blank\u0026#34;{{ end }}\u0026gt; {{- .Pre | safeHTML }} {{ .Name }} {{ if ne .Post \u0026#34;_blank\u0026#34; }}{{ .Post | safeHTML -}}{{ end }} \u0026lt;/a\u0026gt; {{- end -}} {{- end -}} 添加css样式 在_custom.scss中添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /* 子菜单栏 */ .dropdown { display: inline-block; } /* 子菜单的内容 (默认隐藏) */ .dropdown-content { display: none; position: absolute; background-color: #f9f9f9; box-shadow: 0px 8px 16px 0px rgba(0, 0, 0, 0.2); border-radius: 4px; line-height: 1.3rem; } /* 子菜单的链接 */ .dropdown-content a { padding: 10px 18px 10px 14px; text-decoration: none; display: block; \u0026amp; i { margin-right: 3px; } } /* 鼠标移上去后修改子菜单链接颜色 */ .dropdown-content a:hover { background-color: #f1f1f1; border-radius: 4px; } /* 在鼠标移上去后显示子菜单 */ .dropdown:hover .dropdown-content { display: block; } @media screen and (max-width: 680px) { .dropdown { display: inline; } .dropdown:hover .dropdown-content { display: inline; z-index: 1; margin-top: -2em; margin-left: 3em; } .dropdown-content a:hover { background-color: transparent; } } 配置子菜单 打开站点配置文件config.toml，添加子菜单到菜单栏里。子菜单其实和原本的菜单一样写法，只是多了一个parent属性，用来定位到对应的父菜单的identifier。下面是一个简单的子菜单定义方式（没有使用多语言功能）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 # 菜单配置 [menu] [[menu.main]] identifier = \u0026#34;posts\u0026#34; # 你可以在名称 (允许 HTML 格式) 之前添加其他信息, 例如图标 pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-fw fa-archive\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; # 你可以在名称 (允许 HTML 格式) 之后添加其他信息, 例如图标 post = \u0026#34;\u0026#34; name = \u0026#34;归档\u0026#34; url = \u0026#34;/posts/\u0026#34; title = \u0026#34;\u0026#34; weight = 1 [[menu.main]] pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-fw fa-link\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; name = \u0026#34;友链\u0026#34; identifier = \u0026#34;friends\u0026#34; url = \u0026#34;/friends/\u0026#34; weight = 2 # 二级菜单 [[menu.main]] parent = \u0026#34;posts\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-fw fa-th\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; name = \u0026#34;分类\u0026#34; identifier = \u0026#34;categories\u0026#34; url = \u0026#34;/categories/\u0026#34; weight = 1 [[menu.main]] parent = \u0026#34;posts\u0026#34; identifier = \u0026#34;tags\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-fw fa-tag\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; post = \u0026#34;_blank\u0026#34; name = \u0026#34;标签\u0026#34; url = \u0026#34;/tags/\u0026#34; title = \u0026#34;\u0026#34; weight = 2 菜单栏还允许以下配置：\n通过给菜单配置一个post = \u0026quot;_blank\u0026quot;属性来将该菜单设置为在新窗口打开该链接，如果post属性填其他值则依然作为原本的功能使用：即给name添加后缀。 通过设置title来添加超链的提示文本。 父菜单可以通过将url设置为空来将其渲染为不跳转的超链：url = \u0026quot;\u0026quot;。 添加文章打赏 配置文件添加相关变量 在config.toml添加如下变量：\n1 2 3 4 [params.reward] # 文章打赏 enable = true wechat = \u0026#34;/images/wechat.png\u0026#34; # 微信二维码 alipay = \u0026#34;/images/alipay.png\u0026#34; # 支付宝二维码 这里是对全局文章生效，也可以在每篇文章的文件头里添加如下变量来控制是否启用该功能：\n1 reward: false 至于微信和支付宝的收款码，如果不想用官方提供的样式，可以参考这篇文章：微信支付宝收款码制作和美化如何做？\n添加变量到国际化文件 将\\themes\\LoveIt\\i18n\\zh-CN.toml拷贝到\\i18n\\zh-CN.toml，然后将该文件重命名为zh-cn.toml。因为站点配置文件里的中文语言代码应该是全小写的zh-cn，如下：\n1 defaultContentLanguage = \u0026#34;zh-cn\u0026#34; 打开拷贝后的文件，添加如下内容：\n1 2 3 4 5 6 7 8 [reward] other = \u0026#34;赞赏支持\u0026#34; [rewardAlipay] other = \u0026#34;支付宝打赏\u0026#34; [rewardWechat] other = \u0026#34;微信打赏\u0026#34; 如果你的国际化文件是用的yaml格式，则如下：\n1 2 3 4 5 6 7 8 reward: other: \u0026#34;赞赏支持\u0026#34; rewardAlipay: other: \u0026#34;支付宝打赏\u0026#34; rewardWechat: other: \u0026#34;微信打赏\u0026#34; 如果有配置了其他语言，可以添加上面两个变量到对应的国际化文件里，自行修改other所对应的值即可。\n添加模板文件reward.html 新建模板文件/layouts/partials/single/reward.html，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 {{ if or .Params.reward (and .Site.Params.reward.enable (ne .Params.reward false)) -}} \u0026lt;div class=\u0026#34;post-reward\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; name=\u0026#34;reward\u0026#34; id=\u0026#34;reward\u0026#34; hidden /\u0026gt; \u0026lt;label class=\u0026#34;reward-button\u0026#34; for=\u0026#34;reward\u0026#34;\u0026gt;{{ T \u0026#34;reward\u0026#34; }}\u0026lt;/label\u0026gt; \u0026lt;div class=\u0026#34;qr-code\u0026#34;\u0026gt; {{ $qrCode := .Site.Params.reward }} {{- $cdnPrefix := .Site.Params.cdnPrefix -}} {{ with $qrCode.wechat -}} \u0026lt;label class=\u0026#34;qr-code-image\u0026#34; for=\u0026#34;reward\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;image\u0026#34; src=\u0026#34;{{ $cdnPrefix }}{{ . }}\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{ T \u0026#34;rewardWechat\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; {{- end }} {{ with $qrCode.alipay -}} \u0026lt;label class=\u0026#34;qr-code-image\u0026#34; for=\u0026#34;reward\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;image\u0026#34; src=\u0026#34;{{ $cdnPrefix }}{{ . }}\u0026#34;\u0026gt; \u0026lt;span\u0026gt;{{ T \u0026#34;rewardAlipay\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/label\u0026gt; {{- end }} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{- end }} 修改模板文件single.html 将/themes/LoveIt/layouts/posts/single.html拷贝到/layouts/posts/single.html，打开拷贝后的文件，找到如下内容：\n1 2 3 4 {{- /* Content */ -}} \u0026lt;div class=\u0026#34;content\u0026#34; id=\u0026#34;content\u0026#34;\u0026gt; {{- dict \u0026#34;Content\u0026#34; .Content \u0026#34;Ruby\u0026#34; $params.ruby \u0026#34;Fraction\u0026#34; $params.fraction \u0026#34;Fontawesome\u0026#34; $params.fontawesome | partial \u0026#34;function/content.html\u0026#34; | safeHTML -}} \u0026lt;/div\u0026gt; 修改成如下：\n1 2 3 4 5 6 7 {{- /* Content */ -}} \u0026lt;div class=\u0026#34;content\u0026#34; id=\u0026#34;content\u0026#34;\u0026gt; {{- dict \u0026#34;Content\u0026#34; .Content \u0026#34;Ruby\u0026#34; $params.ruby \u0026#34;Fraction\u0026#34; $params.fraction \u0026#34;Fontawesome\u0026#34; $params.fontawesome | partial \u0026#34;function/content.html\u0026#34; | safeHTML -}} {{- /* Reward */ -}} {{- partial \u0026#34;single/reward.html\u0026#34; . -}} \u0026lt;/div\u0026gt; 添加css代码 在自定义的_custom.scss里添加如下样式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /* 打赏 */ article .post-reward { margin-top: 20px; padding-top: 10px; text-align: center; border-top: 1px dashed #e6e6e6 } article .post-reward .reward-button { margin: 15px 0; padding: 3px 7px; display: inline-block; color: #c05b4d; border: 1px solid #c05b4d; border-radius: 5px; cursor: pointer } article .post-reward .reward-button:hover { color: #fefefe; background-color: #c05b4d; transition: .5s } article .post-reward #reward:checked~.qr-code { display: block } article .post-reward #reward:checked~.reward-button { display: none } article .post-reward .qr-code { display: none } article .post-reward .qr-code .qr-code-image { display: inline-block; min-width: 200px; width: 40%; margin-top: 15px } article .post-reward .qr-code .qr-code-image span { display: inline-block; width: 100%; margin: 8px 0 } article .post-reward .qr-code .image { width: 200px; height: 200px } 添加打赏榜 前文新增了文章打赏的功能，这里添加一个新的页面来记录老板们的打赏和红包，用的是响应式垂直时间轴。\n配置文件添加子菜单 这里使用了菜单栏的子菜单配置，子菜单的做法请参考前文。\n1 2 3 4 5 6 7 8 [[menu.main]] parent = \u0026#34;posts\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-fw fa-donate\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; name = \u0026#34;打赏\u0026#34; title = \u0026#34;感谢打赏，老板大气~\u0026#34; identifier = \u0026#34;donation\u0026#34; url = \u0026#34;/donation/\u0026#34; weight = 4 添加模板文件donation.html 新建模板文件/layouts/shortcodes/donation.html，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 {{ if .IsNamedParams }} {{- $cdn := .Site.Params.cdnPrefix -}} {{- $name := .Get \u0026#34;name\u0026#34; -}} \u0026lt;div class=\u0026#34;cd-timeline-block\u0026#34;\u0026gt; {{- if eq $name \u0026#34;wechat\u0026#34; -}} \u0026lt;div class=\u0026#34;cd-timeline-img cd-wechat\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;/images/common/wechat.svg\u0026#34; alt=\u0026#34;微信\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; {{- else if eq $name \u0026#34;alipay\u0026#34; -}} \u0026lt;div class=\u0026#34;cd-timeline-img cd-alipay\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;{{- $cdn -}}/images/common/alipay.svg\u0026#34; alt=\u0026#34;支付宝\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; {{- end -}} \u0026lt;div class=\u0026#34;cd-timeline-content {{ .Get \u0026#34;name\u0026#34; }}\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;b\u0026gt;{{ .Get \u0026#34;title\u0026#34; }}\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{{ .Get \u0026#34;description\u0026#34; }}\u0026lt;/p\u0026gt; \u0026lt;a href={{ .Get \u0026#34;url\u0026#34; }} class=\u0026#34;cd-read-more\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;阅读被打赏文章\u0026lt;/a\u0026gt; \u0026lt;span class=\u0026#34;cd-date\u0026#34;\u0026gt;{{ .Get \u0026#34;date\u0026#34; }}\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 新增css样式文件和图片 新建/static/css/timeline.style.css，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 /* -------------------------------- Primary style -------------------------------- */ html * { -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } *, *:after, *:before { -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } body { font-size: 100%; background-color: #e9f0f5; } footer { padding-bottom: 3rem; } img { max-width: 100%; } /* -------------------------------- Modules - reusable parts of our design -------------------------------- */ .cd-container { /* this class is used to give a max-width to the element it is applied to, and center it horizontally when it reaches that max-width */ width: 90%; max-width: 1170px; margin: 0 auto; } .cd-container::after { /* clearfix */ content: \u0026#39;\u0026#39;; display: table; clear: both; } /* -------------------------------- Main components -------------------------------- */ #cd-timeline { position: relative; padding: 2em 0; margin-top: 0; margin-bottom: 0; } #cd-timeline::before { /* this is the vertical line */ content: \u0026#39;\u0026#39;; position: absolute; top: 0; left: 18px; height: 100%; width: 4px; background: #d7e4ed; } @media only screen and (min-width: 1170px) { #cd-timeline { margin-top: 0; margin-bottom: 0; } #cd-timeline::before { left: 50%; margin-left: -2px; } } .cd-timeline-block { position: relative; margin: 2em 0; } .cd-timeline-block:after { content: \u0026#34;\u0026#34;; display: table; clear: both; } .cd-timeline-block:first-child { margin-top: 0; } .cd-timeline-block:last-child { margin-bottom: 0; } @media only screen and (min-width: 1170px) { .cd-timeline-block { margin: 4em 0; } .cd-timeline-block:first-child { margin-top: 0; } .cd-timeline-block:last-child { margin-bottom: 0; } } .cd-timeline-img { position: absolute; top: 0; left: 0; width: 40px; height: 40px; border-radius: 50%; box-shadow: 0 0 0 4px #e9f0f5, inset 0 2px 0 rgba(0, 0, 0, 0.08), 0 3px 0 4px rgba(0, 0, 0, 0.05); } .cd-timeline-img img { display: block; width: 24px; height: 24px; position: relative; left: 50%; top: 50%; margin-left: -12px; margin-top: -12px; } .cd-timeline-img.cd-wechat { background: #75ce66; } .cd-timeline-img.cd-alipay { background: #3e8af4; } .cd-timeline-img.cd-location { background: #f0ca45; } @media only screen and (min-width: 1170px) { .cd-timeline-img { width: 60px; height: 60px; left: 50%; margin-left: -30px; /* Force Hardware Acceleration in WebKit */ -webkit-transform: translateZ(0); -webkit-backface-visibility: hidden; } .cssanimations .cd-timeline-img.is-hidden { visibility: hidden; } .cssanimations .cd-timeline-img.bounce-in { visibility: visible; -webkit-animation: cd-bounce-1 0.6s; -moz-animation: cd-bounce-1 0.6s; animation: cd-bounce-1 0.6s; } } .cd-timeline-content { position: relative; margin-left: 60px; border-radius: 0.25em; padding: 1em; box-shadow: 0 3px 0 #d7e4ed; } .cd-timeline-content:after { content: \u0026#34;\u0026#34;; display: table; clear: both; } .cd-timeline-content { color: #303e49; } .cd-timeline-block .wechat{ background: #75ce66; } .cd-timeline-block .alipay{ background: #3e8af4; } .cd-timeline-content p, .cd-timeline-content .cd-read-more, .cd-timeline-content .cd-date { font-size: 13px; font-size: 0.8125rem; } .cd-timeline-content .cd-read-more, .cd-timeline-content .cd-date { display: inline-block; } .cd-timeline-content p { margin: 1em 0; line-height: 1.6; } .cd-timeline-content .cd-read-more { float: right; padding: .8em 1em; background: white; color: #999 !important; border-radius: 0.25em; } .no-touch .cd-timeline-content .cd-read-more:hover { background-color: #bac4cb; } a.cd-read-more:hover{text-decoration:none; background-color: #424242; } .cd-timeline-content .cd-date { float: left; padding: .8em 0; opacity: .7; color: black; } .cd-timeline-content::before { content: \u0026#39;\u0026#39;; position: absolute; top: 16px; right: 100%; height: 0; width: 0; border: 7px solid transparent; border-right: 7px solid white; } @media only screen and (min-width: 768px) { .cd-timeline-content { font-size: 20px; font-size: 1.25rem; } .cd-timeline-content p { font-size: 16px; font-size: 1rem; } .cd-timeline-content .cd-read-more, .cd-timeline-content .cd-date { font-size: 14px; font-size: 0.875rem; } } @media only screen and (min-width: 1170px) { .cd-timeline-content { margin-left: 0; padding: 1em; width: 45%; } .cd-timeline-content::before { top: 24px; left: 100%; border-color: transparent; border-left-color: white; } .cd-timeline-content .cd-read-more { float: left; } .cd-timeline-content .cd-date { position: absolute; width: 100%; left: 122%; top: 6px; font-size: 16px; font-size: 1rem; } .cd-timeline-block .wechat{ background: #75ce66; } .cd-timeline-block .alipay{ background: #3e8af4; } .cd-timeline-block:nth-child(even) .cd-timeline-content { float: right; } .cd-timeline-block:nth-child(even) .cd-timeline-content::before { top: 24px; left: auto; right: 100%; border-color: transparent; border-right-color: white; } .cd-timeline-block:nth-child(even) .cd-timeline-content .cd-read-more { float: right; } .cd-timeline-block:nth-child(even) .cd-timeline-content .cd-date { left: auto; right: 122%; text-align: right; } .cssanimations .cd-timeline-content.is-hidden { visibility: hidden; } .cssanimations .cd-timeline-content.bounce-in { visibility: visible; -webkit-animation: cd-bounce-2 0.6s; -moz-animation: cd-bounce-2 0.6s; animation: cd-bounce-2 0.6s; } } @media only screen and (min-width: 1170px) { /* inverse bounce effect on even content blocks */ .cssanimations .cd-timeline-block:nth-child(even) .cd-timeline-content.bounce-in { -webkit-animation: cd-bounce-2-inverse 0.6s; -moz-animation: cd-bounce-2-inverse 0.6s; animation: cd-bounce-2-inverse 0.6s; } } 此外还需要新增两个图片：\n/static/images/common/alipay.svg和/static/images/common/wechat.svg，这两个图片可以从下面的路径里获取到，请自行下载。\nhttps://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/common/ 新建donation页面 新建/content/donation/index.md，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 --- title: \u0026#34;打赏榜\u0026#34; date: 2021-08-23T22:01:44+08:00 lastmod: 2021-08-23T22:01:44+08:00 --- \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/css/timeline.style.css\u0026#34; /\u0026gt; \u0026lt;section id=\u0026#34;cd-timeline\u0026#34; class=\u0026#34;cd-container\u0026#34;\u0026gt; {{\u0026lt; donation name=\u0026#34;wechat\u0026#34; title=\u0026#34;感谢*A打赏5元！\u0026#34; description=\u0026#34;打赏文章为Hexo系列(2.1) - NexT主题美化与博客功能增强 · 第二章#对文章进行加密\u0026#34; url=\u0026#34;https://lewky.cn/posts/hexo-2.1.html/#对文章进行加密\u0026#34; date=\u0026#34;2021-08-23\u0026#34; \u0026gt;}} {{\u0026lt; donation name=\u0026#34;alipay\u0026#34; title=\u0026#34;感谢*B打赏5元！\u0026#34; description=\u0026#34;打赏文章为Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章#使用Waline替代Valine评论系统\u0026#34; url=\u0026#34;http://lewky.cn/posts/hugo-3.1.html/#使用waline替代valine评论系统\u0026#34; date=\u0026#34;2021-08-11\u0026#34; \u0026gt;}} \u0026lt;/section\u0026gt; 该页面首先需要引入css样式文件，然后是添加一个section标签，我们的打赏片段需要在section标签里通过一个个的donation短代码来引入。\n上文中的donation短代码有五个属性。\nname有两种值：wechat和alipay，分别对应微信和支付宝。\ntitle是标题，description是描述，url是被打赏文章的链接，date是打赏日期。\n具体效果可以去我的打赏页面看看。\n添加站点运行时间 将\\themes\\LoveIt\\layouts\\partials\\footer.html拷贝到\\layouts\\partials\\footer.html，打开拷贝后的文件，在\u0026lt;div class=\u0026quot;footer-container\u0026quot;\u0026gt;的下方添加如下代码：\n1 2 3 \u0026lt;div class=\u0026#34;footer-line\u0026#34;\u0026gt; \u0026lt;span id=\u0026#34;run-time\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; 然后在custom.js中添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 站点运行时间 */ function runtime() { window.setTimeout(\u0026#34;runtime()\u0026#34;, 1000); /* 请修改这里的起始时间 */ let startTime = new Date(\u0026#39;04/24/2018 15:00:00\u0026#39;); let endTime = new Date(); let usedTime = endTime - startTime; let days = Math.floor(usedTime / (24 * 3600 * 1000)); let leavel = usedTime % (24 * 3600 * 1000); let hours = Math.floor(leavel / (3600 * 1000)); let leavel2 = leavel % (3600 * 1000); let minutes = Math.floor(leavel2 / (60 * 1000)); let leavel3 = leavel2 % (60 * 1000); let seconds = Math.floor(leavel3 / (1000)); let runbox = document.getElementById(\u0026#39;run-time\u0026#39;); runbox.innerHTML = \u0026#39;本站已运行\u0026lt;i class=\u0026#34;far fa-clock fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; \u0026#39; + ((days \u0026lt; 10) ? \u0026#39;0\u0026#39; : \u0026#39;\u0026#39;) + days + \u0026#39; 天 \u0026#39; + ((hours \u0026lt; 10) ? \u0026#39;0\u0026#39; : \u0026#39;\u0026#39;) + hours + \u0026#39; 时 \u0026#39; + ((minutes \u0026lt; 10) ? \u0026#39;0\u0026#39; : \u0026#39;\u0026#39;) + minutes + \u0026#39; 分 \u0026#39; + ((seconds \u0026lt; 10) ? \u0026#39;0\u0026#39; : \u0026#39;\u0026#39;) + seconds + \u0026#39; 秒 \u0026#39;; } runtime(); 添加文章热度排行榜 在content目录下新建hot目录，添加一个index.md文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 --- title: \u0026#34;热度排行榜\u0026#34; --- \u0026lt;style\u0026gt; ul#hot { list-style: none; } ul#hot li { position: relative; padding-left: 30px; height: 36px; line-height: 36px; } ul#hot li:after { content: \u0026#34;\u0026#34;; display: inline-block; width: 20px; height: 20px; line-height: 20px; text-align: center; color: #FFF; background: #999999; text-align: center; position: absolute; left: 0; top: 8px; } ul#hot li:first-child:after {content: \u0026#34;1\u0026#34;;background: #FD8C84;} ul#hot li:nth-child(2):after {content: \u0026#34;2\u0026#34;;background: #FFCC99;} ul#hot li:nth-child(3):after {content: \u0026#34;3\u0026#34;;background: #7FD75A;} ul#hot li:nth-child(4):after {content: \u0026#34;4\u0026#34;;background: #CCCCFF;} ul#hot li:nth-child(5):after {content: \u0026#34;5\u0026#34;;background: #60C4FD;} ul#hot li:nth-child(6):after {content: \u0026#34;6\u0026#34;;} ul#hot li:nth-child(7):after {content: \u0026#34;7\u0026#34;;} ul#hot li:nth-child(8):after {content: \u0026#34;8\u0026#34;;} ul#hot li:nth-child(9):after {content: \u0026#34;9\u0026#34;;} ul#hot li:nth-child(10):after {content: \u0026#34;10\u0026#34;;} ul#hot li:nth-child(11):after {content: \u0026#34;11\u0026#34;;} ul#hot li:nth-child(12):after {content: \u0026#34;12\u0026#34;;} ul#hot li:nth-child(13):after {content: \u0026#34;13\u0026#34;;} ul#hot li:nth-child(14):after {content: \u0026#34;14\u0026#34;;} ul#hot li:nth-child(15):after {content: \u0026#34;15\u0026#34;;} li font {color: grey;} li#hot1 font, li#hot2 font, li#hot3 font {color: red;} li#hot4 font, li#hot5 font {color: #bd5d67;} ul#hot li { display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; overflow: hidden; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt;\u0026lt;ul id=\u0026#34;hot\u0026#34;\u0026gt;\u0026lt;/ul\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/leancloud-storage@3.10.0/dist/av-min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;AV.initialize(\u0026#34;appId\u0026#34;, \u0026#34;appKey\u0026#34;);\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var time=0 var title=\u0026#34;\u0026#34; var url=\u0026#34;\u0026#34; var query = new AV.Query(\u0026#39;Counter\u0026#39;); query.notEqualTo(\u0026#39;id\u0026#39;,0); query.descending(\u0026#39;time\u0026#39;); query.limit(15); query.find().then(function (todo) { for (var i=0;i\u0026lt;1000;i++){ var result=todo[i].attributes; time=result.time; title=result.title; url=result.url; if (i\u0026lt;5) { var content=\u0026#34;\u0026lt;li id=\u0026#39;hot\u0026#34;+(i+1)+\u0026#34;\u0026#39;\u0026gt;\u0026#34;+\u0026#34;\u0026lt;a href=\u0026#39;\u0026#34;+url+\u0026#34;\u0026#39;\u0026gt;\u0026#34;+title+\u0026#34;\u0026lt;font\u0026gt;\u0026#34;+\u0026#34;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;i class=\u0026#39;fas fa-fire fa-fw\u0026#39;\u0026gt;\u0026lt;/i\u0026gt; \u0026#34;+time+\u0026#34; ℃\u0026#34;+\u0026#34;\u0026lt;/font\u0026gt;\u0026#34;+\u0026#34;\u0026lt;/a\u0026gt;\u0026#34;+\u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; } else { var content=\u0026#34;\u0026lt;li id=\u0026#39;hot\u0026#34;+(i+1)+\u0026#34;\u0026#39;\u0026gt;\u0026#34;+\u0026#34;\u0026lt;a href=\u0026#39;\u0026#34;+url+\u0026#34;\u0026#39;\u0026gt;\u0026#34;+title+\u0026#34;\u0026lt;font\u0026gt;\u0026#34;+\u0026#34;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;i class=\u0026#39;fas fa-eye fa-fw\u0026#39;\u0026gt;\u0026lt;/i\u0026gt; \u0026#34;+time+\u0026#34; ℃\u0026#34;+\u0026#34;\u0026lt;/font\u0026gt;\u0026#34;+\u0026#34;\u0026lt;/a\u0026gt;\u0026#34;+\u0026#34;\u0026lt;/li\u0026gt;\u0026#34;; } document.getElementById(\u0026#34;hot\u0026#34;).innerHTML+=content } }, function (error) { console.log(\u0026#34;error\u0026#34;); }); \u0026lt;/script\u0026gt; 需要把上面代码中的appId和appKey改成LeanCloud应用对应的值。\n添加PlantUML支持 新增/themes/LoveIt/layouts/shortcodes/uml.html，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 {{ $title := \u0026#34;Diagram\u0026#34; }} {{ if .IsNamedParams }} {{ with .Get \u0026#34;title\u0026#34; }} {{ $title = . }} {{ end }} {{ else }} {{ with .Get 0 }} {{ $title = . }} {{ end }} {{ end }} {{ $inner := .Inner }} \u0026lt;figure\u0026gt; \u0026lt;img src=\u0026#39;https://g.gravizo.com/svg?{{ $inner }}\u0026#39; alt=\u0026#39;{{ $title }}\u0026#39; /\u0026gt; \u0026lt;figcaption\u0026gt;{{ $title }}\u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; 之后即可在正文中通过在{{\u0026lt; uml \u0026gt;}}和{{\u0026lt; /uml \u0026gt;}}之间使用PlantUML的语法来自动渲染出对应的PlantUML图，不过需要注意的是，该功能是借助的gravizo来实现。而gravizo并不能支持所有的PlantUML语法，部分语法会失效导致渲染失败。这时候只能手动去PlantUML官网提供的在线工具生成对应的图片了。\n1 2 3 4 5 6 7 {{\u0026lt; uml \u0026gt;}} @startuml class Animal class Cat Animal \u0026lt;-- Cat @enduml {{\u0026lt; /uml \u0026gt;}} Diagram\r参考链接 Hexo-NexT添加热度、阅读量排行 分享一个纯CSS样式，显示不同颜色数字的排行榜列表 Embed a diagram in a Hugo page HTML5+CSS3实现的响应式垂直时间轴 ","permalink":"https://lewky.cn/posts/hugo-3.2.html/","tags":["Hugo","LoveIt主题","主题美化","功能增强"],"title":"Hugo系列(3.2) - LoveIt主题美化与博客功能增强 · 第三章"},{"categories":["Hugo系列"],"contents":"前言 本博客使用的是Hugo的LoveIt主题，本文也是基于该主题而写的，不过Hugo的美化步骤应该大同小异，版本如下：\n1 2 3 hugo: v0.74.2/extended windows/amd64 BuildDate: unknown LoveIt: v0.2.10 请注意，本文的所有功能都离不开两个新增加的文件：_custom.scss和custom.js，部分功能还需要jquery，在第一章中会提及如何引入。\n另外本文篇幅太长，阅读体验不好，将其进行分章如下：\nHugo系列(3.0) - LoveIt主题美化与博客功能增强 · 第一章 Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章 Hugo系列(3.2) - LoveIt主题美化与博客功能增强 · 第三章 Hugo系列(3.3) - LoveIt主题美化与博客功能增强 · 第四章 Valine评论系统添加邮件通知和QQ提醒 LoveIt主题自带的Valine没有邮件通知和QQ提醒功能，所以需要额外使用Valine的增强版Valine-Admin来进行功能增强。网上有好几个版本，我这里选择了目前由@W4J1e维护的Hexo-Valine-ASPush项目，由于我需要自定义部分改动，所以自己fork了一份：valine-admin-custom。如果需要进行自定义改动的，可以继续fork我的这个项目。\n下面开始教程。这里默认你已经使用了Valine作为评论系统，如果还没有对应的LeanCloud应用请自行移步Valine的官方文档： Valine快速开始。\n部署LeanCloud云引擎 登陆你的LeanCloud账号，进入你的应用，选择：云引擎 -\u0026gt; 部署 -\u0026gt; Git部署，然后输入下面的仓库地址：\n1 https://github.com/lewky/valine-admin-custom.git 然后点击部署按钮，等待云引擎将上面的仓库代码克隆下来。接下来需要设置环境变量。\n设置环境变量 点击云引擎 -\u0026gt; 设置，选择添加新变量，将下列变量一一加入。\n变量 示例 说明 SITE_NAME xxx [必填] 网站名称 SITE_URL https://xxx.com [必填] 网站首页地址，地址末尾不要加/ SMTP_USER xxxxxx@qq.com [必填] SMTP登录用户，一般为邮箱地址 SMTP_PASS ccxxxxxxxxch [必填] SMTP授权码，不是邮箱的登陆密码，请自行查询对应邮件服务商授权码的获取方式 SMTP_SERVICE QQ [必填] 邮件服务提供商，支持 QQ、163、126、Gmail 以及 更多 SENDER_NAME xxx [必填] 发件人 SENDER_EMAIL xxxxxx@qq.com [必填] 发件邮箱 ADMIN_URL https://xxx.leanapp.cn/ [建议] Web主机二级域名（云引擎域名），用于自动唤醒 BLOGGER_EMAIL xxxxx@gmail.com [可选] 博主通知收件地址，默认使用SENDER_EMAIL AKISMET_KEY xxxxxxxx [可选] Akismet Key 用于垃圾评论检测，设为MANUAL_REVIEW开启人工审核，留空不使用反垃圾 TEMPLATE_NAME default [可选] 设置提醒邮件主题，目前内置了多款主题：default、rainbow、custom1、custom2 COMMENT #post-comment [可选] 评论 div 的 ID 名，直接跳转到评论位置 设置好变量后，需要重启实例。在部署页面点击重启按钮即可，每次更改变量后都需要重启才能生效。如果对应的Git仓库代码发生变更，需要清除部署，重新克隆代码才能生效。\n后台评论管理 首先需要设置管理员信息。在部署云引擎成功后，访问管理员注册页面https://云引擎域名/sign-up，注册管理员登录信息，如：https://cloud.lewky.cn/sign-up\n注册成功后可以在存储 -\u0026gt; 结构化数据 -\u0026gt; _User里看到多出来一条数据，正是刚刚我们注册成功的用户。\n注：使用原版Valine如果遇到注册页面不显示直接跳转至登录页的情况，请手动删除_User表中的全部数据。\n注册成功后，就可以通过这个注册的用户访问后台评论管理页面：https://云引擎域名\n配置QQ提醒 前往Qmsg酱官网，点击管理台登陆账号，选择其中任意一个你想使用的Qmsg酱(QQ机器人)，并加其为QQ好友 点击菜单栏里Qmsg酱旁边的QQ号码，添加你想要接收信息推送的QQ号码 点击 菜单栏里的KEY，这里有一串字符串等下要添加到LeanCloud的环境变量里 官网里提供了所有的接口文档，你可以先行通过一个简单的测试来验证你的QQ能不能接收到推送，如下：\n在浏览器新打开一个页面，在地址栏里输入https://qmsg.zendee.cn/send/，然后把你管理台里的KEY添加到地址栏末尾，然后在末尾继续加上?msg=test，接着按下回车键，这里表示让Qmsg酱发送test给你的QQ号码 如果发送成功，你会发现浏览器页面内容变成： 1 {\u0026#34;success\u0026#34;:true,\u0026#34;reason\u0026#34;:\u0026#34;操作成功\u0026#34;,\u0026#34;code\u0026#34;:0,\u0026#34;info\u0026#34;:{}} 与此同时，你的QQ号码会收到你加的那个Qmsg酱QQ好友的消息。这表明推送正常，可以往下走了。 前面我们已经在LeanCloud云引擎里配置了一部分必须的环境变量，为了使用QQ提醒功能，还想要额外配置两个变量：\n变量 示例 说明 QMSG_KEY xxxxxxx [必填] Qmsg酱的KEY QQ xxxxxxx [必填] Qmsg酱发送的 qq，支持多个，用英文逗号分隔即可 解决云引擎休眠 LeanCloud云引擎有自动休眠机制，这是官方的说法：点击查看\n目前实现了两种云函数定时任务来解决云引擎休眠的问题：\n自动唤醒，定时访问Web APP二级域名防止云引擎休眠； 每天定时检查过去24小时内漏发的邮件通知。 进入云引擎 -\u0026gt; 定时任务，创建两个定时任务：\n选择self-wake云函数，Cron表达式为0 */25 7-23 * * ?，表示每天早7点到晚12点每隔25分钟访问云引擎。 选择resend-mails云函数，Cron表达式为0 10 7 * * ?，表示每天7点10分检查过去24小时内漏发的通知邮件并补发。 云引擎还有个国际版的，要注意表达式的时区问题，不过表达式填写后会显示每天几点操作，应该不会有人填错吧。\n解决免费版云引擎流控问题 免费版云引擎会在达到最大启动时长限制（好像是持续运行18个小时），进入强制休眠状态。在休眠状态时无法通过我们定义的自动唤醒函数来自动重启，可以在日志里看到报错如下：\n1 {\u0026#34;error\u0026#34;:\u0026#34;因流控原因，通过定时任务唤醒体验版实例失败，建议升级至标准版云引擎实例避免休眠 https://url.leanapp.cn/dwAEksv\u0026#34;} 但是如果在休眠期间，云引擎又受到外界的一次访问，就可以再次激活进入启动状态，这时候就可以通过自动唤醒函数来每隔半小时自我唤醒一次了。也就是说，当云引擎进入强制休眠状态后，我们通过外部的定时任务，来每天定时访问云引擎绑定好的域名（也就是你的后台评论管理页面地址），就可以继续白嫖了。\n那么去那里弄免费的外部定时任务呢？实现方案有不少，比如：\n方案一：GitHub + Actions 借助GitHub + Actions，自动部署也是用这种方案，不过这种方案有个缺点，就是每次执行action都会生成一次对应的commit，对我来说不是理想方案，这里就不介绍了。有兴趣的可以参考这篇文章\n方案二：借助国内其他的免费云函数或定时任务 利用国内的云函数，自己写一个脚本。然后定时监控即可。或者宝塔、自己服务器的定时任务都是可以的。说穿了，就是用其他的类似于LeanCloud云引擎类似的免费容器的云函数或者定时任务来唤醒LeanCloud的云引擎，那如果其他的免费容器也有类似的强制休眠机制怎么办呢？\n很简单，互相套娃即可。让一个免费的容器A通过定时任务在非休眠期间去唤醒另一个强制休眠中的容器B，如果容器A强制休眠了就让另一个非休眠的容器B去唤醒。只要两个免费容器的强制休眠时间错开即可完成这一白嫖循环O(∩_∩)O~\n方案三：cloudflare的Workers cloudflare的Workers可以在线定义脚本，通过链接即可触发脚本，具体做法请参考这篇文章\n方案四：借助cron-job平台进行每日定时唤醒 通过cron-job平台进行监控，这是官方地址\n本人使用的方案四，该方案其实和方案二是一回事。这里简单介绍下怎么用，注册该平台可能需要tī zi，请自行解决。\n注册时，Time zone（也就是时区）请选择Asia/Shanghai，否则后续在定义cron表达式时需要自己换算时区时间。如果注册页面最下面的谷歌人机验证出不来，你懂的，请自行解决。 注册后需要登录邮箱通过邮件激活账号，没收到邮件的请检查你的垃圾箱，邮件可能在垃圾箱里。 激活账号后登录你的账号，访问这个地址：https://cron-job.org/en/members/jobs/ 点击页面上的Create cronjob按钮，创建你的定时任务，各个必填配置项如下表： 变量 示例 说明 Title xxx 定时任务名称 Address https://xxx.com 访问的地址，请填写LeanCloud云引擎绑定的域名地址，也就是那个后台评论管理页面地址https://云引擎域名 Schedule 按需选择 定时任务的执行时间和频率，这里建议使用第二种：Every day at 6 : 50 。具体每天几点执行请自行决定。 Notifications 按需选择 执行失败时的通知提醒 Save responses 按需选择 保存执行定时任务的日志 使用Waline替代Valine评论系统 鉴于Valine的安全问题，以及LeanCloud云引擎的限流问题，改用Waline + Vercel来作为评论系统，Waline是基于Valine进行开发的，所以迁移成本较低。这是Waline的官方文档，有很详细的配置、迁移等教程。\n由于LoveIt主题没有引入Waline，所以这里记录下如何引入Waline，以及遇到的相关问题的解决方法。\n站点配置文件添加相关变量 打开站点配置文件，找到Valine相关变量[params.page.comment.valine]，在该节点下面添加Waline相关的变量\t：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # Waline comment config (https://waline.js.org/) # Waline 评论系统设置 (https://waline.js.org/) [params.page.comment.waline] enable = true #js = \u0026#34;https://cdn.jsdelivr.net/npm/@waline/client@latest\u0026#34; js = \u0026#34;https://cdn.jsdelivr.net/npm/@waline/client/dist/Waline.min.js\u0026#34; meta = [\u0026#39;nick\u0026#39;,\u0026#39;mail\u0026#39;,\u0026#39;link\u0026#39;] # 评论者相关属性 requiredMeta = [\u0026#39;nick\u0026#39;,\u0026#39;mail\u0026#39;] # 设置必填项，默认匿名 login = \u0026#34;force\u0026#34; # 评论必须先登录，用于防护恶意攻击 placeholder = \u0026#34;为防恶意灌水攻击，评论前需注册并登录，望见谅~\u0026#34; # 评论框占位提示符 serverURL = \u0026#34;\u0026#34; # Waline的服务端地址（必填） #imageHosting = # 图床api，如果允许评论框上传图片 uploadImage = false # 评论上传图片功能 avatar = \u0026#34;retro\u0026#34; # Gravatar头像 avatarCDN = \u0026#34;https://sdn.geekzu.org/avatar/\u0026#34; # Gravatar头像CDN地址，不建议使用loli源 pageSize = 20 # 评论列表分页，每页条数 lang = \u0026#34;zh-CN\u0026#34; # 多语言支持 visitor = true # 文章访问量统计 highlight = true # 代码高亮 记得把原本的评论系统的enable设置为false，改用新加的Waline。\n修改comment.html模板文件 将\\themes\\LoveIt\\layouts\\partials\\comment.html拷贝到\\layouts\\partials\\comment.html，打开拷贝后的文件，找到Valine相关的代码部分，然后在其下方添加Waline的代码，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 {{- /* Waline Comment System */ -}} {{- $waline := $comment.waline | default dict -}} {{- if $waline.enable -}} \u0026lt;div id=\u0026#34;waline\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#39;{{ $waline.js }}\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; new Waline({ el: \u0026#39;#waline\u0026#39;, meta: {{ $waline.meta }}, requiredMeta: {{ $waline.requiredMeta }}, login: {{ $waline.login }}, placeholder: {{ $waline.placeholder }}, serverURL: {{ $waline.serverURL }}, avatarCDN: {{ $waline.avatarCDN }}, pageSize: {{ $waline.pageSize }}, avatar: {{ $waline.avatar }}, lang: {{ $waline.lang }}, visitor: {{ $waline.visitor }}, highlight: {{ $waline.highlight }}, uploadImage: {{ $waline.uploadImage }}\t}); \u0026lt;/script\u0026gt; {{- end -}} Waline内置微博表情，如果想自定义表情包的，可以继续添加两个属性emoji到上面的代码里，具体做法可以参考官方文档 - 自定义表情。\n这里顺便介绍下@小康大佬整理的一个很方便的表情包站点：表情速查，里面有很多类别的表情包，还有对应的快速引入语法链接，以及用于配置Valine、Waline等评论系统表情包映射的JSON！\n这里还有一个专门爬取b站表情包的项目仓库：lrhtony / BiliEmoji\n添加评论统计到文章元数据 将/themes/LoveIt/layouts/posts/single.html拷贝到/layouts/posts/single.html，打开拷贝后的文件，找到如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;div class=\u0026#34;post-meta-line\u0026#34;\u0026gt; {{- with .Site.Params.dateformat | default \u0026#34;2006-01-02\u0026#34; | .PublishDate.Format -}} \u0026lt;i class=\u0026#34;far fa-calendar-alt fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;time datetime=\u0026#34;{{ . }}\u0026#34;\u0026gt;{{ . }}\u0026lt;/time\u0026gt;\u0026amp;nbsp; {{- end -}} \u0026lt;i class=\u0026#34;fas fa-pencil-alt fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;{{ T \u0026#34;wordCount\u0026#34; .WordCount }}\u0026amp;nbsp; \u0026lt;i class=\u0026#34;far fa-clock fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;{{ T \u0026#34;readingTime\u0026#34; .ReadingTime }}\u0026amp;nbsp; {{- $comment := .Scratch.Get \u0026#34;comment\u0026#34; | default dict -}} {{- if $comment.enable | and $comment.valine.enable | and $comment.valine.visitor -}} \u0026lt;span id=\u0026#34;{{ .RelPermalink }}\u0026#34; class=\u0026#34;leancloud_visitors\u0026#34; data-flag-title=\u0026#34;{{ .Title }}\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;far fa-eye fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;span class=leancloud-visitors-count\u0026gt;\u0026lt;/span\u0026gt;\u0026amp;nbsp;{{ T \u0026#34;views\u0026#34; }} \u0026lt;/span\u0026gt;\u0026amp;nbsp; {{- end -}} \u0026lt;/div\u0026gt; 将上面的代码改为如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;div class=\u0026#34;post-meta-line\u0026#34;\u0026gt; {{- with .Site.Params.dateformat | default \u0026#34;2006-01-02\u0026#34; | .PublishDate.Format -}} \u0026lt;i class=\u0026#34;far fa-calendar-alt fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;time datetime=\u0026#34;{{ . }}\u0026#34;\u0026gt;{{ . }}\u0026lt;/time\u0026gt;\u0026amp;nbsp; {{- end -}} \u0026lt;i class=\u0026#34;fas fa-pencil-alt fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;{{ T \u0026#34;wordCount\u0026#34; .WordCount }} \u0026lt;i class=\u0026#34;far fa-clock fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;{{ T \u0026#34;readingTime\u0026#34; .ReadingTime }}\u0026amp;nbsp; {{- $comment := .Scratch.Get \u0026#34;comment\u0026#34; | default dict -}} {{- if $comment.enable | and $comment.valine.enable | and $comment.valine.visitor -}} \u0026lt;span id=\u0026#34;{{ .RelPermalink }}\u0026#34; class=\u0026#34;leancloud_visitors\u0026#34; data-flag-title=\u0026#34;{{ .Title }}\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;far fa-eye fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;span class=leancloud-visitors-count\u0026gt;\u0026lt;/span\u0026gt;\u0026amp;nbsp;{{ T \u0026#34;views\u0026#34; }} \u0026lt;/span\u0026gt;\u0026amp;nbsp; {{- end -}} {{- if $comment.enable | and $comment.waline.enable | and $comment.waline.visitor -}} \u0026lt;span id=\u0026#34;{{ .RelPermalink }}\u0026#34; class=\u0026#34;leancloud_visitors\u0026#34; data-flag-title=\u0026#34;{{ .Title }}\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;far fa-eye fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;span class=leancloud-visitors-count\u0026gt;\u0026lt;/span\u0026gt;\u0026amp;nbsp;{{ T \u0026#34;views\u0026#34; }} \u0026lt;/span\u0026gt;\u0026amp;nbsp; \u0026lt;a href=\u0026#34;#comments\u0026#34; id=\u0026#34;post-meta-vcount\u0026#34; title=\u0026#34;{{ T `viewComments` }}\u0026#34;\u0026gt; \u0026lt;i class=\u0026#34;fas fa-comment fa-fw\u0026#34;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;span id=\u0026#34;{{ .RelPermalink }}\u0026#34; class=\u0026#34;waline-comment-count\u0026#34;\u0026gt;\u0026lt;/span\u0026gt;\u0026amp;nbsp;条评论 \u0026lt;/a\u0026gt; {{- end -}} \u0026lt;/div\u0026gt; 添加样式 在_custom.scss里添加如下样式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 文章元数据meta */ .post-meta .post-meta-line:nth-child(2) i:nth-child(1) { margin-left: 0; } .post-meta .post-meta-line:nth-child(2) i { margin-left: 0.3rem; } .post-meta .post-meta-line:nth-child(2) span i { margin-left: 0.3rem !important; } .post-meta a#post-meta-vcount { color: #a9a9b3; \u0026amp;:hover { color: #2d96bd; } } 部署到Vercel 这个部分直接参考官方文档 - Vercel 部署。实际上就是在GitHub上帮你创建了一个仓库，仓库里只有简单的几个文件，用于Vercel的部署。Vercel那边会和刚刚创建的GitHub仓库关联，然后部署到Vercel自己的服务器。\n这里有个坑，之前用Valine的时候只需要用到LeanCloud的两个变量APP ID和APP KEY。但是对于Waline，必须要再用到第三个变量Master Key。也就是说，对于Waline + Vercel，必须配置三个变量LEAN_ID、LEAN_KEY和LEAN_MASTER_KEY才能算部署成功。\n否则你会发现就算Vercel显示部署成功，一旦访问部署页面却会发现页面一片空白，具体可参考GitHub上的一个issue：Vercel初始化后打开网址页面内容为空 #82\nWaline还带有简单的后台，可以实现对评论的管理。部署完成后访问\u0026lt;serverURL\u0026gt;/ui/register进行注册，第一个注册的你会被设定成管理员。登录成功后就可以看到评论管理的界面了，大家可以收藏该地址方便后续使用。serverURL就是Vercel部署成功后提供给你的那几个访问域名。\n如果原本使用的是Valine + LeanCloud云引擎，在改用Waline + Vercel后记得把LeanCloud云引擎的部署清除掉。\n使用评论通知功能 Waline支持邮件、微信、QQ通知，想要使用通知功能，需要在Vercel那边配置环境变量。具体可参考官方文档 - 评论通知。这些环境变量名字和Valine的配置是一样的，貌似只有QQ通知相关的一个变量名字不一样而已。\nVercel配置环境变量步骤：\n打开你在Vercel上创建的项目 点击Settings -\u0026gt; Environment Variables -\u0026gt; 选择添加Plaintext类型的环境变量 -\u0026gt; 输入环境变量的name和value -\u0026gt; 点击Save 所有被添加的环境变量可以在下方看到，可以删除或修改已定义的环境变量。\nWaline + Vercel的使用体验 由于使用了LeanCloud作为存储，外加使用了反垃圾评论服务Akismet，所以在提交评论时会比较慢，大概需要等待个两三秒。这个耗时见仁见智，一方面确实慢，一方面可以有效避免被人恶意评论攻击。 据说部署在CloudBase的速度还行。 Waline的机制好像是QQ提醒了邮件就不提醒，所以对于新评论，如果设置了QQ提醒就不会再收到邮件通知。对于回复的评论则是可以同时收到。 Waline提供了一个很棒的后台管理，还支持其他人的注册和登陆。 添加百度统计 默认的统计功能只有Google Analytics和Fathom Analytics两种，想要使用百度统计需要自行修改配置文件和模板文件。\n添加百度统计相关变量 在站点配置文件里找到统计相关的配置，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # Analytics config # 网站分析配置 [params.analytics] enable = flase # Google Analytics [params.analytics.google] id = \u0026#34;\u0026#34; # whether to anonymize IP # 是否匿名化用户 IP anonymizeIP = true # Fathom Analytics [params.analytics.fathom] id = \u0026#34;\u0026#34; # server url for your tracker if you\u0026#39;re self hosting # 自行托管追踪器时的主机路径 server = \u0026#34;\u0026#34; 在这里的[params.analytics.fathom]后面添加一个新的变量给百度统计使用：\n1 2 3 4 # Baidu Analytics # 百度统计 [params.analytics.baidu] id = \u0026#34;\u0026#34; 将百度统计的脚本代码添加到analytics.html里 首先拷贝\\themes\\LoveIt\\layouts\\partials\\plugin\\analytics.html到\\layouts\\partials\\plugin\\analytics.html。\n打开拷贝后的analytics.html文件，在Fathom Analytics的代码下面加上如下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 {{- /* Baidu Analytics */ -}} {{- with $analytics.baidu.id -}} \u0026lt;script\u0026gt; var _hmt = _hmt || []; (function() { var hm = document.createElement(\u0026#34;script\u0026#34;); hm.src = \u0026#34;https://hm.baidu.com/hm.js?{{ . }}\u0026#34;; var s = document.getElementsByTagName(\u0026#34;script\u0026#34;)[0]; s.parentNode.insertBefore(hm, s); })(); \u0026lt;/script\u0026gt; {{- end -}} 启用百度统计 将统计功能的enable = flase改为enable = true。在新增的百度统计变量的id那里填上你的百度统计id值，也就是百度统计的脚本代码里https://hm.baidu.com/hm.js?后面跟着的那串很长的东东。如果不知道怎么查看这个百度统计id，请自行百度。\n添加鼠标右键菜单 添加右键菜单的变量 打开站点配置文件，添加如下变量，可以自行定制菜单里的按钮，包括数量、名称、图片和地址：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 # Right click menu # 右键菜单 [params.rightmenu] enable = true # true or false 是否开启右键 audio = false # true or false 是否开启点击音乐 [[params.rightmenu.layout]] # 按钮名称 name = \u0026#34;首页\u0026#34; # 背景图片 image = \u0026#34;/images/rightmenu/rightmenu1.jpg\u0026#34; # 跳转地址 url = \u0026#34;/\u0026#34; [[params.rightmenu.layout]] name = \u0026#34;音乐游戏\u0026#34; image = \u0026#34;/images/rightmenu/rightmenu2.jpg\u0026#34; url = \u0026#34;/funny/mikutap/\u0026#34; [[params.rightmenu.layout]] name = \u0026#34;前方高能\u0026#34; image = \u0026#34;/images/rightmenu/rightmenu3.jpg\u0026#34; url = \u0026#34;/funny/high/\u0026#34; [[params.rightmenu.layout]] name = \u0026#34;建站日志\u0026#34; image = \u0026#34;/images/rightmenu/rightmenu4.jpg\u0026#34; url = \u0026#34;/posts/e62c38c4.html\u0026#34; [[params.rightmenu.layout]] name = \u0026#34;随笔\u0026#34; image = \u0026#34;/images/rightmenu/rightmenu5.jpg\u0026#34; url = \u0026#34;/posts/d65a1577.html\u0026#34; [[params.rightmenu.layout]] name = \u0026#34;友链\u0026#34; image = \u0026#34;/images/rightmenu/rightmenu6.jpg\u0026#34; url = \u0026#34;/friends/\u0026#34; 如果你有图床的话，还可以额外增加一个图床变量，这样可以去图床加载你的图片，可以参考前文的添加全局cdn变量。\n添加rightmenu.html文件 新建一个layouts/partials/plugin/rightmenu.html文件，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 {{- $rightmenu := .Site.Params.rightmenu -}} {{- $cdn := .Site.Params.cdnPrefix -}} {{- if $rightmenu.enable -}} \u0026lt;div class=\u0026#34;GalMenu GalDropDown\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;circle\u0026#34; id=\u0026#34;gal\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;ring\u0026#34;\u0026gt; {{- range $item := $rightmenu.layout -}} {{- $defaultURL := \u0026#34;/\u0026#34; -}} {{- $defaultName := \u0026#34;Home\u0026#34; -}} {{- $defaultImage := \u0026#34;https://gravatar.loli.net/avatar/c02f8b813aa4b7f72e32de5a48dc17a7?d=retro\u0026amp;v=1.4.14\u0026#34; -}} \u0026lt;a href=\u0026#34;{{- $item.url | default $defaultURL -}}\u0026#34; target=\u0026#34;_blank\u0026#34; {{- $itemImage := $item.image | default $defaultImage -}} {{- if strings.HasPrefix $item.image \u0026#34;http\u0026#34; -}} style=\u0026#34;background-image:url({{- $itemImage -}});\u0026#34; {{- else if strings.HasPrefix $item.image \u0026#34;/\u0026#34; -}} style=\u0026#34;background-image:url({{- $cdn -}}{{- $itemImage -}});\u0026#34; {{- else -}} style=\u0026#34;background-image:url({{- $itemImage -}});\u0026#34; {{- end -}} class=\u0026#34;menuItem\u0026#34;\u0026gt;{{- $item.name | default $defaultName -}}\u0026lt;/a\u0026gt; {{- end -}} \u0026lt;/div\u0026gt; {{- if $rightmenu.audio -}} \u0026lt;audio id=\u0026#34;audio\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/audio/niconiconi.mp3\u0026#34;\u0026gt;\u0026lt;/audio\u0026gt; {{- end -}} \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var items = document.querySelectorAll(\u0026#39;.menuItem\u0026#39;); for (var i = 0, l = items.length; i \u0026lt; l; i++) { items[i].style.left = (50 - 35 * Math.cos( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + \u0026#34;%\u0026#34;; items[i].style.top = (50 + 35 * Math.sin( - 0.5 * Math.PI - 2 * (1 / l) * i * Math.PI)).toFixed(4) + \u0026#34;%\u0026#34; } \u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/css/GalMenu.css\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/js/GalMenu.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; $(document).ready(function() { $(\u0026#39;body\u0026#39;).GalMenu({ \u0026#39;menu\u0026#39;: \u0026#39;GalDropDown\u0026#39; }) }); \u0026lt;/script\u0026gt; {{- end -}} 这个模板代码里使用到了我项目里的niconiconi.mp3、GalMenu.css、GalMenu.js这三个文件，有兴趣的可以自己把文件保存到自己网站里，mp3文件可以自己修改为其他的音频文件。\n修改assets.html文件 将主题的\\themes\\LoveIt\\layouts\\partials\\assets.html拷贝一份到\\layouts\\partials\\assets.html，在{{- partial \u0026quot;plugin/analytics.html\u0026quot; . -}}下添加如下内容：\n1 2 3 {{- /* 右键菜单 */ -}} \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{- partial \u0026#34;plugin/rightmenu.html\u0026#34; . -}} 搞定，这个功能就完成了。\n添加文章加密功能 将\\themes\\LoveIt\\layouts\\posts\\single.html拷贝到\\layouts\\posts\\single.html，打开拷贝后的文件，在{{- $params := .Scratch.Get \u0026quot;params\u0026quot; -}}的下一行添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 {{- $password := $params.password | default \u0026#34;\u0026#34; -}} {{- if ne $password \u0026#34;\u0026#34; -}} \u0026lt;script\u0026gt; (function(){ if({{ $password }}){ if (prompt(\u0026#39;请输入文章密码\u0026#39;) != {{ $password }}){ alert(\u0026#39;密码错误！\u0026#39;); if (history.length === 1) { window.opener = null; window.open(\u0026#39;\u0026#39;, \u0026#39;_self\u0026#39;); window.close(); } else { history.back(); } } } })(); \u0026lt;/script\u0026gt; {{- end -}} 之后只要在文章的头部加上password属性即可进行加密，只有输入了正确密码才能打开文章，否则会回退到之前的页面。用法如下：\n1 2 3 4 --- title: 随笔 password: test --- 添加GitHub Corner 将\\themes\\LoveIt\\layouts\\partials\\header.html拷贝到\\layouts\\partials\\header.html，打开拷贝后的文件，在\u0026lt;div class=\u0026quot;header-wrapper\u0026quot;\u0026gt;的下一行添加一个超链代码：\n1 \u0026lt;a href=\u0026#34;https://github.com/lewky\u0026#34; class=\u0026#34;github-corner\u0026#34; target=\u0026#34;_blank\u0026#34; title=\u0026#34;Follow me on GitHub\u0026#34; aria-label=\u0026#34;Follow me on GitHub\u0026#34;\u0026gt;\u0026lt;svg width=\u0026#34;3.5rem\u0026#34; height=\u0026#34;3.5rem\u0026#34; viewBox=\u0026#34;0 0 250 250\u0026#34; style=\u0026#34;fill:#70B7FD; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1);\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt;\u0026lt;path d=\u0026#34;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;path d=\u0026#34;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\u0026#34; fill=\u0026#34;currentColor\u0026#34; style=\u0026#34;transform-origin: 130px 106px;\u0026#34; class=\u0026#34;octo-arm\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;path d=\u0026#34;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\u0026#34; fill=\u0026#34;currentColor\u0026#34; class=\u0026#34;octo-body\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;/svg\u0026gt;\u0026lt;/a\u0026gt; 将上边的超链的href改为自己的GitHub地址，如果想调整图片大小，可以修改代码里的svg标签的width和height属性。\n然后是添加样式代码到_custom.scss里：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* Github Corner */ .github-corner:hover .octo-arm { animation: octocat-wave 560ms ease-in-out } @keyframes octocat-wave { 0%,100% { transform: rotate(0) } 20%,60% { transform: rotate(-25deg) } 40%,80% { transform: rotate(10deg) } } @media (max-width:500px) { .github-corner:hover .octo-arm { animation: none } .github-corner .octo-arm { animation: octocat-wave 560ms ease-in-out } } 下面是GitHub Corner的项目地址，一共有10种颜色样式，随便挑！\nGitHub Corners项目地址 页面下方添加拉姆雷姆快捷跳转 将\\themes\\LoveIt\\layouts\\_default\\baseof.html拷贝到\\layouts\\_default\\baseof.html，打开拷贝后的baseof.html，在{{- /* Load JavaScript scripts and CSS */ -}}的上面一行添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;div class=\u0026#34;sidebar_wo\u0026#34;\u0026gt; \u0026lt;div id=\u0026#34;leimu\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/b2t/leimuA.png\u0026#34; alt=\u0026#34;雷姆\u0026#34; onmouseover=\u0026#34;this.src=\u0026#39;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/b2t/leimuB.png\u0026#39;\u0026#34; onmouseout=\u0026#34;this.src=\u0026#39;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/b2t/leimuA.png\u0026#39;\u0026#34; title=\u0026#34;回到顶部\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;sidebar_wo\u0026#34; id=\u0026#34;lamu\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/b2t/lamuA.png\u0026#34; alt=\u0026#34;雷姆\u0026#34; onmouseover=\u0026#34;this.src=\u0026#39;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/b2t/lamuB.png\u0026#39;\u0026#34; onmouseout=\u0026#34;this.src=\u0026#39;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/b2t/lamuA.png\u0026#39;\u0026#34; title=\u0026#34;回到底部\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; 在_custom.scss里添加对应的css代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 /* 拉姆蕾姆回到顶部或底部按钮 */ .sidebar_wo { position:fixed; line-height:0; bottom:0; z-index:1000 } #leimu { left:0; -webkit-transition:all .3s ease-in-out; transition:all .3s ease-in-out; -webkit-transform:translate(-7px,7px); -ms-transform:translate(-7px,7px); transform:translate(-7px,7px) } #lamu { -webkit-transition:all .3s ease-in-out;transition:all .3s ease-in-out; -webkit-transform:translate(7px,7px); -ms-transform:translate(7px,7px); transform:translate(7px,7px); right:0 } #leimu:hover { -webkit-transform:translate(0,0); -ms-transform:translate(0,0); transform:translate(0,0) } #lamu:hover { -webkit-transform:translate(0,0); -ms-transform:translate(0,0); transform:translate(0,0) } .sidebar_wo img { cursor:pointer; } @media only screen and (max-width:1024px) { .sidebar_wo{display:none} } 最后在custom.js里添加如下代码，注意，要先引入jquery才有效果，具体细节请看前文：\n1 2 3 4 5 6 7 8 9 10 11 /* 拉姆蕾姆回到顶部或底部按钮 */ $(function() { $(\u0026#34;#lamu img\u0026#34;).eq(0).click(function() { $(\u0026#34;html,body\u0026#34;).animate({scrollTop:$(document).height()},800); return false; }); $(\u0026#34;#leimu img\u0026#34;).eq(0).click(function() { $(\u0026#34;html,body\u0026#34;).animate({scrollTop:0},800); return false; }); }); 添加首页头像挂件 这个功能分为四个部分：\n首页头像的动画特效从浮动改为旋转，为了适配挂件还稍微缩小了头像大小 添加头像挂件（都是b站的挂件） 点击头像一定次数后随机刷新头像 加载首页时随机刷新头像（该功能可禁用） 修改站点配置文件 在站点配置文件里找到你配置首页头像的变量avatarURL，在其下方添加几个新的变量，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 [params.home.profile] enable = true # 主页显示头像的 URL avatarURL = \u0026#34;/images/avatar.jpg\u0026#34; # 是否启用头像挂件 avatarPluginURL = \u0026#34;/images/avatar-plug/png/bilibili_105.png\u0026#34; # 是否启用头像挂件自动刷新 avatarPluginFlush = true # 点击频率，点击几次就换挂件 avatarPluginFrequency = 1 # 头像挂件总数 avatarPluginCount = 23 # 头像挂件格式：png, webp avatarPluginSuffix = \u0026#34;webp\u0026#34; 如果你有自己的图床，还可以配置一个给头像挂件使用的图床地址，如下：\n1 2 3 4 5 # 参数 [params] # 图床变量，末尾不需要加/ #cdnPrefix = \u0026#34;\u0026#34; cdnPrefix = \u0026#34;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master\u0026#34; 这个变量不设置也没关系，不会影响挂件的功能。\n修改模板文件profile.html 将\\themes\\LoveIt\\layouts\\partials\\home\\profile.html拷贝到\\layouts\\partials\\home\\profile.html，打开拷贝后的文件，找到下面的代码：\n1 2 3 \u0026lt;a href=\u0026#34;{{ $url }}\u0026#34;{{ with .Title | default .Name }} title=\u0026#34;{{ . }}\u0026#34;{{ end }}{{ if (urls.Parse $url).Host }} rel=\u0026#34;noopener noreffer\u0026#34; target=\u0026#34;_blank\u0026#34;{{ end }}\u0026gt; {{- dict \u0026#34;Src\u0026#34; $avatar | partial \u0026#34;plugin/image.html\u0026#34; -}} \u0026lt;/a\u0026gt; 这是渲染首页头像的代码，将这段代码改成如下内容：\n1 2 3 4 5 6 7 8 9 10 {{- if $profile.avatarPluginURL -}} \u0026lt;img class=\u0026#34;site-avatar-plug-bilibili\u0026#34; onerror=\u0026#34;this.src=\u0026#39;{{ $profile.avatarPluginURL }}\u0026#39;\u0026#34; /\u0026gt; \u0026lt;a href=\u0026#34;javascript:void(0);\u0026#34;{{ with .Title | default .Name }} title=\u0026#34;Please click me~~\u0026#34;{{ end }}{{ if (urls.Parse $url).Host }} rel=\u0026#34;noopener noreffer\u0026#34; target=\u0026#34;_blank\u0026#34;{{ end }}\u0026gt; {{- dict \u0026#34;Src\u0026#34; $avatar \u0026#34;Title\u0026#34; \u0026#34;Please click me~~\u0026#34; | partial \u0026#34;plugin/image.html\u0026#34; -}} \u0026lt;/a\u0026gt; {{- else -}} \u0026lt;a href=\u0026#34;{{ $url }}\u0026#34;{{ with .Title | default .Name }} title=\u0026#34;{{ . }}\u0026#34;{{ end }}{{ if (urls.Parse $url).Host }} rel=\u0026#34;noopener noreffer\u0026#34; target=\u0026#34;_blank\u0026#34;{{ end }}\u0026gt; {{- dict \u0026#34;Src\u0026#34; $avatar | partial \u0026#34;plugin/image.html\u0026#34; -}} \u0026lt;/a\u0026gt; {{- end -}} 修改模板文件assets.html 打开\\layouts\\partials\\assets.html，在你引入的jquery的下面添加如下代码，不知道怎么引入jquery的请看前文：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 \u0026lt;!-- 头像挂件 --\u0026gt; {{- if .IsHome -}} \u0026lt;script\u0026gt; {{- $profile := .Site.Params.home.profile -}} {{- $avatarPlugin := $profile.avatarPluginURL -}} {{- $avatarPluginFrequency := $profile.avatarPluginFrequency -}} {{- $avatarPluginCount := $profile.avatarPluginCount -}} {{- $avatarPluginSuffix := $profile.avatarPluginSuffix -}} {{- $cdnPrefix := .Site.Params.cdnPrefix -}} {{- if $avatarPlugin -}} /* 头像挂件自动刷新 */ {{- if $profile.avatarPluginFlush -}} $(function () { $(\u0026#34;.site-avatar-plug-bilibili\u0026#34;).attr(\u0026#34;src\u0026#34;, \u0026#34;{{ $cdnPrefix }}/images/avatar-plug/{{ $avatarPluginSuffix }}/bilibili_\u0026#34; + (~~({{ $avatarPluginCount }}*Math.random())+1) + \u0026#34;.{{ $avatarPluginSuffix }}\u0026#34;); }); {{- else -}} $(function () { $(\u0026#34;.site-avatar-plug-bilibili\u0026#34;).attr(\u0026#34;src\u0026#34;, \u0026#34;{{ $cdnPrefix }}{{ $avatarPlugin }}\u0026#34;); }); {{- end -}} /* 点击头像更换b站挂件 */ var avatar_plug = 0; var avatar_click = 1; jQuery(document).ready(function($) { /* 点击频率，点击几次就换挂件 */ var frequency = {{ $avatarPluginFrequency }}; /* 头像挂件总数 */ var plug_count = {{ $avatarPluginCount }}; $(\u0026#34;div.home-avatar a\u0026#34;).click(function(e) { if (avatar_click % frequency === 0) { avatar_plug ++; $(\u0026#34;.site-avatar-plug-bilibili\u0026#34;).attr(\u0026#34;src\u0026#34;, \u0026#34;{{ $cdnPrefix }}/images/avatar-plug/{{ $avatarPluginSuffix }}/bilibili_\u0026#34; + avatar_plug + \u0026#34;.{{ $avatarPluginSuffix }}\u0026#34;); }\tif (avatar_plug === plug_count) { avatar_plug = 0; } $(\u0026#34;div.home-avatar a\u0026#34;).attr(\u0026#34;alt\u0026#34;,\u0026#34;再点击\u0026#34; + (frequency - avatar_click % frequency) + \u0026#34;次头像试试看~~\u0026#34;); avatar_click ++; }); }); {{- end -}} \u0026lt;/script\u0026gt; {{- end -}} 添加css代码 在自定义的_custom.scss里添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 /* 首页头像 */ /* bilibili头像挂件 */ img.site-avatar-plug-bilibili { position: absolute; display: block; margin: -2rem !important; padding: 0; width: 9rem !important; max-width: 168px; height: auto; box-shadow: none !important; z-index: 1; pointer-events: none; } /* 头像旋转 */ .home .home-profile .home-avatar img { width: 5rem; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ease-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out; \u0026amp;:hover { /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg); } } /* Z 轴旋转动画 */ @-webkit-keyframes play { 0% { -webkit-transform: rotateZ(0deg); } 100% { -webkit-transform: rotateZ(-360deg); } } @-moz-keyframes play { 0% { -moz-transform: rotateZ(0deg); } 100% { -moz-transform: rotateZ(-360deg); } } @keyframes play { 0% { transform: rotateZ(0deg); } 100% { transform: rotateZ(-360deg); } } 头像和挂件的样式代码可能根据个人的定制化而需要微调下位置之类的。至于头像挂件这些图片请去我的站点里下载下来，下面是具体地址： https://github.com/lewky/lewky.github.io/tree/master/images/avatar-plug\n参考链接 DesertsP/Valine-Admin Hexo主题使用Valine-Admin管理评论和评论提醒 最新版基于Leancloud或javascript推送Valine评论到QQ 优雅解决LeanCloud流控问题 cron-job.org Qmsg酱 hexo中添加鼠标右键功能 在搭配Volantis主题的hexo博客上使用waline ","permalink":"https://lewky.cn/posts/hugo-3.1.html/","tags":["Hugo","LoveIt主题","主题美化","功能增强"],"title":"Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章"},{"categories":["Java"],"contents":"泛型（Generic） 泛型：把类型明确的工作推迟到创建对象或调用方法时再明确的特殊类型。\n参数化类型：把类型当作参数来传递，这意味着参数化类型不能是基本数据类型，需要用对应的包装类来代替。\n相关概念：\n● ArrayList\u0026lt;E\u0026gt;中的E是类型参数变量（typeVariable，也叫泛型参数），除了E之外，也可以是任意标识符。其实就是一个变量名，常用的一般有E（Element）、T（Type）、K（Key）、V（Value）等。\n● ArrayList\u0026lt;Integer\u0026gt;中的Integer称为实际类型参数（ActualTypeArgument），上面的E相当于形参，这里的Integer相当于实参\n● ArrayList\u0026lt;E\u0026gt;整个被称为泛型类型（泛型类，GenericType）\n● ArrayList\u0026lt;Integer\u0026gt;整个被称为参数化的类型（ParameterizedType）\n● ArrayList被称为原生类型（RawType）\n● 泛型类中允许定义泛型内部类，那么外部泛型类的原生类型，被称为内部泛型类的拥有者类型（OwnerType)\n泛型的好处 ● 泛型的本质是为了参数化类型，在不创建新类型的情况下，通过泛型指定的不同类型来限制形参的具体类型，以此提高代码的复用性。\n● 安全性。泛型可以在编译时检查类型安全，避免在运行时发生类转换异常ClassCastException。\n● 可读性，代码更加简洁。泛型会进行隐式类型转换，比如在使用集合时，无需进行强制类型转换。比如遍历一个指定了泛型的集合时，就可以用增强for来进行遍历。\n泛型类、泛型方法 只有声明了泛型参数的类才是泛型类（泛型接口同理），只有声明了泛型参数的方法才是泛型方法。也就是说，泛型类中使用了泛型的方法并不是泛型方法，泛型类声明的泛型参数和泛型方法声明的泛型参数可以重名，但是二者并不存在任何关系。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 // 泛型类 class TestGeneric\u0026lt;T\u0026gt; { // 不是泛型方法 public T getT1(T t) { return t; } // 泛型方法，这里的T和泛型类的T完全没有关系 public \u0026lt;T\u0026gt; T getT2(T t) { return t; } } // 不是泛型类 class TestGeneric2\u0026lt;Integer\u0026gt; { // 不是泛型方法 public Integer getT1(Integer t) { return t; } // 泛型方法 public \u0026lt;T\u0026gt; T getT2(T t) { return t; } } 泛型是在类实例化或者方法调用时才明确类型的：\n● 对于泛型类的泛型参数，需要在类实例化时才能明确类型；\n● 对于泛型方法的泛型参数，需要在方法调用时才能明确类型。\n如果要继承泛型类，写法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 定义一个泛型类 class TestGeneric\u0026lt;T\u0026gt; { } // 定义一个参数化类型 class TestChild extends TestGeneric\u0026lt;Integer\u0026gt; { } // 定义一个泛型类子类，子类必须声明泛型参数，否则编译报错 class TestChild2\u0026lt;T\u0026gt; extends TestGeneric\u0026lt;T\u0026gt; { } 实现泛型接口的写法也是同理。\n泛型原理：类型擦除 Java的泛型是伪泛型。泛型是提供给javac编译器使用的，在编译期间，泛型信息会被擦除掉，生成的class文件中将不再带有泛型信息。但是泛型擦除并不是完全擦除掉所有的泛型信息，参数化类型的泛型信息（相当于元数据）会被保留下来，可以通过反射获取到。\nJava的泛型擦除留下了什么？ Java是向前兼容的，泛型在Java5引入，需要兼容Java5之前的版本，这也是Java泛型需要类型擦除的原因之一。\n在编译期，ArrayList\u0026lt;Integer\u0026gt;和ArrayList对于编译器是两个不同的类型；但是经过了泛型擦除后，在运行期，对于JVM来说就是一样的类型。此外，编译期会在使用泛型的地方自动生成类型转换的字节码，所以在使用泛型时无需进行强制类型转换。\n泛型擦除导致的多态冲突 由于泛型擦除，会导致运行期的多态冲突。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class TestGeneric\u0026lt;T\u0026gt; { public T test(T t) { return t; } } class TestChild extends TestGeneric\u0026lt;Integer\u0026gt; { @Override public Integer test(Integer t) { return t; } } @Override表明子类重写了父类的方法，但实际上，经过泛型擦除之后，父类的test方法变成如下：\n1 2 3 public Object test(Object t) { return t; } 如果是在非泛型类的继承关系中，其实这样并不是子类重写了父类的方法，而是子类重载了这个test方法。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Animal { public Object test(Object t) { return t; } } class Cat extends Animal { // 编译出错，编译器认为这是方法重载而非重写，不能使用@Override @Override public Integer test(Integer t) { // The method test(Integer) of type Cat must override or implement a supertype method return t; } } 本意是想要重写父类方法，结果经过泛型擦除后实际上是方法重载。为了解决这个泛型擦除在继承关系中带来的多态冲突，编译器在生成泛型类子类的字节码时会生成桥方法（Bridge Method），用以桥接原来的方法。如果去看泛型类的子类字节码文件，会发现每一个使用了泛型的被重写的父类方法都多出来一个对应的被bridge修饰的桥方法。\n对于上述的TestChild类，经过编译之后相当于变成如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class TestChild extends TestGeneric\u0026lt;Integer\u0026gt; { // 原本的@Override注解被移除，实际上是方法重载 public Integer test(Integer t) { return t; } // 编译器生成的桥方法，重写了父类的方法，并直接调用子类里重载的方法 // 这样就可以实现泛型类在继承体系中的运行时多态 public Object test(Object t) { return test((Integer)t); } } Java泛型中的桥方法(Bridge Method) 泛型与反射 泛型的类型检查只是在编译期生效，所以可以在运行期通过反射往一个泛型集合中加入限制类型以外的元素。\n由于泛型擦除的原因，虽然无法在运行期通过反射动态获取一个泛型类的实际类型，但依然可以用反射来获取参数化类型的泛型信息。注意，泛型类和参数化类型不是一个东西。\nJava中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型？ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class TestGeneric\u0026lt;T\u0026gt; { public TestInner child; public static void main(final String[] args) { final TestChild testChild = new TestChild(); testChild.child = testChild.new TestInner(); testChild.getArray(testChild, 3); System.out.println(\u0026#34;===============================\u0026#34;); testChild.getArray(testChild.child, 3); } class InnerGeneric\u0026lt;E\u0026gt; { } class TestInner extends InnerGeneric\u0026lt;Integer\u0026gt; { } } class TestChild extends TestGeneric\u0026lt;Integer\u0026gt; { public Integer[] getArray(final Object obj, final int length) { final ParameterizedType type = (ParameterizedType) obj.getClass().getGenericSuperclass(); final Class \u0026lt;?\u0026gt; clazz = (Class \u0026lt;?\u0026gt;) type.getActualTypeArguments()[0]; System.out.println(\u0026#34;Class: \u0026#34; + obj.getClass().getName()); System.out.println(\u0026#34;ParameterizedType: \u0026#34; + type.getTypeName()); System.out.println(\u0026#34;RawType: \u0026#34; + type.getRawType()); System.out.println(\u0026#34;OwnerType: \u0026#34; + type.getOwnerType()); System.out.println(\u0026#34;ActualTypeArguments\u0026#39; number: \u0026#34; + type.getActualTypeArguments().length); System.out.println(\u0026#34;ActualTypeArgument Class: \u0026#34; + clazz.getName()); return (Integer[])Array.newInstance(clazz, length); } } 运行结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 Class: test.TestChild ParameterizedType: test.TestGeneric\u0026lt;java.lang.Integer\u0026gt; RawType: class test.TestGeneric OwnerType: null ActualTypeArguments\u0026#39; number: 1 ActualTypeArgument Class: java.lang.Integer =============================== Class: test.TestGeneric$TestInner ParameterizedType: test.TestGeneric\u0026lt;T\u0026gt;.InnerGeneric\u0026lt;java.lang.Integer\u0026gt; RawType: class test.TestGeneric$InnerGeneric OwnerType: test.TestGeneric\u0026lt;T\u0026gt; ActualTypeArguments\u0026#39; number: 1 ActualTypeArgument Class: java.lang.Integer 如果理解了前文提及的相关概念，那么自然也能理解这些泛型反射的方法。\n泛型集合 泛型经常被用于集合，一个泛型集合不允许被加入指定类型以外的对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void test() { List\u0026lt;Dog\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(new Dog()); // 编译错误，不能添加指定类型以外的对象 list.add(new Cat()); // The method add(Dog) in the type List\u0026lt;Dog\u0026gt; is not applicable for the arguments (Cat) Animal animal = new Dog(); // 编译错误，虽然Animal是Dog的父类型，但依然不能添加进去集合里，因为Animal类型不一定能安全地转型为Dog类型。 list.add(animal); // The method add(Dog) in the type List\u0026lt;Dog\u0026gt; is not applicable for the arguments (Animal) BigDog bigDog = new BigDog(); // 因为BigDog是Dog的子类型，一定可以转型为Dog类型，所以允许加入集合 list.add(bigDog); // ok } 因为泛型集合在读取元素或者添加元素时，会有类型转换操作（在源码底层里进行的强制类型转换），如果不能把一个元素安全地进行类型转换，那就不能被添加到集合中。\n此外，作用于编译期的类型检查是针对于引用类型的，跟引用类型指向的实际对象并无关系。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public void test() { // 指向一个泛型集合 List list1 = new ArrayList\u0026lt;Dog\u0026gt;(); list1.add(new Cat()); // ok // 指向一个非泛型集合 List\u0026lt;Dog\u0026gt; list2 = new ArrayList(); // 编译错误 list2.add(new Cat()); // The method add(Dog) in the type List\u0026lt;Dog\u0026gt; is not applicable for the arguments (Cat) // 指向一个泛型集合 List\u0026lt;Dog\u0026gt; list3 = new ArrayList\u0026lt;\u0026gt;(); // 编译错误 list3.add(new Cat()); // The method add(Dog) in the type List\u0026lt;Dog\u0026gt; is not applicable for the arguments (Cat) } 泛型通配符 泛型参数除了可以是Java标识符之外，还可以指定为?无界通配符，用以表示不确定的Java类型。\n但是?不可用于声明泛型，只能用于使用泛型的场合。因为?并不是合法的Java标识符，不可用于声明，只能作为实际类型参数来使用，效果相当于Object。通配符类型同样无法实例化。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // 不能用通配符声明泛型类 class TestGeneric\u0026lt;?\u0026gt; { // Syntax error on token \u0026#34;?\u0026#34;, Identifier expected // 不能用通配符声明泛型方法 public \u0026lt;?\u0026gt; void test1(final ? test) { // Syntax error on token \u0026#34;?\u0026#34;, byte expected } public void test2(final List\u0026lt;?\u0026gt; test) { // ok // 不能实例化 ? obj = new ?(); // Syntax error on token \u0026#34;?\u0026#34;, invalid ClassType // 不能实例化 List\u0026lt;?\u0026gt; list = new ArrayList\u0026lt;?\u0026gt;(); // Cannot instantiate the type ArrayList\u0026lt;?\u0026gt; } } 无界通配符\u0026lt;?\u0026gt; 泛型使用最多的场景是集合，然而对于泛型集合来说，每个集合之间都是完全独立的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Animal {} class Cat extends Animal {} class Dog extends Animal {} class BigDog extends Dog {} class TestGeneric { public static void main(final String[] args) { List\u0026lt;Dog\u0026gt; dogs = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Animal\u0026gt; animals = new ArrayList\u0026lt;\u0026gt;(); // 编译错误 dogs = animals; // Type mismatch: cannot convert from List\u0026lt;Animal\u0026gt; to List\u0026lt;Dog\u0026gt; // 编译错误 animals = dogs; // Type mismatch: cannot convert from List\u0026lt;Dog\u0026gt; to List\u0026lt;Animal\u0026gt; // 在运行期这两个泛型集合的类型是同一个类对象 System.out.println(dogs.getClass() == animals.getClass()); // true // 不能添加Animal对象 dogs.add(new Animal()); // The method add(Dog) in the type List\u0026lt;Dog\u0026gt; is not applicable for the arguments (Animal) dogs.add(new Dog()); // ok animals.add(new Animal()); // ok animals.add(new Dog()); // ok } } 可以看到，虽然Dog是Animal的子类，但是List\u0026lt;Animal\u0026gt;和List\u0026lt;Dog\u0026gt;这两个集合之间并不存在任何关系，不能把一个List\u0026lt;Dog\u0026gt;对象直接赋值给一个List\u0026lt;Animal\u0026gt;引用。于是这就会引发一个问题，如果一个方法的参数是泛型集合，就很容易出现类型不匹配的情况。为了避免这种情况，也更有利于代码的复用和简洁，就有了无界通配符\u0026lt;?\u0026gt;，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class TestGeneric { public static void test1(final List\u0026lt;Animal\u0026gt; list) { } public static void test2(final List\u0026lt;?\u0026gt; list) { } public static void main(final String[] args) { List\u0026lt;Dog\u0026gt; dogs = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;Animal\u0026gt; animals = new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;?\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // 编译错误，无法调用 test1(dogs); // The method test1(List\u0026lt;Animal\u0026gt;) in the type TestGeneric is not applicable for the arguments (List\u0026lt;Dog\u0026gt;) test1(animals); // ok // 编译错误，无法调用 test1(list); // The method test1(List\u0026lt;Animal\u0026gt;) in the type TestGeneric is not applicable for the arguments (List\u0026lt;capture#2-of ?\u0026gt;) test2(dogs); // ok test2(animals); // ok test2(list); // ok dogs.add(new Dog());\t// ok // 编译错误 list.add(new Animal()); // The method add(capture#2-of ?) in the type List\u0026lt;capture#2-of ?\u0026gt; is not applicable for the arguments (Animal) // 编译错误 list.add(new Dog()); // The method add(capture#3-of ?) in the type List\u0026lt;capture#3-of ?\u0026gt; is not applicable for the arguments (Dog) list.add(null); // ok list = dogs; // 将泛型通配符集合赋值为普通的泛型集合后，依然不能添加null以外的元素 list.add(new Dog()); // The method add(capture#6-of ?) in the type List\u0026lt;capture#6-of ?\u0026gt; is not applicable for the arguments (Dog) // 泛型通配符集合中读取的元素为Object类型 Object object = list.get(0); // 将读取的元素强转为原本的类型 Dog dog = (Dog) list.get(0); } } 可以发现，泛型通配符集合虽然被任意的泛型集合对象所赋值，但是却不能往这个集合里添加null以外的任何元素，只能读取这个集合的元素，并且被读取的元素都是Object类型。\n这是因为经过泛型擦除后，通配符被擦除成了Object类型。也就是说，可以把一个无界通配符\u0026lt;?\u0026gt;看成是上界通配符\u0026lt;? extends Object\u0026gt;。\n上界通配符\u0026lt;? extends T\u0026gt; 使用上界通配符可以将实际类型参数限制为指定的类型或者指定类型的子类，经过泛型擦除后，上界通配符被擦除成了指定的类型，即泛型擦除会保留上界。\n需要注意的是，这里的上界虽然用了extends关键字，但实际上和类的继承不太一样。对于泛型来说，extends之后的具体类型可以是类，也可以是接口。（也就是说如果上界指定的是一个接口，也必须用extends关键字，而不是implements）\n1 2 3 4 5 public void test() { List\u0026lt;? extends Serializable\u0026gt; list1; // ok // 编译错误 List\u0026lt;? implements Serializable\u0026gt; list2; // Incorrect number of arguments for type List\u0026lt;E\u0026gt;; it cannot be parameterized with arguments \u0026lt;?, Serializable\u0026gt; } 泛型参数T也可以指定上界，但只能用于声明泛型的场景，这是和通配符的一个重要区别之一：\n1 2 3 4 5 6 7 // 用T声明一个有上界的泛型方法 public \u0026lt;T extends Serializable\u0026gt; void test(T t) { // 编译错误 List\u0026lt;T extends Serializable\u0026gt; list1; // Incorrect number of arguments for type List\u0026lt;E\u0026gt;; it cannot be parameterized with arguments \u0026lt;T, Serializable\u0026gt; List\u0026lt;? extends Serializable\u0026gt; list2; // ok } 下界通配符\u0026lt;? super T\u0026gt; 使用下界通配符可以将实际类型参数限制为指定的类型或者指定类型的父类，经过泛型擦除后，下界通配符会被擦除成Object类型，但是在编译期不允许传入非指定类型或其父类以外的类型。\n泛型参数T不可以指定下界，这是和通配符的另一个区别：\n1 2 3 4 // 编译错误 public \u0026lt;T super Serializable\u0026gt; void test(T t) { // Syntax error on token \u0026#34;super\u0026#34;, , expected } PECS原则 当泛型集合使用了有边界的通配符时，存在PECS原则（Producer Extends Consumer Super），如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class TestGeneric { public static \u0026lt;T\u0026gt; void main(String[] args) { List\u0026lt;Dog\u0026gt; dogs = new ArrayList\u0026lt;\u0026gt;(); dogs.add(new Dog()); // 上界通配符泛型集合 List\u0026lt;? extends Animal\u0026gt; list1 = dogs; /* 往上界通配符泛型集合添加元素 */ // 编译错误，不能加入null以外的任意类型对象 list1.add(new Dog()); // The method add(capture#1-of ? extends Animal) in the type List\u0026lt;capture#1-of ? extends Animal\u0026gt; is not applicable for the arguments (Dog) // 编译错误，不能加入null以外的任意类型对象 list1.add(new Animal()); // The method add(capture#2-of ? extends Animal) in the type List\u0026lt;capture#2-of ? extends Animal\u0026gt; is not applicable for the arguments (Animal) list1.add(null); // ok /* 从上界通配符泛型集合获取元素 */ // 获取的元素默认是上界类型 Animal animal = list1.get(0); // ok // 强转为原来的类型 Dog dog = (Dog) list1.get(0); // ok // ---------------------------- // 下界通配符泛型集合 List\u0026lt;? super Dog\u0026gt; list2 = new ArrayList\u0026lt;\u0026gt;(); /* 往下界通配符泛型集合添加元素 */ // 编译错误，只能加入下界类型及其子类型 list2.add(new Animal()); // The method add(capture#6-of ? super Dog) in the type List\u0026lt;capture#6-of ? super Dog\u0026gt; is not applicable for the arguments (Animal) list2.add(new Dog()); // ok list2.add(new BigDog()); // ok list2.add(null); // ok /* 从下界通配符泛型集合获取元素 */ // 获取的元素默认是Object类型 Object object = list2.get(0); // ok // 强转为原来的类型 dog = (Dog) list2.get(0); // ok BigDog bigDog = (BigDog) list2.get(1); // ok } } 对于上界通配符的泛型集合，不允许添加null以外的任何类型对象，因为泛型擦除导致JVM无法确定该集合究竟存放了什么类型的元素，只知道集合里的元素都是上界类型或者上界类型的子类型，这意味着无论被添加的元素是哪种类型，都无法确保安全的类型转换（比如集合里可能存的是Dog类型或者Animal类型，而被添加的类型如果是Cat类型就会发生类转型异常），所以会拒绝添加null以外的任意元素。而null是一个特殊的值，它可以转型为任意类型，因此能成功添加到上界通配符的泛型集合中。\n但是这种集合可以往外读取元素，因为这些元素可以被JVM自动转型为上界类型。这种只允许读取，不允许写入的特性，被称为Producer Extends，相当于生产者的概念。\n对于下界通配符的泛型集合，只能加入下界类型及其子类型，因为泛型擦除导致JVM只知道该集合中存放的都是下界类型或者下界类型的父类型，而下界类型及其子类型必然可以安全转型为下界类型，所以可以添加到该集合中。\n但是这种集合只允许往外读取Object类型的元素，因为无法确定集合中的元素的具体类型，出于类型安全就只能作为Object类型被读取。如果将读取的元素进行强制类型转换，就要注意是否会发生类转换异常。这种只允许写入，不允许读取为原本类型的特性，被称为Consumer Super，相当于消费者的概念。\n总结：\n● 如果要从集合中读取类型T的数据，并且不能写入，可以使用? extends T通配符；(Producer Extends)\n● 如果要从集合中写入类型T的数据，并且不需要读取，可以使用? super T通配符；(Consumer Super)\n● 如果既要存又要取，那么就不要使用任何通配符。\n在实际应用中，一般不直接对通配符泛型集合进行编辑操作，而是作为一个引用类型（可以是局部变量，或者是作为方法参数），并将另一个泛型集合对象赋值给该引用。\n泛型的多重限定 泛型允许使用\u0026amp;进行多重限定，即\u0026lt;T extends A \u0026amp; B\u0026gt;，此时泛型的具体类型必须是这两个限定类型的最小范围或者共同子类型。并且，\u0026amp;的右值必须是接口，左值则没有这个要求。\n此外，通配符\u0026lt;?\u0026gt;不可以使用多重限定。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public \u0026lt;T extends List \u0026amp; Collection\u0026gt; void test1(T t) { // ok } // 编译错误，Animal不是接口 public \u0026lt;T extends Dog \u0026amp; Animal\u0026gt; void test2(T t) { // The type Animal is not an interface; it cannot be specified as a bounded parameter } // 编译错误 public \u0026lt;? extends List \u0026amp; Collection\u0026gt; void test3(T t) { // Syntax error on token \u0026#34;?\u0026#34;, Identifier expected } 经过泛型擦除后，在字节码文件中多重限定会被擦除为\u0026amp;的左值类型，但在编译期时类型检查依然限定具体类型必须是这两个限定类型的最小范围或者共同子类型。\n\u0026lt;T\u0026gt;和\u0026lt;?\u0026gt;的区别 ● \u0026lt;T\u0026gt;可以用于声明泛型，也可用于使用泛型的场合；\u0026lt;?\u0026gt;不可用于声明泛型，只能用于使用泛型的场合。\n● \u0026lt;T\u0026gt;可以指定上界，但此时只能用于声明泛型，\u0026lt;T\u0026gt;不可以指定下界；\u0026lt;?\u0026gt;可指定上下界，且只能用于使用泛型的场合。\n● \u0026lt;T\u0026gt;用于确保泛型参数的一致性，比如一个方法的参数是多个泛型T，那么调用方法传参时都必须是相同的类型；但如果一个方法的参数是多个泛型通配符?，则调用时传参不需要保持相同的类型，因为?表示随机类型。\n● \u0026lt;T\u0026gt;可以使用多重限定，而\u0026lt;?\u0026gt;不可以。\n● \u0026lt;T\u0026gt;无法创建参数化类型的数组，但\u0026lt;?\u0026gt;可以。\n泛型数组 跟前面的泛型集合特性一样，只是把泛型集合塞到一个数组中而已。但不同的是，无法实例化一个参数化类型的数组对象，但可以实例化一个通配符类型的数组对象。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public void test() { List\u0026lt;String\u0026gt;[] array1 = new ArrayList[10]; // ok array1[0].add(\u0026#34;test\u0026#34;); // ok // 编译错误 List\u0026lt;String\u0026gt;[] array2 = new ArrayList\u0026lt;String\u0026gt;[10]; // Cannot create a generic array of ArrayList\u0026lt;String\u0026gt; List\u0026lt;?\u0026gt;[] array3 = new ArrayList\u0026lt;?\u0026gt;[10]; // ok array3[0] = new ArrayList\u0026lt;String\u0026gt;(); // ok // 编译错误 array3[0].add(\u0026#34;test\u0026#34;); // The method add(capture#2-of ?) in the type List\u0026lt;capture#2-of ?\u0026gt; is not applicable for the arguments (String) array3[0].add(null); // ok } 不能使用泛型的场景 基本类型不能使用泛型 泛型的类型参数要求是Object的子类，所以不能使用基本数据类型，只能使用对应的包装类。\n1 2 3 List\u0026lt;int\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // Syntax error, insert \u0026#34;Dimensions\u0026#34; to complete ReferenceType List\u0026lt;Integer\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); // ok 泛型类型无法直接实例化 由于泛型擦除的原因，运行期泛型信息是不可见的，因此不能直接实例化。\n1 2 3 4 // 运行期不存在这个泛型E，所以无法实例化 public \u0026lt;E\u0026gt; void test(E e) { E e2 = new E(); // Cannot instantiate the type E } 泛型类的泛型参数不能作为静态变量，也不能作为静态方法的返回值 泛型类在类实例化时才明确类型，而静态类型是在类加载时就初始化的，此时对于泛型类是无法明确泛型的具体类型的，所以泛型类的泛型参数不能作为静态变量。也就是说，泛型类的泛型参数默认就是非静态的。\n但是，对于泛型方法，则可以被定义为静态的。原因是泛型方法在方法调用时明确类型，与类实例化无关，所以允许定义为静态的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class TestGeneric\u0026lt;T\u0026gt; { T t1; // ok static T t2; // Cannot make a static reference to the non-static type T static { T t3; // Cannot make a static reference to the non-static type T } public static T getT(T t) { // Cannot make a static reference to the non-static type T return t; } public static \u0026lt;E\u0026gt; E getE(E e) { // ok return e; } } 无法进行 instanceof 判断 Java的泛型是伪泛型，在编译期会被擦除，运行的字节码中不存在泛型，所以下面的判断条件无法进行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class TestGeneric\u0026lt;T\u0026gt; { public void test(ArrayList\u0026lt;T\u0026gt; list) { // Cannot perform instanceof check against parameterized type ArrayList\u0026lt;Integer\u0026gt;. // Use the form ArrayList\u0026lt;?\u0026gt; instead since further generic type information will be erased at runtime if (list instanceof ArrayList\u0026lt;Integer\u0026gt;) { } // 编译报错 if (list instanceof ArrayList\u0026lt;? super Animal\u0026gt;) { } // 编译报错 if (list instanceof ArrayList\u0026lt;? extends Animal\u0026gt;) { } } } 但是泛型的无界通配符\u0026lt;?\u0026gt;可以进行instanceof判断，且只有无界通配符才可以用这个关键字判断，如果是有界通配符依然会编译报错。\n因为无界通配符类型的集合对象意味着可以是任意类型的集合，对于JVM来说都是同一个集合类型,无需具体区分是哪一种泛型集合，所以允许无界通配符使用instanceof进行判断。\n无法创建参数化类型的数组 1 2 3 4 public void test() { // 编译错误 List\u0026lt;String\u0026gt;[] array = new ArrayList\u0026lt;String\u0026gt;[10]; // Cannot create a generic array of ArrayList\u0026lt;String\u0026gt; } 因为在运行期泛型集合对于JVM来说都是同一种类型，这意味着对于一个泛型集合数组对象来说，无论放入的是ArrayList\u0026lt;String\u0026gt;还是ArrayList\u0026lt;Integer\u0026gt;都是一样的。这样就会和本身泛型集合数组的定义相矛盾，比如原本声明的是一个List\u0026lt;String\u0026gt;[]。为了避免发生这种逻辑错误，所以不允许创建参数化类型的数组。\n但是可以创建通配符类型的数据，因为通配符类型是一个随机的类型，不会发生上述的自相矛盾：\n1 2 3 public void test() { List\u0026lt;?\u0026gt;[] array = new ArrayList\u0026lt;?\u0026gt;[10]; // ok } 不能直接或者间接扩展Throwable 1 2 3 4 5 // 不能间接地扩展 Throwable class IndirectException\u0026lt;T\u0026gt; extends Exception {} // The generic class IndirectException\u0026lt;T\u0026gt; may not subclass java.lang.Throwable // 不能直接地扩展 Throwable class DirectException\u0026lt;T\u0026gt; extends Throwable {} // The generic class DirectException\u0026lt;T\u0026gt; may not subclass java.lang.Throwable 因为异常类在进行捕获时需要明确类型，在运行期JVM无法获取泛型异常的类型：\n1 2 3 4 5 try { } catch (IndirectException\u0026lt;T\u0026gt; | DirectException\u0026lt;T\u0026gt; e) { // 类型不确定，无法处理具体的异常逻辑 } 但是可以抛出一个不确定的异常类型：\n1 2 3 4 5 6 7 8 9 10 11 12 class TestGeneric\u0026lt;T extends Exception\u0026gt; { // ok public void test1() throws T { } // ok public \u0026lt;E extends Exception\u0026gt; void test() throws E { } } 泛型擦除后相同参数签名的方法不能重载 由于泛型擦除的原因，以下方法不能重载且会编译报错\n1 2 public void test(List\u0026lt;Integer\u0026gt; list) {} public void test(List\u0026lt;Long\u0026gt; list) {} 一道笔试题 如何使用泛型实现LRU缓存？\nLRU就是Least Recently Used的缩写，即最近最少使用。JAVA提供的LinkedHashMap可以拿来实现LRU缓存的功能，除了可以设定排序的模式（按照访问排序还是按照插入排序），还可以重写删除最旧键值对的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class LRUCache\u0026lt;K, V\u0026gt; extends LinkedHashMap\u0026lt;K, V\u0026gt; { private int size; public LRUCache(int size) { // 16是初始化容量，0.75是负载因子，true表示按照访问排序 super(16, (float) 0.75, true); this.size = size; } @Override // 该方法会在`put`和`putAll`插入元素之后自行调用，返回true表示应该删除最旧的元素。 protected boolean removeEldestEntry(java.util.Map.Entry\u0026lt;K, V\u0026gt; eldest) { return size() \u0026gt; size; } } 参考链接 九、泛型 Java泛型中的PECS原则 万字长文详解Java泛型 什么情况下不能使用 Java 泛型 什么叫泛型？有什么作用？ 使用泛型实现（LRU）缓存 ","permalink":"https://lewky.cn/posts/java-generic.html/","tags":["Java"],"title":"Java - 泛型"},{"categories":["杂谈"],"contents":"PlantUML PlantUML是一个开源项目，可以用来快速生成各种UML图，官方文档：https://plantuml.com/zh/\n可以通过官方提供的工具在线生成对应的类图，本文只介绍PlantUML类图的部分常用语法。\nUML类图关系 类图关系 符号 依赖 .. 单向关联 \u0026lt;-- 双向关联 --或\u0026lt;--\u0026gt; 聚合 0-- 组合 *-- 泛化 `\u0026lt; 实现 `\u0026lt; 箭头方向可以在左边，也可以在右边。 --表示纵向的实线，-表示横向的实线。 ..表示纵向的虚线，-表示横向的虚线。 在符号两侧可以用\u0026quot;\u0026quot;来添加对元素的说明。 在关系末尾可以用:来添加对关系的说明。 1 2 3 4 5 6 7 8 9 @startuml Class01 \u0026#34;1\u0026#34; *-- \u0026#34;many\u0026#34; Class02 : contains Class03 o-- Class04 : aggregation Class05 --\u0026gt; \u0026#34;1\u0026#34; Class06 @enduml Diagram\r为了避免类图生成有差错，最好把涉及到的类先声明出来；还可以用title xxx来给类图添加标题。：\n1 2 3 4 5 @startuml class Class01 class Class02 Class01 --\u0026gt; Class02 @enduml Diagram\r还用关键字abstract或abstract class来定义抽象类，抽象类会用斜体显示。也可以使用interface,annotation和enum关键字。\n添加方法、属性 使用{}把字段或者方法括起来，定义方法或属性时以()结尾来判断。\n访问权限 符号 public + protected # default(package private) ~ private - 1 2 3 4 5 6 7 8 @startuml class Dummy { -field1 #field2 ~method1() +method2() } @enduml Diagram\r抽象与静态 通过修饰符{static}或者{abstract}，可以定义静态或者抽象的方法或者属性。\n这些修饰符可以写在行的开始或者结束，也可以使用{classifier}这个修饰符来代替{static}。\n1 2 3 4 5 6 @startuml class Dummy { {static} String id {abstract} void methods() } @enduml plantuml\r备注和模板 模板通过类关键字(\u0026lt;\u0026lt;和\u0026gt;\u0026gt;)来定义。\n1 2 3 @startuml class Object \u0026lt;\u0026lt; general \u0026gt;\u0026gt; @enduml Diagram\r使用note left of,note right of,note top of,note bottom of这些关键字来添加备注，优点是可以自定义备注的位置，但是不能复用备注。\n备注可以用\\n来换行。\n1 2 3 4 @startuml class Object note top of Object : In java, every class\\nextends this one. @enduml Diagram\r也可以用note \u0026quot;\u0026quot; as来定义备注，然后用..将备注和类关联起来，优点是可以复用备注，但是不能自定义备注的位置。\n1 2 3 4 5 6 @startuml class Object note \u0026#34;In java, every class\\nextends this one.\u0026#34; as N Object..N @enduml Diagram\r如果想使用更多行且更复杂的备注来支持更多的样式，有下面两种方式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @startuml class Object note top of Object In java, \u0026lt;size:18\u0026gt;every\u0026lt;/size\u0026gt; \u0026lt;u\u0026gt;class\u0026lt;/u\u0026gt; \u0026lt;b\u0026gt;extends\u0026lt;/b\u0026gt; \u0026lt;i\u0026gt;this\u0026lt;/i\u0026gt; one. end note note as N In java, \u0026lt;size:18\u0026gt;every\u0026lt;/size\u0026gt; \u0026lt;u\u0026gt;class\u0026lt;/u\u0026gt; \u0026lt;b\u0026gt;extends\u0026lt;/b\u0026gt; \u0026lt;i\u0026gt;this\u0026lt;/i\u0026gt; one. end note Object..N @enduml Diagram\r备注除了用于类，还可以用于类的成员和方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @startuml class A { {static} int counter +void {abstract} start(int timeout) } note right of A::counter This member is annotated end note note right of A::start This method is now explained in a UML note end note @enduml plantuml2\r参考链接 类图的语法和功能 ","permalink":"https://lewky.cn/posts/plantuml-class-diagram.html/","tags":["PlantUML"],"title":"PlantUML - 类图"},{"categories":null,"contents":"\r信息 有需要联系博主的可以在本版块留言\n别让博主寂寞太久哦~\nreply.png\r","permalink":"https://lewky.cn/bbs/","tags":null,"title":"公告栏/留言板"},{"categories":null,"contents":"\r","permalink":"https://lewky.cn/hot/","tags":null,"title":"热度排行榜"},{"categories":["Spring"],"contents":"前言 本文基于如下版本的JPA和Hibernate：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.4.23.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; JPA本身提供的Repository功能比较简单，遇到一些复杂的查询无法胜任，这时可以使用第三方的增强库，比如Jinq或者QueryDSL。\n定义实体类相关的一些注解 实体类的字段不要使用基本数据类型，应该使用包装类。\n@Entity：声明该类为一个实体类。\n@Table：声明当前实体类对应数据库中的哪一张表。\n一对一的关联关系 @OneToOne：定义两个实体间一对一的关联关系，通常和@JoinColumn搭配使用。比如下面的例子：一个商品只能有一个默认的采购记录，然后采购记录也关联这个商品，由于两者没有定义外键关系所以没有配置mappedBy：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Data @Entity @Table(name = \u0026#34;tb_item\u0026#34;) public class Item { @Id @GeneratedValue(generator = \u0026#34;jpa-uuid\u0026#34;) @GenericGenerator(name = \u0026#34;jpa-uuid\u0026#34;, strategy = \u0026#34;uuid\u0026#34;) private String id; @OneToOne(fetch = FetchType.LAZY) // 在一对一或者多对一的关系中，@JoinColumn是拿自己表的字段去连接对方的字段，默认连接对方的id字段 @JoinColumn(name = \u0026#34;default_sourcing_record_id\u0026#34;) private SourcingRecord defaultSourcingRecord; } @Data @Entity @Table(name = \u0026#34;tb_sourcing_record\u0026#34;) public class SourcingRecord { @Id @GeneratedValue(generator = \u0026#34;jpa-uuid\u0026#34;) @GenericGenerator(name = \u0026#34;jpa-uuid\u0026#34;, strategy = \u0026#34;uuid\u0026#34;) private String id; @OneToOne(fetch = FetchType.LAZY) // 在一对一或者多对一的关系中，@JoinColumn是拿自己表的字段（由name指定）去连接对方的字段，默认连接对方的id字段 @JoinColumn(name = \u0026#34;item_id\u0026#34;) private Item item; } 一对多的关联关系 @OneToMany和@ManyToOne：定义两个实体间一对多的关联关系，多对一的那方需要指定@JoinColumn，为了保证数据一致性通常会设置外键关系，并通过mappedBy来对外键关系进行维护。\n下面是一个一对多的例子，相当于父子关系，一个商品可以有不同的颜色方案：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 @Data @Entity @Table(name = \u0026#34;tb_item\u0026#34;) public class Item { // 这里没有指定mappedBy，因此使用了orphanRemoval来指明自动删除 // 当集合中移除元素时自动删除多方表中对应的记录，如果不设置为true则只会将对应记录的外键设为null // 如果设置了mappedBy，则集合中移除元素将不会产生任何影响（即无法删掉或更新对应记录） // cascade是级联策略 @OneToMany(fetch = FetchType.LAZY, orphanRemoval = true, cascade = CascadeType.ALL) // 在一对多的关系中，@JoinColumn是拿自己表的id字段去连接对方的字段（由name指定） @JoinColumn(name = \u0026#34;item_id\u0026#34;) @OrderBy(value = \u0026#34;colorSeq\u0026#34;) private List\u0026lt;ItemColor\u0026gt; itemColorList; } @Data @Entity @Table(name = \u0026#34;tb_item_color\u0026#34;) public class ItemColor { // 外键 @Column(name = \u0026#34;item_id\u0026#34;) private String itemId; } 多对多的关联关系 下面是一个多对多的例子，将多对多拆分成两个一对多，并额外定义一个中间表。供应商和工厂之间是多对多的关系，通过一个中间表来进行维护：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 @Data @Entity @Table(name = \u0026#34;tb_vendor\u0026#34;) public class Vendor { // 一对多的一方，不需要指定@JoinColumn，不负责维护外键关系，mappedBy指明由多方的vendor变量来维护外键关系 @OneToMany(mappedBy = \u0026#34;vendor\u0026#34;, fetch = FetchType.LAZY) @OrderBy(value = \u0026#34;internalSeqNo\u0026#34;) private List\u0026lt;VendorFact\u0026gt; factList; } @Data @Entity @Table(name = \u0026#34;tb_vendor_fact\u0026#34;) public class VendorFact { // 多对一的一方需要指定@JoinColumn @ManyToOne(fetch = FetchType.LAZY) // 在一对一或者多对一的关系中，@JoinColumn是拿自己表的字段（由name指定）去连接对方的字段，默认连接对方的id字段 @JoinColumn(name = \u0026#34;vendor_id\u0026#34;) private Vendor vendor; // 多对一的一方需要指定@JoinColumn @ManyToOne(fetch = FetchType.LAZY) // 在一对一或者多对一的关系中，@JoinColumn是拿自己表的字段（由name指定）去连接对方的字段，默认连接对方的id字段 @JoinColumn(name = \u0026#34;fact_id\u0026#34;) private Fact fact; } @Data @Entity @Table(name = \u0026#34;tb_fact\u0026#34;) public class Fact { // 一对多的一方，不需要指定@JoinColumn，不负责维护外键关系，mappedBy指明由多方的vendor变量来维护外键关系 @OneToMany(mappedBy = \u0026#34;fact\u0026#34;, fetch = FetchType.LAZY) @OrderBy(value = \u0026#34;internalSeqNo\u0026#34;) private List\u0026lt;VendorFact\u0026gt; vendorList; } 属性嵌入 如果实体类中需要定义一个对象属性，但该对象的字段来自于自身表的多个列，而非另一个表，则可以用@Embedded，@Embeddable，@AttributeOverrides和@AttributeOverride来实现。\n比如供应商有一个国家变量，这个国家变量对应数据表中的三个列，现在希望把这三个列作为一个整体定义到实体类中，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Data @Entity @Table(name = \u0026#34;tb_vendor\u0026#34;) public class Vendor { @Embedded @AttributeOverrides({ @AttributeOverride(name = \u0026#34;code\u0026#34;, column = @Column(name = \u0026#34;country\u0026#34;)), @AttributeOverride(name = \u0026#34;name\u0026#34;, column = @Column(name = \u0026#34;country_name\u0026#34;)), @AttributeOverride(name = \u0026#34;version\u0026#34;, column = @Column(name = \u0026#34;country_ver\u0026#34;)) }) private EmbedCodelist country; } @Data @Embeddable public class EmbedCodelist { private String code; private String name; private Integer version; } 这里的@AttributeOverrides可以省略不写，效果是一样的，如下：\n1 2 3 4 @AttributeOverride(name = \u0026#34;code\u0026#34;, column = @Column(name = \u0026#34;country\u0026#34;)) @AttributeOverride(name = \u0026#34;name\u0026#34;, column = @Column(name = \u0026#34;country_name\u0026#34;)) @AttributeOverride(name = \u0026#34;version\u0026#34;, column = @Column(name = \u0026#34;country_ver\u0026#34;)) private EmbedCodelist country; 建表策略 通常不使用hibernate的建表策略，避免把生产数据搞没了，在SpringBoot配置如下：\n1 2 # common.jpa.hibernate.ddl-auto - available values are: create, create-drop, validate, update, none spring.jpa.hibernate.ddl-auto=none id生成策略 通常情况下直接用下面的注解来标注一个pojo的id字段即可：\n1 2 3 4 5 6 7 8 9 10 @Entity @Table(name = \u0026#34;TB_ITEM\u0026#34;) public class Item { @Id @GeneratedValue(generator = \u0026#34;jpa-uuid\u0026#34;) @GenericGenerator(name = \u0026#34;jpa-uuid\u0026#34;, strategy = \u0026#34;uuid\u0026#34;) private String id; } @Id和@GeneratedValue是JPA规范的注解，@GenericGenerator是Hibernate的注解。\n@Id指明当前字段是当前pojo的id主键，@GeneratedValue指明使用名为jpa-uuid的id生成器。\n@GenericGenerator定义了一个名为@GenericGenerator的id生成器，使用的生成策略是uuid（32位16进制数字）。\nHibernate除了常见的uuid策略，还提供了其他常见的策略：sequence、identity等。\nsequence策略 使用底层数据库的序列机制生成id，换言之，必须用底层数据库支持序列才行。比如MySQL就不支持sequence，但是可以用identity。\n支持序列的有Oracle、PostgreSQL等，使用该策略需要先在数据库创建序列。\nidentity策略 identity同样是由数据库生成的，但该主键字段必须设置为自增长。使用该策略的前提是数据库要支持自动增长类型的字段，Oracle不支持该策略。\n支持自增长的有MySQL、PostgreSQL等，在MySQL中需要将主键设为auto_increment，在PostgreSQL中需要将主键设为serial4或serial8，前者是32位长度，后者是64位长度。\n其他的写法 如果不想混用Hibernate的注解，可以用JPA自身提供的生成器注解：@TableGenerator，@SequenceGenerator等，此时需要改变@GeneratedValue的策略。\n下面是样例代码，具体可以参考这篇文章：Hibernate学习笔记2.4（Hibernate的Id生成策略）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // 自增长，适用于支持自增字段的数据库 @Id @GeneratedValue(strategy = GenerationType.IDENTITY) // 使用表存储生成的主键，可以跨数据库。 // 每次需要主键值时，查询名为\u0026#34;hibernate_table\u0026#34;的表，查找主键列\u0026#34;gen_pk\u0026#34;值为\u0026#34;2\u0026#34;记录，得到这条记录的\u0026#34;gen_val\u0026#34;值，根据这个值，和allocationSize的值生成主键值。 @Id @GeneratedValue(strategy = GenerationType.TABLE, generator = \u0026#34;ud\u0026#34;) @TableGenerator(name = \u0026#34;ud\u0026#34;, table = \u0026#34;hibernate_table\u0026#34;, pkColumnName = \u0026#34;gen_pk\u0026#34;, pkColumnValue = \u0026#34;2\u0026#34;, valueColumnName = \u0026#34;gen_val\u0026#34;, initialValue = 2, allocationSize = 5) // 使用序列 @Id @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \u0026#34;ud\u0026#34;) @SequenceGenerator(name = \u0026#34;ud\u0026#34;, sequenceName = \u0026#34;hibernate_seq\u0026#34;, allocationSize = 1, initialValue = 2) should be mapped with insert=\u0026ldquo;false\u0026rdquo; update=\u0026ldquo;false\u0026rdquo; 启动项目时报错should be mapped with insert=\u0026quot;false\u0026quot; update=\u0026quot;false\u0026quot;，这是因为实体类中定义了重复的映射字段，可能是@Column和@JoinColumn里指定的列名重复了。\n解决方法有两个，要么去掉重复定义的，只留下唯一的映射字段；要么在重复的映射字段上添加insertable = false, updatable = false，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @Data @Entity @Table(name = \u0026#34;tb_member_rule\u0026#34;) public class MemberRule { private String accessObjectId; @OneToOne // 定义重复了映射字段 @JoinColumn(name = \u0026#34;accessObjectId\u0026#34;, referencedColumnName = \u0026#34;id\u0026#34;, insertable = false, updatable = false) private AccessObject accessObject; } 懒加载异常 - JsonMappingException: could not initialize proxy 查询数据时报懒加载异常：\n1 2 3 4 5 Caused by: org.hibernate.LazyInitializationException: could not initialize proxy [com.cbxsoftware.cbx.attachment.entity.RefAttachment#c109ec36e60c4a89a10eabc72416d984] - no Session at org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:169) at org.hibernate.proxy.AbstractLazyInitializer.getImplementation(AbstractLazyInitializer.java:309) at org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor.intercept(ByteBuddyInterceptor.java:45) at org.hibernate.proxy.ProxyConfiguration$InterceptorDispatcher.intercept(ProxyConfiguration.java:95) 报错很明显，是由于hibernate的懒加载引起的。项目使用的是SpringBoot框架，JPA默认使用的是hibernate的实现，而hibernate的懒加载机制其实就是延迟加载对象，如果没有在session关闭前使用到对象里除id以外的属性时，就只会返回一个没有初始化过的包含了id的代理类。很多时候，这个代理类会引发上述的异常。\n简单说一下为什么会触发懒加载异常，首先hibernate开启一个session（会话），然后开启transaction（事务），接着发出sql找回数据并组装成pojo（或者说entity、model），这时候如果pojo里有懒加载的对象，并不会去发出sql查询db，而是直接返回一个懒加载的代理对象，这个对象里只有id。\n如果接下来没有其他的操作去访问这个代理对象除了id以外的属性，就不会去初始化这个代理对象，也就不会去发出sql查找db。接着事务提交，session关闭。如果这时候再去访问代理对象除了id以外的属性时，就会报上述的懒加载异常，原因是这时候已经没有session了，无法初始化懒加载的代理对象。\n解决方法一 如果是spring集成的hibernate，根据上述的原因，可以延长session的生命周期，但是这里用的是SpringBoot的JPA，处理方法不同，需要在application.properties配置下懒加载相关的东西：\n1 spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true 进行该配置后，可以在session关闭时也能另外开启一个新的session和事务来访问db以取回懒加载对象的数据。\n解决方法二 因为该懒加载异常是缺少session导致的，那么可以通过在方法前添加事务注解@Transactional的方式来解决，只要事务没有提交，session就不会关闭，自然就不会出现上述的懒加载异常。不过由于该事务注解是用Spring AOP实现的，存在着一些坑，比如类内直接调用无效或者对非public方法无效等，需要多加注意。\n当使用了上述两种方法后，发现不再触发LazyInitializationException，但是却发生了另一个新的异常InvalidDefinitionException：\n1 2 3 4 5 6 7 8 9 com.fasterxml.jackson.databind.exc.InvalidDefinitionException: No serializer found for class org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS) (through reference chain: com.cbxsoftware.cbx.item.elasticsearch.entity.ItemEstc[\u0026#34;mainEntity\u0026#34;]-\u0026gt;com.cbxsoftware.cbx.item.entity.Item[\u0026#34;image\u0026#34;]-\u0026gt;com.cbxsoftware.cbx.image.entity.RefImage[\u0026#34;propFormat\u0026#34;]-\u0026gt;com.cbxsoftware.cbx.attachment.entity.RefAttachment$HibernateProxy$vTKSYzrN[\u0026#34;hibernateLazyInitializer\u0026#34;]) at com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:77) at com.fasterxml.jackson.databind.SerializerProvider.reportBadDefinition(SerializerProvider.java:1191) at com.fasterxml.jackson.databind.DatabindContext.reportBadDefinition(DatabindContext.java:313) at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.failForEmpty(UnknownSerializer.java:71) at com.fasterxml.jackson.databind.ser.impl.UnknownSerializer.serialize(UnknownSerializer.java:33) at com.fasterxml.jackson.databind.ser.BeanPropertyWriter.serializeAsField(BeanPropertyWriter.java:727) at com.fasterxml.jackson.databind.ser.std.BeanSerializerBase.serializeFields(BeanSerializerBase.java:719) ... 这个异常是由于hibernate在代理类里添加了一个属性hibernateLazyInitializer，当该对象转换成json的时候就会报错。解决方法是将该属性过滤掉，可以在对应的类名或者公共类前加上如下注解：\n1 @JsonIgnoreProperties(value = { \u0026#34;hibernateLazyInitializer\u0026#34; }) 懒加载源码分析 因为对懒加载异常的发生有些好奇，所以看了下hibernate的源码，这里简单分析下，另外我看的是两个源码包如下：\n1 2 spring-orm-5.1.5.RELEASE.jar hibernate-core-5.3.7.Final.jar 首先是关于spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true的配置，前面半截是因为JPA集成了hibernate的配置，所以在hibernate中，这个配置应该是hibernate.enable_lazy_load_no_trans=true。\n在hibernate的一个常量接口org.hibernate.cfg.AvailableSettings中定义了各种配置常量，其中就包括上述这个配置：\n1 String ENABLE_LAZY_LOAD_NO_TRANS = \u0026#34;hibernate.enable_lazy_load_no_trans\u0026#34;; 在启动项目的时候会读取配置文件，将其解析为一个HashMap\u0026lt;K,V\u0026gt;，这些参数在newEntityManagerFactoryBuilderImpl的时候被使用到，上面的常量会在org.hibernate.boot.internal.SessionFactoryOptionsBuilder里被拿来初始化：\n1 this.initializeLazyStateOutsideTransactions = cfgService.getSetting( ENABLE_LAZY_LOAD_NO_TRANS, BOOLEAN, false ); 因为在配置文件里配置了该变量的值为true，所以这里在初始化的时候就会把initializeLazyStateOutsideTransactions的值设置为true。该变量由一个方法来判断其值是否为true：\n1 2 3 4 @Override public boolean isInitializeLazyStateOutsideTransactionsEnabled() { return initializeLazyStateOutsideTransactions; } 接着在组装pojo时，会为懒加载对象创建对应的代理对象，当需要获取该代理对象除id以外的属性时，就会调用AbstractLazyInitializer#initialize()进行初始化，逻辑如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @Override public final void initialize() throws HibernateException { if ( !initialized ) { if ( allowLoadOutsideTransaction ) { permissiveInitialization(); } else if ( session == null ) { throw new LazyInitializationException( \u0026#34;could not initialize proxy [\u0026#34; + entityName + \u0026#34;#\u0026#34; + id + \u0026#34;] - no Session\u0026#34; ); } else if ( !session.isOpen() ) { throw new LazyInitializationException( \u0026#34;could not initialize proxy [\u0026#34; + entityName + \u0026#34;#\u0026#34; + id + \u0026#34;] - the owning Session was closed\u0026#34; ); } else if ( !session.isConnected() ) { throw new LazyInitializationException( \u0026#34;could not initialize proxy [\u0026#34; + entityName + \u0026#34;#\u0026#34; + id + \u0026#34;] - the owning Session is disconnected\u0026#34; ); } else { target = session.immediateLoad( entityName, id ); initialized = true; checkTargetState(session); } } else { checkTargetState(session); } } 如果在配置文件中设置了spring.jpa.properties.hibernate.enable_lazy_load_no_trans=true，那么上述的allowLoadOutsideTransaction变量值就为true，则可以进入permissiveInitialization()方法另起session和事务，最终避免懒加载异常LazyInitializationException。如果没有配置该参数，那么就会由于session已关闭（即为null）而抛出LazyInitializationException。\n@JoinColumn无法找回数据导致报错 使用@JoinColumn时如果无法找到对应的record，就会报错导致查询失败：\n1 2 3 4 5 6 7 javax.persistence.EntityNotFoundException: Unable to find com.cbxsoftware.rest.entity.fact.Fact with id 4d644cfa243b493ab34d69e4207ee5f1 at org.hibernate.jpa.boot.internal.EntityManagerFactoryBuilderImpl$JpaEntityNotFoundDelegate.handleEntityNotFound(EntityManagerFactoryBuilderImpl.java:163) at org.hibernate.proxy.AbstractLazyInitializer.checkTargetState(AbstractLazyInitializer.java:286) at org.hibernate.proxy.AbstractLazyInitializer.initialize(AbstractLazyInitializer.java:181) at org.hibernate.proxy.AbstractLazyInitializer.getImplementation(AbstractLazyInitializer.java:310) at org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor.intercept(ByteBuddyInterceptor.java:45) at org.hibernate.proxy.ProxyConfiguration$InterceptorDispatcher.intercept(ProxyConfiguration.java:95) 通过使用Hibernate提供的@NotFound(action = NotFoundAction.IGNORE)可以避免这个问题，该注解的默认值是NotFoundAction.EXCEPTION，所以hibernate在join表时查不到对应的数据就会抛出异常。\n连表时指定额外的条件 连表时使用的@JoinColumn只能指定被连接的表的列，如果需要指定其他的条件，如a inner join b on b.column_1 = 'xxx'，需要使用@JoinColumnsOrFormula注解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @Data @Entity @Table(name = \u0026#34;navi\u0026#34;) public class Navi { @JsonUnwrapped @OneToOne(fetch = FetchType.EAGER) @JoinColumnsOrFormulas(value={ @JoinColumnOrFormula(column=@JoinColumn(name=\u0026#34;label\u0026#34;,referencedColumnName=\u0026#34;labelId\u0026#34;)), @JoinColumnOrFormula(formula=@JoinFormula(value=\u0026#34;\u0026#39;en_US\u0026#39;\u0026#34;,referencedColumnName=\u0026#34;locale\u0026#34;)) }) private Label label; } @Data @Entity @Table(name=\u0026#34;label\u0026#34;) public class Label { private String labelId; private String locale; } 上面的连表sql即为：navi inner join label on navi.label = label.label_id and label.locale = 'en_US'。\n这里的Formula用来定义sql判断，referencedColumnName是被连接的表的字段名字（非数据库列名）。如果嫌麻烦，也可以不写@JoinColumnsOrFormulas，直接用简写的方式：\n1 2 3 4 5 @JsonUnwrapped @OneToOne(fetch = FetchType.EAGER) @JoinColumnOrFormula(column=@JoinColumn(name=\u0026#34;label\u0026#34;,referencedColumnName=\u0026#34;labelId\u0026#34;)) @JoinColumnOrFormula(formula=@JoinFormula(value=\u0026#34;\u0026#39;en_US\u0026#39;\u0026#34;,referencedColumnName=\u0026#34;locale\u0026#34;)) private Label label; 编译器会自动将多个@JoinColumnOrFormula注解包装成一个@JoinColumnsOrFormulas。\n懒加载导致的N + 1问题 Hibernate的懒加载有个让人诟病的问题，就是所谓的N + 1问题：如果一个实体里存在一个懒加载的集合对象，在查询该实体时，会发出一条SQL。当触发查询该懒加载的集合时，则会发出N条SQL。\n如果这个实体比较复杂，存在多个懒加载的集合，集合对象又各自关联了其他的懒加载的集合，如果触发查询这些集合，就会发出大量的SQL去查询，对DB造成较大的负荷。\n解决方法有如下几种：\n取消懒加载，改为FetchType.EAGER。 给集合对象添加@Fetch(FetchMode.SUBSELECT)，该注解会让Hibernate只会生成一条SQL去查询该集合。 使用@NamedEntityGraph和@EntityGraph来解决懒加载时SQL查询过多的问题，但是这种方法比较复杂。 解决JPA懒加载典型的N+1问题-注解@NamedEntityGraph cannot simultaneously fetch multiple bags异常 应用启动时报错：org.hibernate.loader.MultipleBagFetchException: cannot simultaneously fetch multiple bags，该异常由Hibernate引发，当一个实体中定义了两个及两个以上的非懒加载的集合时，即fetch = FetchType.EAGER，这些集合又可能关联其他的对象。Hibernate实现的JPA，默认最高抓取深度含本身级为四级(它有个属性配置是0-3)，若多方(第二级)存在重复值，则第三级中抓取的值就无法映射，就会出现 multiple bags。\n简单来说，Hibernate默认会用一条SQL直接把FetchType.EAGER的集合也一起left join进来，如果这些集合允许重复值，且存在两个及两个以上的这些集合，而集合又可能关联其他的对象。一旦出现这种情况，Hibernate就会无法区分清楚查询回来的结果集。\n解决方法有如下几种：\n改用懒加载FetchType.LAZY来加载这些集合对象。 给集合对象添加@Fetch(FetchMode.SUBSELECT)，该注解会让Hibernate另外生成一条SQL去查询该集合。效果类似于懒加载，也是用分开的SQL去查询，区别是这个是非懒加载。 使用Set集合来替代List集合。 使用@IndexColumn，该注解允许你指明存放索引值的字段，目的跟Set容器不允许重复元素的道理一样。但是该注解以废弃，官方推荐使用的是JPA规范的@OrderColumn。 前两种方法比较常用，不过第二个方法是Hibernate自身的规范。\nUnexpectedRollbackException异常 在使用事务时发生异常，事务回滚时报错：\n1 org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only 这是事务传播行为导致的，JPA默认的事务传播级别是PROPAGATION_REQUIRED：如果当前存在事务则加入该事务，否则新建一个事务。\n于是当一个事务方法A去调用了另一个事务方法B时，不指明事务传播级别，那么事务方法B依然使用方法A的事务。此时如果方法B抛出异常，触发事务回滚，而在方法A调用方法B的地方使用try-catch捕获发生的异常，理论上方法A应该继续正常执行，实际上却不是这样。\n当方法A继续执行完毕，在最后提交事务时，会发现当前事务已经被标记为rollback-only状态，于是整个事务回滚并抛出UnexpectedRollbackException异常。\n在这种情况下，一般有两种处理场景：\n只有方法B在遇到异常时事务回滚，且不影响到方法A的事务提交，那么此时方法B的事务要指明为PROPAGATION_NESTED。但是，JPA默认实现是Hibernate，而Hibernate不提供事务嵌套。对于这种情况，要么使用其他的JPA实现，要么在方法B中将可能发生的异常try-catch并且不往外抛出，但此时方法B将不能自动事务回滚。 方法B发生异常时，和方法A一起事务回滚。这种场景需要在方法A调用方法B的地方使用try-catch捕获发生的异常，并且将该异常重新往外抛出，这样就可以让方法A事务回滚，且得到的异常也是真正的异常，而不是UnexpectedRollbackException异常。 JPA Projection不支持新的日期类LocalDate、LocalDateTime JPA的Projection有个坑：不支持LocalDate、LocalDateTime这两个类型。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 @Query(value = \u0026#34;select ibs.sequence as sequence, ibs.inspect_booking_id as inspectBookingId, ibs.date as date \u0026#34; + \u0026#34;from CNT_INSPECT_BOOKING_SCHEDULED ibs where ibs.inspector_id = :inspectorId\u0026#34;, nativeQuery = true) List\u0026lt;SimpleInspectBookingScheduled\u0026gt; findInspectBookingIdByInspectorId(@Param(value = \u0026#34;inspectorId\u0026#34;)final String inspectorId); interface SimpleInspectBookingScheduled { Long getSequence(); String getInspectBookingId(); LocalDate getDate(); } 当调用该方法时会抛出如下异常：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 java.lang.IllegalArgumentException: Projection type must be an interface! at org.springframework.util.Assert.isTrue(Assert.java:121) at org.springframework.data.projection.ProxyProjectionFactory.createProjection(ProxyProjectionFactory.java:105) at org.springframework.data.projection.SpelAwareProxyProjectionFactory.createProjection(SpelAwareProxyProjectionFactory.java:45) at org.springframework.data.projection.ProjectingMethodInterceptor.getProjection(ProjectingMethodInterceptor.java:160) at org.springframework.data.projection.ProjectingMethodInterceptor.potentiallyConvertResult(ProjectingMethodInterceptor.java:108) at org.springframework.data.projection.ProjectingMethodInterceptor.invoke(ProjectingMethodInterceptor.java:85) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.data.projection.ProxyProjectionFactory$TargetAwareMethodInterceptor.invoke(ProxyProjectionFactory.java:250) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.data.projection.DefaultMethodInvokingMethodInterceptor.invoke(DefaultMethodInvokingMethodInterceptor.java:80) at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186) at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:215) at com.sun.proxy.$Proxy611.getDate(Unknown Source) 在使用JPA Projection时，对于日期类型必须使用java.sql包下的Date或Timestamp。如果强行使用Java 8新增的日期类，则会抛出上述诡异的异常。将接口改为如下则调用正常：\n1 2 3 4 5 6 7 8 9 import java.sql.Date; interface SimpleInspectBookingScheduled { Long getSequence(); String getInspectBookingId(); Date getDate(); } 此外，java.sql包下的类和新的日期类的转换方式可以参考这篇文章\noperator does not exist: character varying = bytea 当使用JPA的@Query查询数据库时，此时@Query里自定义的sql会用到参数绑定，如下：\n1 2 3 4 @Query(value = \u0026#34;SELECT * \u0026#34; + \u0026#34;from tb_test test \u0026#34; + \u0026#34;where test.domain_id = :domainId\u0026#34;, nativeQuery = true) List\u0026lt;Test\u0026gt; test(@Param(value = \u0026#34;domainId\u0026#34;) final String domainId); 如果被绑定的参数值是null，而被查询的数据库是PostgreSQL，那么上述SQL在执行时就会报错：\n1 2 3 Caused by: org.postgresql.util.PSQLException: ERROR: operator does not exist: character varying = bytea Hint: No operator matches the given name and argument types. You might need to add explicit type casts. Position: 145 原因是PostgreSQL驱动把null值识别成了bytea类型，在进行参数绑定时，由于当前字段是varchar类型（character varying），会认为需要进行显示类型转换。如果直接把下述SQL去PostgreSQL 12查询，是不会报错的：\n1 SELECT * from tb_test test where test.domain_id = null; 这里报错是因为JPA使用了参数绑定的方式：\n1 SELECT * from tb_test test where test.domain_id = ?; 解决这个问题，需要处理参数值是null的情况，由于业务需求，这个参数值不能为null，我需要在参数值不为null时才能调用这个方法，这样就不会触发这个问题。\n如果是需要按照参数值是否为null来作为查询条件，可以这样写：\n1 2 3 4 @Query(value = \u0026#34;SELECT * \u0026#34; + \u0026#34;from tb_test test \u0026#34; + \u0026#34;where test.domain_id is null or test.domain_id = cast(:domainId as text)\u0026#34;, nativeQuery = true) List\u0026lt;Test\u0026gt; test(@Param(value = \u0026#34;domainId\u0026#34;) final String domainId); 忽略某个字段 有时候需要在pojo中定义一个常量字段，仅用于业务逻辑，且不希望该字段被映射到数据库中，也就是说这个字段的值不需要被持久化的数据库中。\n这时候可以使用@Transient注解（包路径是javax.persistence.Transient）。\nSpringBoot打印Hibernate的sql 1 2 3 4 5 6 7 8 9 # 控制台打印sql语句 spring.jpa.show-sql=true # 格式化sql语句 spring.jpa.properties.hibernate.format_sql=false # 指出是什么操作生成了该sql语句 spring.jpa.properties.hibernate.use_sql_comments=false spring.jpa.properties.hibernate.generate_statistics=false 如果想把sql也打印的log文件中，logger的配置如下：\n1 2 3 4 5 \u0026lt;!-- Use DEBUG level to print sql and sql-parameters, change to INFO level will not print them. --\u0026gt; \u0026lt;Logger name=\u0026#34;org.hibernate.SQL\u0026#34; level=\u0026#34;DEBUG\u0026#34; additivity=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/Logger\u0026gt; \u0026lt;Logger name=\u0026#34;org.hibernate.type.descriptor.sql.BasicBinder\u0026#34; level=\u0026#34;INFO\u0026#34; additivity=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;/Logger\u0026gt; detached entity passed to persist 不要手动设置id的值，如果有其他实体需要用到这个id的值，可以直接getId()来获取id（尽管此时id还没有被hibernate生成出来），hibernate会在commit到db的时候获取到id。\njpa的Repository的save()有个返回值，返回值是保存之后的对象，虽然此时还没commit到db，但可以通过这个返回值来获取到一些需要提交到db才会生成的数据，如id等。\nnativeQuery 有时候用hql来查询一个复杂的sql会比较麻烦，可以用nativeQuery = true来使用原生sql查询数据：\n1 2 3 4 @Query(value = \u0026#34;SELECT * \u0026#34; + \u0026#34;from tb_test test \u0026#34; + \u0026#34;where test.domain_id is null or test.domain_id = cast(:domainId as text)\u0026#34;, nativeQuery = true) List\u0026lt;Test\u0026gt; test(@Param(value = \u0026#34;domainId\u0026#34;) final String domainId); 事务提交成功才能执行其他操作 有些业务可能需要在事务提交之后才能执行，可以使用TransactionSynchronizationManager来实现：\n1 2 3 4 5 6 7 8 public void afterCommitProcess() throws Exception { TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() { @Override public void afterCommit() { System.out.println(\u0026#34;after transaction commit...\u0026#34;); } }); } TransactionSynchronizationAdapter在Spring5.3之后被废弃了，直接改用其继承的接口org.springframework.transaction.support.TransactionSynchronization就行。\nTransactionSynchronization中可以重写beforeCommit(boolean readOnly)、afterCommit()等方法来控制事务的生命周期，比如想要在事务提交后发邮件通知，就可以重写afterCommit()，添加发生邮件的功能。\n参考链接 springboot jpa 解决延迟加载问题 No serializer found for class org.hibernate.proxy.pojo.bytebuddy.ByteBuddyInterceptor springboot集成jpa返回Json报错 com.fasterxml.jackson.databind.exc.InvalidDefinitionException: Hibernate和Spring整合出现懒加载异常：org.hibernate.LazyInitializationException: could not initialize proxy - no Session [JPA] javax.persistence.EntityNotFoundException: Unable to find XXXX with id 0 问题原因 [转]cannot simultaneously fetch multiple bags 问题的解决办法 UnexpectedRollbackException解决方案 import java.sql.date_Java8中 LocalDate和java.sql.Date的相互转换操作 PostgreSQL错误处理“operator does not exist: character varying = bytea at character” Hibernate在控制台打印sql语句以及参数 detached entity passed to persist 错误的引起的原因和解决办法 postgresql如何设置自动增长 Hibernate学习笔记2.4（Hibernate的Id生成策略） Hibernate oneToOne join with additional criteria Hibernate实体基本注解，ManyToOne,OneToMany,cascade,orphanRemoval等说明 如何在数据库事务提交成功后进行异步操作 ","permalink":"https://lewky.cn/posts/spring-data-jpa-hibernate/","tags":["JPA","Hibernate","工作记录"],"title":"Spring Data JPA/Hibernate问题汇总"},{"categories":["Blog"],"contents":"docsify 根据官方说法，docsify是一个神奇的文档网站生成工具，也可以把它当做一个简易版的静态站点诸如Hexo、Hugo等。当然，它是专门针对文档的，忽然想到了程序员深恶痛绝的就是写API文档……\ndocsify特性很多，最吸引我的是全文搜索、主题简洁好看、无需构建的纯静态站点。这意味着可以很简单地把写完的文档直接扔到Pages服务上，比如GitHub Pages、Coding Pages等等。\n快速安装 首先需要先安装npm，这里简单说下。安装npm之前需要先安装node.js，而博主是Windows系统，可以通过nvm-windows来安装node.js，具体可以参考这篇文章\n然后用npm来全局安装docsify：\n1 npm i docsify-cli -g 简易搭建 初始化 创建一个文档站点目录，比如note目录，然后在该目录下执行命令：\n1 docsify init ./docs 然后docsify会在该目录下新建一个docs目录，里面有3个初始文件：\n.nojekyll：告诉GitHub Pages服务该站点不使用Jekyll作为构建工具 index.html：入口文件 README.md：作为首页渲染 请尽量使用docs目录来初始化docsify，原因是后面要用该目录部署到GitHub Pages。\n本地预览与实时更新 使用如下命令可以本地预览站点：\n1 docsify serve docs 然后就可以通过http://localhost:3000/来访问你的文档站点。\ndocsify支持实时更新，可以在启动本地服务时自动重新加载刚刚更新的文件。\n常用配置 站点标题、图标 站点标题需要修改index.html里的title标签：\n1 \u0026lt;title\u0026gt;Java-Note\u0026lt;/title\u0026gt; 站点图标要在index.html添加如下代码：\n1 \u0026lt;link rel=\u0026#34;icon\u0026#34; href=\u0026#34;//cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/avatar.jpg\u0026#34;\u0026gt; 主题选择 docsify提供了多款主题，通过修改index.html里的css地址即可更换主题：\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css\u0026#34;\u0026gt; 还有以下的主题可以挑选，有遗漏的可以帮忙补充下：\n1 2 3 4 5 6 7 8 9 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/buble.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/dark.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/pure.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/dolphin.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/css/theme-defaults.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/css/theme-simple.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/docsify-themeable@0/dist/css/theme-simple-dark.css\u0026#34;\u0026gt; Github Corner index.html里有个脚本代码如下：\n1 2 3 4 5 6 \u0026lt;script\u0026gt; window.$docsify = { name: \u0026#39;\u0026#39;, repo: \u0026#39;\u0026#39; } \u0026lt;/script\u0026gt; name会作为标题显示在站点的侧边栏，repo会作为Github Corner显示在站点的右上角，点击可跳转到对应的地址。样例如下：\n1 2 3 4 5 6 \u0026lt;script\u0026gt; window.$docsify = { name: \u0026#39;Java-Note\u0026#39;, repo: \u0026#39;https://github.com/lewky\u0026#39; } \u0026lt;/script\u0026gt; coverpage封面 该参数可以给站点添加一个封面，如下：\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; window.$docsify = { name: \u0026#39;Java-Note\u0026#39;, repo: \u0026#39;https://github.com/lewky\u0026#39;, coverpage: true } \u0026lt;/script\u0026gt; 封面由_coverpage.md来渲染，默认无该文件需自行创建，内容如下：\n1 2 3 4 5 6 7 8 9 ![logo](https://docsify.js.org/_media/icon.svg) # Java笔记 \u0026gt; 个人向的Java学习笔记 * 贵在坚持 [开始阅读](/README) loadNavbar导航栏 该参数用于添加导航栏，如下：\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; window.$docsify = { name: \u0026#39;Java-Note\u0026#39;, repo: \u0026#39;https://github.com/lewky\u0026#39;, loadNavbar: true } \u0026lt;/script\u0026gt; 同样需要新建文件_navbar.md，内容如下：\n1 2 3 * [Home](/) * Links * [CS-Notes](http://cyc2018.gitee.io/cs-notes/#/README) loadSidebar侧边栏 该参数用于添加侧边栏，如下：\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; window.$docsify = { name: \u0026#39;Java-Note\u0026#39;, repo: \u0026#39;https://github.com/lewky\u0026#39;, loadSidebar: true } \u0026lt;/script\u0026gt; 同样需要新建文件_sidebar.md，内容如下：\n1 2 3 * [简介](/) * 数据结构 * [数组](data-structure/array/) 个人不建议用这个参数，docsify默认会帮你生成侧边栏，并且有目录效果，可以点击跳转。\n全文搜索插件 docsify提供了一些插件，包括全文搜索等，可以通过该地址查询有哪些插件：https://cdn.jsdelivr.net/npm/docsify@4.12.0/lib/plugins/\n对于全文搜索插件，需要在index.html里添加search属性以及JavaScript，官方提供的搜索插件好像有点问题，这里用的是其他的搜索插件。如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; window.$docsify = { name: \u0026#39;Java-Note\u0026#39;, repo: \u0026#39;https://github.com/lewky\u0026#39;, search: { maxAge: 86400000, // Expiration time, the default one day paths: \u0026#39;auto\u0026#39;, placeholder: \u0026#39;🔍 Type to search \u0026#39;, noData: \u0026#39;😞 No Results! \u0026#39;, depth: 6 } } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;//cdn.bootcss.com/docsify/4.5.9/plugins/search.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 目前似乎高于4.5.9版本的搜索插件有bug，只能搜索到首页的数据；建议使用该版本的搜索插件。\n此外，使用了无序列表或者有序列表的数据是无法生成对应索引的，也就是说搜索插件无法搜索到列表里的数据。建议尽量别使用列表语法，可以改用特殊符号● 、罗马数字ⅠⅡⅢⅣⅤⅥⅦⅧⅨ 和换行符\u0026lt;br\u0026gt;来代替列表语法。\n回到顶部插件 在index.html引入脚本和参数配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;script\u0026gt; window.$docsify = { name: \u0026#39;Java-Note\u0026#39;, repo: \u0026#39;https://github.com/lewky\u0026#39;, scrollToTop: { auto: true, text: \u0026#39;Top\u0026#39;, right: 15, bottom: 15, offset: 300 } } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;//unpkg.com/docsify-scroll-to-top/dist/docsify-scroll-to-top.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 参数配置有默认值，不配也可以，一共就这几个属性，可以自己随意定制。\n代码高亮插件 在index.html引入脚本，可以根据需要引入对应的语言高亮脚本：\n1 2 3 4 \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-java.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-bash.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-c.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/npm/prismjs@1.22.0/components/prism-sql.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 复制代码块插件 在index.html引入脚本和参数配置：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;script\u0026gt; window.$docsify = { // docsify-copy-code (defaults) copyCode: { buttonText : \u0026#39;Copy to clipboard\u0026#39;, errorText : \u0026#39;Error\u0026#39;, successText: \u0026#39;Copied\u0026#39; } } \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;//unpkg.com/docsify-copy-code@2.1.1/dist/docsify-copy-code.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 参数配置有默认值，可以不配置直接引入脚本即可使用。\n图片缩放插件 在index.html引入脚本即可：\n1 \u0026lt;script src=\u0026#34;//cdn.jsdelivr.net/npm/docsify/lib/plugins/zoom-image.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 添加fontawesome 可以通过引入fontawesome来使用各种免费的矢量图标来丰富页面内容：\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css\u0026#34;\u0026gt; 用法很简单，就是使用\u0026lt;i\u0026gt;标签来引入，而markdown兼容html代码，如下：\n1 \u0026lt;i class=\u0026#34;fas fa-fw fa-home\u0026#34;\u0026gt;\u0026lt;/i\u0026gt; 还有其他的动态图用法等，网上教程很多，这里就不赘述了。\nPlantUML插件 在index.html引入脚本即可：\n1 \u0026lt;script src=\u0026#34;//unpkg.com/docsify-plantuml/dist/docsify-plantuml.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 默认主题是default，也可以配置成classic：\n1 2 3 4 5 6 7 \u0026lt;script\u0026gt; window.$docsify = { plantuml: { skin: \u0026#39;classic\u0026#39;, } } \u0026lt;/script\u0026gt; 远程部署到Pages服务 GitHub Pages支持从三个地方读取文件：\ndocs目录 main分支（以前是叫master分支） gh-pages分支 master分支一般用于个人站点，gh-pages分支需要另外创建一个新的分支（默认GitHub仓库创建的是master分支），对于文档站点，建议直接使用docs目录来部署，这也是前文为什么建议用docs目录进行初始化的原因。\n将文档站点推送到GitHub仓库后，在Settings里选择使用main branch和/docs进行部署即可。\n参考链接 docsify官方文档 docsify 入坑指南与我放弃 Gitbook 的那些理由 有了docsify神器，从此爱上看文档 关于写作那些事之github告诉我构建失败,然后呢? docsify-scroll-to-top 入坑 docsify，一款神奇的文档生成利器！ ","permalink":"https://lewky.cn/posts/docsify-0.html/","tags":["docsify"],"title":"docsify快速入门"},{"categories":["杂谈"],"contents":"前言 有些网站需要加载谷歌字体，由于网络问题或者某些问题，fonts.googleapis.com访问太慢会导致站点加载很慢。虽然最后能看到网站，但实际上谷歌字体依然加载失败了，这个体验就非常差劲了。\n解决方法 实际上这个谷歌字体是可以不需要去访问的，当然有强迫症的可以靠fan qiang等某些操作来达到快速加载的目的。个人建议是直接屏蔽掉这个谷歌字体的访问，一般都会在浏览器安装adblockplus等广告拦截插件，可以在这些广告拦截插件添加新的拦截规则：\n1 ||fonts.googleapis.com 这样就可以拦截谷歌字体的访问，以避免访问站点过慢的问题。按照这个思路，理论上直接改hosts文件，把这个地址重定向到localhost应该也是可行的。\n补充 如果是自己搭建的站点需要加载谷歌字体，那么有两种方法。\n方法一 使用360提供的cdn，将需要加载的谷歌字体的url放到360的Google 字体库搜索，会得到一串css代码，将代码拷贝到一个css文件中然后站点直接引入该css文件即可。\n比如说，现在需要引入https://fonts.googleapis.com/css?family=Roboto+Mono|Source+Sans+Pro:300,400,600这个谷歌字体，那么前往360的Google 字体库搜索得到如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 /* roboto-mono-regular */ @font-face { font-family: \u0026#39;Roboto Mono\u0026#39;; font-style: normal; font-weight: regular; src: url(\u0026#39;//lib.baomitu.com/fonts/roboto-mono/roboto-mono-regular.eot\u0026#39;); /* IE9 Compat Modes */ src: local(\u0026#39;Roboto Mono\u0026#39;), local(\u0026#39;RobotoMono-Normal\u0026#39;), url(\u0026#39;//lib.baomitu.com/fonts/roboto-mono/roboto-mono-regular.eot?#iefix\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), /* IE6-IE8 */ url(\u0026#39;//lib.baomitu.com/fonts/roboto-mono/roboto-mono-regular.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;), /* Super Modern Browsers */ url(\u0026#39;//lib.baomitu.com/fonts/roboto-mono/roboto-mono-regular.woff\u0026#39;) format(\u0026#39;woff\u0026#39;), /* Modern Browsers */ url(\u0026#39;//lib.baomitu.com/fonts/roboto-mono/roboto-mono-regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;), /* Safari, Android, iOS */ url(\u0026#39;//lib.baomitu.com/fonts/roboto-mono/roboto-mono-regular.svg#RobotoMono\u0026#39;) format(\u0026#39;svg\u0026#39;); /* Legacy iOS */ } /* source-sans-pro-300 */ @font-face { font-family: \u0026#39;Source Sans Pro\u0026#39;; font-style: normal; font-weight: 300; src: url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-300.eot\u0026#39;); /* IE9 Compat Modes */ src: local(\u0026#39;Source Sans Pro\u0026#39;), local(\u0026#39;SourceSans Pro-Normal\u0026#39;), url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-300.eot?#iefix\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), /* IE6-IE8 */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-300.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;), /* Super Modern Browsers */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-300.woff\u0026#39;) format(\u0026#39;woff\u0026#39;), /* Modern Browsers */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-300.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;), /* Safari, Android, iOS */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-300.svg#SourceSans Pro\u0026#39;) format(\u0026#39;svg\u0026#39;); /* Legacy iOS */ } /* source-sans-pro-regular */ @font-face { font-family: \u0026#39;Source Sans Pro\u0026#39;; font-style: normal; font-weight: regular; src: url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-regular.eot\u0026#39;); /* IE9 Compat Modes */ src: local(\u0026#39;Source Sans Pro\u0026#39;), local(\u0026#39;SourceSans Pro-Normal\u0026#39;), url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-regular.eot?#iefix\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), /* IE6-IE8 */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-regular.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;), /* Super Modern Browsers */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-regular.woff\u0026#39;) format(\u0026#39;woff\u0026#39;), /* Modern Browsers */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-regular.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;), /* Safari, Android, iOS */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-regular.svg#SourceSans Pro\u0026#39;) format(\u0026#39;svg\u0026#39;); /* Legacy iOS */ } /* source-sans-pro-600 */ @font-face { font-family: \u0026#39;Source Sans Pro\u0026#39;; font-style: normal; font-weight: 600; src: url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-600.eot\u0026#39;); /* IE9 Compat Modes */ src: local(\u0026#39;Source Sans Pro\u0026#39;), local(\u0026#39;SourceSans Pro-Normal\u0026#39;), url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-600.eot?#iefix\u0026#39;) format(\u0026#39;embedded-opentype\u0026#39;), /* IE6-IE8 */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-600.woff2\u0026#39;) format(\u0026#39;woff2\u0026#39;), /* Super Modern Browsers */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-600.woff\u0026#39;) format(\u0026#39;woff\u0026#39;), /* Modern Browsers */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-600.ttf\u0026#39;) format(\u0026#39;truetype\u0026#39;), /* Safari, Android, iOS */ url(\u0026#39;//lib.baomitu.com/fonts/source-sans-pro/source-sans-pro-600.svg#SourceSans Pro\u0026#39;) format(\u0026#39;svg\u0026#39;); /* Legacy iOS */ } 将其拷贝到新建的css文件fonts.css中，然后在站点引入该css文件：\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/fonts.css\u0026#34; \u0026gt; 方法二 跟方法一是一回事，只不过不是去360提供的Google 字体库获取代码，而是直接去谷歌字体的链接把代码下载下来，拷贝到一个css文件里。\n甚至还可以将css文件里的字体文件woff或者ttf等下载下来，然后把css代码里的字体文件链接全改为本地的字体文件，之后依然是在站点中引入css文件即可。想看更具体的做法可以参考这篇文章，当然了，对于懒人来说，直接不用谷歌字体就完事了，比如说我。\n参考链接 fonts.googleapis.com访问速度巨慢,导致很多网站加载时间非常长,有什么解决的办法么? 解决页面中引用了谷歌字体库访问缓慢的问题 ","permalink":"https://lewky.cn/posts/fonts-googleapis-slow.html/","tags":["站点访问优化"],"title":"fonts.googleapis.com访问太慢导致站点加载很慢"},{"categories":["杂谈"],"contents":"代马 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 _(\\_/) ,((((^`\\ (((( (6 \\ ,((((( , \\ ,,,_ ,((((( /\u0026#34;._ ,`, ((((\\\\ ,... ,(((( / `-.-\u0026#39; ))) ;\u0026#39; `\u0026#34;\u0026#39;\u0026#34;\u0026#39;\u0026#34;\u0026#34;(((( ( ((( / ((( \\ )) | | (( | . \u0026#39; | )) \\ _ \u0026#39; `t ,.\u0026#39;) ( | y;- -,-\u0026#34;\u0026#34;\u0026#39;\u0026#34;-.\\ \\/ ) / ./ ) / `\\ \\ |./ ( ( / /\u0026#39; || \\\\ //\u0026#39;| || \\\\ _//\u0026#39;|| || )) |_/ || \\_\\ |_/ || `\u0026#39;\u0026#34; \\_\\ `\u0026#39;\u0026#34; 狗子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 /*** * .,:,,, .::,,,::. * .::::,,;;, .,;;:,,....:i: * :i,.::::,;i:. ....,,:::::::::,.... .;i:,. ......;i. * :;..:::;::::i;,,:::;:,,,,,,,,,,..,.,,:::iri:. .,:irsr:,.;i. * ;;..,::::;;;;ri,,,. ..,,:;s1s1ssrr;,.;r, * :;. ,::;ii;:, . ................... .;iirri;;;,,;i, * ,i. .;ri:. ... ............................ .,,:;:,,,;i: * :s,.;r:... ....................................... .::;::s; * ,1r::. .............,,,.,,:,,........................,;iir; * ,s;........... ..::.,;:,,. ...............,;1s * :i,..,. .,:,,::,. .......... .......;1, * ir,....:rrssr;:, ,,.,::. .r5S9989398G95hr;. ....,.:s, * ;r,..,s9855513XHAG3i .,,,,,,,. ,S931,.,,.;s;s\u0026amp;BHHA8s.,..,..:r: * :r;..rGGh, :SAG;;G@BS:.,,,,,,,,,.r83: hHH1sXMBHHHM3..,,,,.ir. * ,si,.1GS, sBMAAX\u0026amp;MBMB5,,,,,,:,,.:\u0026amp;8 3@HXHBMBHBBH#X,.,,,,,,rr * ;1:,,SH: .A@\u0026amp;\u0026amp;B#\u0026amp;8H#BS,,,,,,,,,.,5XS, 3@MHABM\u0026amp;59M#As..,,,,:,is, * .rr,,,;9\u0026amp;1 hBHHBB\u0026amp;8AMGr,,,,,,,,,,,:h\u0026amp;\u0026amp;9s; r9\u0026amp;BMHBHMB9: . .,,,,;ri. * :1:....:5\u0026amp;XSi;r8BMBHHA9r:,......,,,,:ii19GG88899XHHH\u0026amp;GSr. ...,:rs. * ;s. .:sS8G8GG889hi. ....,,:;:,.:irssrriii:,. ...,,i1, * ;1, ..,....,,isssi;, .,,. ....,.i1, * ;h: i9HHBMBBHAX9: . ...,,,rs, * ,1i.. :A#MBBBBMHB##s ....,,,;si. * .r1,.. ,..;3BMBBBHBB#Bh. .. ....,,,,,i1; * :h;.. .,..;,1XBMMMMBXs,.,, .. :: ,. ....,,,,,,ss. * ih: .. .;;;, ;;:s58A3i,.. ,. ,.:,,. ...,,,,,:,s1, * .s1,.... .,;sh, ,iSAXs;. ,. ,,.i85 ...,,,,,,:i1; * .rh: ... rXG9XBBM#M#MHAX3hss13\u0026amp;\u0026amp;HHXr .....,,,,,,,ih; * .s5: ..... i598X\u0026amp;\u0026amp;A\u0026amp;AAAAAA\u0026amp;XG851r: ........,,,,:,,sh; * . ihr, ... . .. ........,,,,,;11:. * ,s1i. ... ..,,,..,,,.,,.,,.,.. ........,,.,,.;s5i. * .:s1r,...................... ..............;shs, * . .:shr:. .... ..............,ishs. * .,issr;,... ...........................,is1s;. * .,is1si;:,....................,:;ir1sr;, * ..:isssssrrii;::::::;;iirsssssr;:.. * .,::iiirsssssssssrri;;:. */\t/*** * ii. ;9ABH, * SA391, .r9GG35\u0026amp;G * \u0026amp;#ii13Gh; i3X31i;:,rB1 * iMs,:,i5895, .5G91:,:;:s1:8A * 33::::,,;5G5, ,58Si,,:::,sHX;iH1 * Sr.,:;rs13BBX35hh11511h5Shhh5S3GAXS:.,,::,,1AG3i,GG * .G51S511sr;;iiiishS8G89Shsrrsh59S;.,,,,,..5A85Si,h8 * :SB9s:,............................,,,.,,,SASh53h,1G. * .r18S;..,,,,,,,,,,,,,,,,,,,,,,,,,,,,,....,,.1H315199,rX, * ;S89s,..,,,,,,,,,,,,,,,,,,,,,,,....,,.......,,,;r1ShS8,;Xi * i55s:.........,,,,,,,,,,,,,,,,.,,,......,.....,,....r9\u0026amp;5.:X1 * 59;.....,. .,,,,,,,,,,,... .............,..:1;.:\u0026amp;s * s8,..;53S5S3s. .,,,,,,,.,.. i15S5h1:.........,,,..,,:99 * 93.:39s:rSGB@A; ..,,,,..... .SG3hhh9G\u0026amp;BGi..,,,,,,,,,,,,.,83 * G5.G8 9#@@@@@X. .,,,,,,..... iA9,.S\u0026amp;B###@@Mr...,,,,,,,,..,.;Xh * Gs.X8 S@@@@@@@B:..,,,,,,,,,,. rA1 ,A@@@@@@@@@H:........,,,,,,.iX: * ;9. ,8A#@@@@@@#5,.,,,,,,,,,... 9A. 8@@@@@@@@@@M; ....,,,,,,,,S8 * X3 iS8XAHH8s.,,,,,,,,,,...,..58hH@@@@@@@@@Hs ...,,,,,,,:Gs * r8, ,,,...,,,,,,,,,,..... ,h8XABMMHX3r. .,,,,,,,.rX: * :9, . .:,..,:;;;::,.,,,,,.. .,,. ..,,,,,,.59 * .Si ,:.i8HBMMMMMB\u0026amp;5,.... . .,,,,,.sMr * SS :: h@@@@@@@@@@#; . ... . ..,,,,iM5 * 91 . ;:.,1\u0026amp;@@@@@@MXs. . .,,:,:\u0026amp;S * hS .... .:;,,,i3MMS1;..,..... . . ... ..,:,.99 * ,8; ..... .,:,..,8Ms:;,,,... .,::.83 * s\u0026amp;: .... .sS553B@@HX3s;,. .,;13h. .:::\u0026amp;1 * SXr . ...;s3G99XA\u0026amp;X88Shss11155hi. ,;:h\u0026amp;, * iH8: . .. ,;iiii;,::,,,,,. .;irHA * ,8X5; . ....... ,;iihS8Gi * 1831, .,;irrrrrs\u0026amp;@ * ;5A8r. .:;iiiiirrss1H * :X@H3s....... .,:;iii;iiiiirsrh * r#h:;,...,,.. .,,:;;;;;:::,... .:;;;;;;iiiirrss1 * ,M8 ..,....,.....,,::::::,,... . .,;;;iiiiiirss11h * 8B;.,,,,,,,.,..... . .. .:;;;;iirrsss111h * i@5,:::,,,,,,,,.... . . .:::;;;;;irrrss111111 * 9Bi,:,,,,...... ..r91;;;;;iirrsss1ss1111 */ /*** * ░░░░░░░░░░░░░░░░░░░░░░░░▄░░ * ░░░░░░░░░▐█░░░░░░░░░░░▄▀▒▌░ * ░░░░░░░░▐▀▒█░░░░░░░░▄▀▒▒▒▐ * ░░░░░░░▐▄▀▒▒▀▀▀▀▄▄▄▀▒▒▒▒▒▐ * ░░░░░▄▄▀▒░▒▒▒▒▒▒▒▒▒█▒▒▄█▒▐ * ░░░▄▀▒▒▒░░░▒▒▒░░░▒▒▒▀██▀▒▌ * ░░▐▒▒▒▄▄▒▒▒▒░░░▒▒▒▒▒▒▒▀▄▒▒ * ░░▌░░▌█▀▒▒▒▒▒▄▀█▄▒▒▒▒▒▒▒█▒▐ * ░▐░░░▒▒▒▒▒▒▒▒▌██▀▒▒░░░▒▒▒▀▄ * ░▌░▒▄██▄▒▒▒▒▒▒▒▒▒░░░░░░▒▒▒▒ * ▀▒▀▐▄█▄█▌▄░▀▒▒░░░░░░░░░░▒▒▒ * 单身狗就这样默默地看着你，一句话也不说。 */ 滑稽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /*** * .,, .,:;;iiiiiiiii;;:,,. .,, * rGB##HS,.;iirrrrriiiiiiiiiirrrrri;,s\u0026amp;##MAS, * r5s;:r3AH5iiiii;;;;;;;;;;;;;;;;iiirXHGSsiih1, * .;i;;s91;;;;;;::::::::::::;;;;iS5;;;ii: * :rsriii;;r::::::::::::::::::::::;;,;;iiirsi, * .,iri;;::::;;;;;;::,,,,,,,,,,,,,..,,;;;;;;;;iiri,,. * ,9BM\u0026amp;, .,:;;:,,,,,,,,,,,hXA8: ..,,,. * ,;\u0026amp;@@#r:;;;;;::::,,. ,r,,,,,,,,,,iA@@@s,,:::;;;::,,. .;. * :ih1iii;;;;;::::;;;;;;;:,,,,,,,,,,;i55r;;;;;;;;;iiirrrr,.. * .ir;;iiiiiiiiii;;;;::::::,,,,,,,:::::,,:;;;iiiiiiiiiiiiri * iriiiiiiiiiiiiiiii;;;::::::::::::::::;;;iiiiiiiiiiiiiiiir; * ,riii;;;;;;;;;;;;;:::::::::::::::::::::::;;;;;;;;;;;;;;iiir. * iri;;;::::,,,,,,,,,,:::::::::::::::::::::::::,::,,::::;;iir: * .rii;;::::,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,::::;;iri * ,rii;;;::,,,,,,,,,,,,,:::::::::::,:::::,,,,,,,,,,,,,:::;;;iir. * ,rii;;i::,,,,,,,,,,,,,:::::::::::::::::,,,,,,,,,,,,,,::i;;iir. * ,rii;;r::,,,,,,,,,,,,,:,:::::,:,:::::::,,,,,,,,,,,,,::;r;;iir. * .rii;;rr,:,,,,,,,,,,,,,,:::::::::::::::,,,,,,,,,,,,,:,si;;iri * ;rii;:1i,,,,,,,,,,,,,,,,,,:::::::::,,,,,,,,,,,,,,,:,ss:;iir: * .rii;;;5r,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,sh:;;iri * ;rii;:;51,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.:hh:;;iir, * irii;::hSr,.,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,.,sSs:;;iir: * irii;;:iSSs:.,,,,,,,,,,,,,,,,,,,,,,,,,,,..:135;:;;iir: * ;rii;;:,r535r:...,,,,,,,,,,,,,,,,,,..,;sS35i,;;iirr: * :rrii;;:,;1S3Shs;:,............,:is533Ss:,;;;iiri, * .;rrii;;;:,;rhS393S55hh11hh5S3393Shr:,:;;;iirr: * .;rriii;;;::,:;is1h555555h1si;:,::;;;iirri:. * .:irrrii;;;;;:::,,,,,,,,:::;;;;iiirrr;, * .:irrrriiiiii;;;;;;;;iiiiiirrrr;,. * .,:;iirrrrrrrrrrrrrrrrri;:. * ..,:::;;;;:::,,. */ 物件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 /*** * ┌───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┬───┐ ┌───┬───┬───┐ * │Esc│ │ F1│ F2│ F3│ F4│ │ F5│ F6│ F7│ F8│ │ F9│F10│F11│F12│ │P/S│S L│P/B│ ┌┐ ┌┐ ┌┐ * └───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┴───┘ └───┴───┴───┘ └┘ └┘ └┘ * ┌───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───┬───────┐ ┌───┬───┬───┐ ┌───┬───┬───┬───┐ * │~ `│! 1│@ 2│# 3│$ 4│% 5│^ 6│\u0026amp; 7│* 8│( 9│) 0│_ -│+ =│ BacSp │ │Ins│Hom│PUp│ │N L│ / │ * │ - │ * ├───┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─────┤ ├───┼───┼───┤ ├───┼───┼───┼───┤ * │ Tab │ Q │ W │ E │ R │ T │ Y │ U │ I │ O │ P │{ [│} ]│ | \\ │ │Del│End│PDn│ │ 7 │ 8 │ 9 │ │ * ├─────┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴┬──┴─────┤ └───┴───┴───┘ ├───┼───┼───┤ + │ * │ Caps │ A │ S │ D │ F │ G │ H │ J │ K │ L │: ;│\u0026#34; \u0026#39;│ Enter │ │ 4 │ 5 │ 6 │ │ * ├──────┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴─┬─┴────────┤ ┌───┐ ├───┼───┼───┼───┤ * │ Shift │ Z │ X │ C │ V │ B │ N │ M │\u0026lt; ,│\u0026gt; .│? /│ Shift │ │ ↑ │ │ 1 │ 2 │ 3 │ │ * ├─────┬──┴─┬─┴──┬┴───┴───┴───┴───┴───┴──┬┴───┼───┴┬────┬────┤ ┌───┼───┼───┐ ├───┴───┼───┤ E││ * │ Ctrl│ │Alt │ Space │ Alt│ │ │Ctrl│ │ ← │ ↓ │ → │ │ 0 │ . │←─┘│ * └─────┴────┴────┴───────────────────────┴────┴────┴────┴────┘ └───┴───┴───┘ └───────┴───┴───┘ */ /*** * ,----------------, ,---------, * ,-----------------------, ,\u0026#34; ,\u0026#34;| * ,\u0026#34; ,\u0026#34;| ,\u0026#34; ,\u0026#34; | * +-----------------------+ | ,\u0026#34; ,\u0026#34; | * | .-----------------. | | +---------+ | * | | | | | | -==----\u0026#39;| | * | | I LOVE DOS! | | | | | | * | | Bad command or | | |/----|`---= | | * | | C:\\\u0026gt;_ | | | ,/|==== ooo | ; * | | | | | // |(((( [33]| ,\u0026#34; * | `-----------------\u0026#39; |,\u0026#34; .;\u0026#39;| |(((( | ,\u0026#34; * +-----------------------+ ;; | | |,\u0026#34; * /_)______________(_/ //\u0026#39; | +---------+ * ___________________________/___ `, * / oooooooooooooooo .o. oooo /, \\,\u0026#34;----------- * / ==ooooooooooooooo==.o. ooo= // ,`\\--{)B ,\u0026#34; * /_==__==========__==_ooo__ooo=_/\u0026#39; /___________,\u0026#34; * */ /*** * .-~~~~~~~~~-._ _.-~~~~~~~~~-. * __.\u0026#39; ~. .~ `.__ * .\u0026#39;// \\./ \\\\`. * .\u0026#39;// | \\\\`. * .\u0026#39;// .-~\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;~~~~-._ | _,-~~~~\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;~-. \\\\`. * .\u0026#39;//.-\u0026#34; `-. | .-\u0026#39; \u0026#34;-.\\\\`. * .\u0026#39;//______.============-.. \\ | / ..-============.______\\\\`. * .\u0026#39;______________________________\\|/______________________________`. * */ 佛祖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 /*** * _ooOoo_ * o8888888o * 88\u0026#34; . \u0026#34;88 * (| -_- |) * O\\ = /O * ____/`---\u0026#39;\\____ * . \u0026#39; \\\\| |// `. * / \\\\||| : |||// \\ * / _||||| -:- |||||- \\ * | | \\\\\\ - /// | | * | \\_| \u0026#39;\u0026#39;\\---/\u0026#39;\u0026#39; | | * \\ .-\\__ `-` ___/-. / * ___`. .\u0026#39; /--.--\\ `. . __ * .\u0026#34;\u0026#34; \u0026#39;\u0026lt; `.___\\_\u0026lt;|\u0026gt;_/___.\u0026#39; \u0026gt;\u0026#39;\u0026#34;\u0026#34;. * | | : `- \\`.;`\\ _ /`;.`/ - ` : | | * \\ \\ `-. \\_ __\\ /__ _/ .-` / / * ======`-.____`-.___\\_____/___.-`____.-\u0026#39;====== * `=---=\u0026#39; * * ............................................. * 佛祖保佑 永无BUG */ /*** * 佛曰: * 写字楼里写字间，写字间里程序员； * 程序人员写程序，又拿程序换酒钱。 * 酒醒只在网上坐，酒醉还来网下眠； * 酒醉酒醒日复日，网上网下年复年。 * 但愿老死电脑间，不愿鞠躬老板前； * 奔驰宝马贵者趣，公交自行程序员。 * 别人笑我忒疯癫，我笑自己命太贱； * 不见满街漂亮妹，哪个归得程序员？ */ /*** * _ooOoo_ * o8888888o * 88\u0026#34; . \u0026#34;88 * (| -_- |) * O\\ = /O * ___/`---\u0026#39;\\____ * . \u0026#39; \\\\| |// `. * / \\\\||| : |||// \\ * / _||||| -:- |||||- \\ * | | \\\\\\ - /// | | * | \\_| \u0026#39;\u0026#39;\\---/\u0026#39;\u0026#39; | | * \\ .-\\__ `-` ___/-. / * ___`. .\u0026#39; /--.--\\ `. . __ * .\u0026#34;\u0026#34; \u0026#39;\u0026lt; `.___\\_\u0026lt;|\u0026gt;_/___.\u0026#39; \u0026gt;\u0026#39;\u0026#34;\u0026#34;. * | | : `- \\`.;`\\ _ /`;.`/ - ` : | | * \\ \\ `-. \\_ __\\ /__ _/ .-` / / * ======`-.____`-.___\\_____/___.-`____.-\u0026#39;====== * `=---=\u0026#39; * ............................................. * 佛曰：bug泛滥，我已瘫痪！ */ FUCK 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 /*** * * █████▒█ ██ ▄████▄ ██ ▄█▀ ██████╗ ██╗ ██╗ ██████╗ * ▓██ ▒ ██ ▓██▒▒██▀ ▀█ ██▄█▒ ██╔══██╗██║ ██║██╔════╝ * ▒████ ░▓██ ▒██░▒▓█ ▄ ▓███▄░ ██████╔╝██║ ██║██║ ███╗ * ░▓█▒ ░▓▓█ ░██░▒▓▓▄ ▄██▒▓██ █▄ ██╔══██╗██║ ██║██║ ██║ * ░▒█░ ▒▒█████▓ ▒ ▓███▀ ░▒██▒ █▄ ██████╔╝╚██████╔╝╚██████╔╝ * ▒ ░ ░▒▓▒ ▒ ▒ ░ ░▒ ▒ ░▒ ▒▒ ▓▒ ╚═════╝ ╚═════╝ ╚═════╝ * ░ ░░▒░ ░ ░ ░ ▒ ░ ░▒ ▒░ * ░ ░ ░░░ ░ ░ ░ ░ ░░ ░ * ░ ░ ░ ░ ░ */ /*** * .::::. * .::::::::. * ::::::::::: FUCK YOU * ..:::::::::::\u0026#39; * \u0026#39;::::::::::::\u0026#39; * .:::::::::: * \u0026#39;::::::::::::::.. * ..::::::::::::. * ``:::::::::::::::: * ::::``:::::::::\u0026#39; .:::. * ::::\u0026#39; \u0026#39;:::::\u0026#39; .::::::::. * .::::\u0026#39; :::: .:::::::\u0026#39;::::. * .:::\u0026#39; ::::: .:::::::::\u0026#39; \u0026#39;:::::. * .::\u0026#39; :::::.:::::::::\u0026#39; \u0026#39;:::::. * .::\u0026#39; ::::::::::::::\u0026#39; ``::::. * ...::: ::::::::::::\u0026#39; ``::. * ```` \u0026#39;:. \u0026#39;:::::::::\u0026#39; ::::.. * \u0026#39;.:::::\u0026#39; \u0026#39;:\u0026#39;````.. */ 神兽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 /*** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ ─┬┘ └┬─ │ * │ │ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! */ /*** * ┌─┐ ┌─┐ * ┌──┘ ┴───────┘ ┴──┐ * │ │ * │ ─── │ * │ \u0026gt; \u0026lt; │ * │ │ * │ ... ⌒ ... │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ * 神兽保佑 * 代码无BUG! */ /*** * ┌─┐ ┌─┐ + + * ┌──┘ ┴───────┘ ┴──┐++ * │ │ * │ ─── │++ + + + * ███████───███████ │+ * │ │+ * │ ─┴─ │ * │ │ * └───┐ ┌───┘ * │ │ * │ │ + + * │ │ * │ └──────────────┐ * │ │ * │ ├─┐ * │ ┌─┘ * │ │ * └─┐ ┐ ┌───────┬──┐ ┌──┘ + + + + * │ ─┤ ─┤ │ ─┤ ─┤ * └──┴──┘ └──┴──┘ + + + + * 神兽保佑 * 代码无BUG! */ /*** * ___====-_ _-====___ * _--^^^#####// \\\\#####^^^--_ * _-^##########// ( ) \\\\##########^-_ * -############// |\\^^/| \\\\############- * _/############// (@::@) \\\\############\\_ * /#############(( \\\\// ))#############\\ * -###############\\\\ (oo) //###############- * -#################\\\\ / VV \\ //#################- * -###################\\\\/ \\//###################- * _#/|##########/\\######( /\\ )######/\\##########|\\#_ * |/ |#/\\#/\\#/\\/ \\#/\\##\\ | | /##/\\#/ \\/\\#/\\#/\\#| \\| * ` |/ V V ` V \\#\\| | | |/#/ V \u0026#39; V V \\| \u0026#39; * ` ` ` ` / | | | | \\ \u0026#39; \u0026#39; \u0026#39; \u0026#39; * ( | | | | ) * __\\ | | | | /__ * (vvv(VVV)(VVV)vvv) * 神兽保佑 * 代码无BUG! */ /*** * * * __----~~~~~~~~~~~------___ * . . ~~//====...... __--~ ~~ * -. \\_|// |||\\\\ ~~~~~~::::... /~ * ___-==_ _-~o~ \\/ ||| \\\\ _/~~- * __---~~~.==~||\\=_ -_--~/_-~|- |\\\\ \\\\ _/~ * _-~~ .=~ | \\\\-_ \u0026#39;-~7 /- / || \\ / * .~ .~ | \\\\ -_ / /- / || \\ / * / ____ / | \\\\ ~-_/ /|- _/ .|| \\ / * |~~ ~~|--~~~~--_ \\ ~==-/ | \\~--===~~ .\\ * \u0026#39; ~-| /| |-~\\~~ __--~~ * |-~~-_/ | | ~\\_ _-~ /\\ * / \\ \\__ \\/~ \\__ * _--~ _/ | .-~~____--~-/ ~~==. * ((-\u0026gt;/~ \u0026#39;.|||\u0026#39; -_| ~~-/ , . _|| * -_ ~\\ ~~---l__i__i__i--~~_/ * _-~-__ ~) \\--______________--~~ * //.-~~~-~_--~- |-------~~~~~~~~ * //.-~~~--\\ * 神兽保佑 * 代码无BUG! */ 嘲讽 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 /*** _ * _._ _..._ .-\u0026#39;, _.._(`)) * \u0026#39;-. ` \u0026#39; /-._.-\u0026#39; \u0026#39;,/ * ) \\ \u0026#39;. * / _ _ | \\ * | a a / | * \\ .-. ; * \u0026#39;-(\u0026#39;\u0026#39; ).-\u0026#39; ,\u0026#39; ; * \u0026#39;-; | .\u0026#39; * \\ \\ / * | 7 .__ _.-\\ \\ * | | | ``/ /` / * /,_| | /,_/ / * /,_/ \u0026#39;`-\u0026#39; */ /*** ************************************************************** * * * .=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-. * * | ______ | * * | .-\u0026#34; \u0026#34;-. | * * | / \\ | * * | _ | | _ | * * | ( \\ |, .-. .-. ,| / ) | * * | \u0026gt; \u0026#34;=._ | )(__/ \\__)( | _.=\u0026#34; \u0026lt; | * * | (_/\u0026#34;=._\u0026#34;=._ |/ /\\ \\| _.=\u0026#34;_.=\u0026#34;\\_) | * * | \u0026#34;=._\u0026#34;(_ ^^ _)\u0026#34;_.=\u0026#34; | * * | \u0026#34;=\\__|IIIIII|__/=\u0026#34; | * * | _.=\u0026#34;| \\IIIIII/ |\u0026#34;=._ | * * | _ _.=\u0026#34;_.=\u0026#34;\\ /\u0026#34;=._\u0026#34;=._ _ | * * | ( \\_.=\u0026#34;_.=\u0026#34; `--------` \u0026#34;=._\u0026#34;=._/ ) | * * | \u0026gt; _.=\u0026#34; \u0026#34;=._ \u0026lt; | * * | (_/ \\_) | * * | | * * \u0026#39;-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=\u0026#39; * * * * LASCIATE OGNI SPERANZA, VOI CH\u0026#39;ENTRATE * ************************************************************** */ /*** * ,s555SB@@\u0026amp; * :9H####@@@@@Xi * 1@@@@@@@@@@@@@@8 * ,8@@@@@@@@@B@@@@@@8 * :B@@@@X3hi8Bs;B@@@@@Ah, * ,8i r@@@B: 1S ,M@@@@@@#8; * 1AB35.i: X@@8 . SGhr ,A@@@@@@@@S * 1@h31MX8 18Hhh3i .i3r ,A@@@@@@@@@5 * ;@\u0026amp;i,58r5 rGSS: :B@@@@@@@@@@A * 1#i . 9i hX. .: .5@@@@@@@@@@@1 * sG1, ,G53s. 9#Xi;hS5 3B@@@@@@@B1 * .h8h.,A@@@MXSs, #@H1: 3ssSSX@1 * s ,@@@@@@@@@@@@Xhi, r#@@X1s9M8 .GA981 * ,. rS8H#@@@@@@@@@@#HG51;. .h31i;9@r .8@@@@BS;i; * .19AXXXAB@@@@@@@@@@@@@@#MHXG893hrX#XGGXM@@@@@@@@@@MS * s@@MM@@@hsX#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\u0026amp;, * :GB@#3G@@Brs ,1GM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@B, * .hM@@@#@@#MX 51 r;iSGAM@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@8 * :3B@@@@@@@@@@@\u0026amp;9@h :Gs .;sSXH@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@: * s\u0026amp;HA#@@@@@@@@@@@@@@M89A;.8S. ,r3@@@@@@@@@@@@@@@@@@@@@@@@@@@r * ,13B@@@@@@@@@@@@@@@@@@@5 5B3 ;. ;@@@@@@@@@@@@@@@@@@@@@@@@@@@i * 5#@@#\u0026amp;@@@@@@@@@@@@@@@@@@9 .39: ;@@@@@@@@@@@@@@@@@@@@@@@@@@@; * 9@@@X:MM@@@@@@@@@@@@@@@#; ;31. H@@@@@@@@@@@@@@@@@@@@@@@@@@: * SH#@B9.rM@@@@@@@@@@@@@B :. 3@@@@@@@@@@@@@@@@@@@@@@@@@@5 * ,:. 9@@@@@@@@@@@#HB5 .M@@@@@@@@@@@@@@@@@@@@@@@@@B * ,ssirhSM@\u0026amp;1;i19911i,. s@@@@@@@@@@@@@@@@@@@@@@@@@@S * ,,,rHAri1h1rh\u0026amp;@#353Sh: 8@@@@@@@@@@@@@@@@@@@@@@@@@#: * .A3hH@#5S553\u0026amp;@@#h i:i9S #@@@@@@@@@@@@@@@@@@@@@@@@@A. * * * 又看源码，看你妹妹呀！ */ 初音 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /*** *_______________#########_______________________ *______________############_____________________ *______________#############____________________ *_____________##__###########___________________ *____________###__######_#####__________________ *____________###_#######___####_________________ *___________###__##########_####________________ *__________####__###########_####_______________ *________#####___###########__#####_____________ *_______######___###_########___#####___________ *_______#####___###___########___######_________ *______######___###__###########___######_______ *_____######___####_##############__######______ *____#######__#####################_#######_____ *____#######__##############################____ *___#######__######_#################_#######___ *___#######__######_######_#########___######___ *___#######____##__######___######_____######___ *___#######________######____#####_____#####____ *____######________#####_____#####_____####_____ *_____#####________####______#####_____###______ *______#####______;###________###______#________ *________##_______####________####______________ */ 好耶 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 /*** * 頂頂頂頂頂頂頂頂頂　頂頂頂頂頂頂頂頂頂 * 頂頂頂頂頂頂頂　頂頂　* 頂頂　頂頂頂頂頂頂頂頂頂頂頂 * 頂頂　頂頂頂頂頂頂頂頂頂頂頂 * 頂頂　頂頂　頂頂 * 頂頂　頂頂　頂頂頂　頂頂 * 頂頂　頂頂　頂頂頂　頂頂 * 頂頂　頂頂　頂頂頂　頂頂 * 頂頂　頂頂　頂頂頂　頂頂 * 頂頂　頂頂頂　* 頂頂　頂頂　頂頂　頂頂 * 頂頂頂頂　頂頂頂頂頂　頂頂頂頂頂 * 頂頂頂頂　頂頂頂頂　頂頂頂頂 */ /*** * /88888888888888888888888888\\ * |88888888888888888888888888/ * |~~____~~~~~~~~~\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;| * / \\_________/\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\\ * / | \\ \\ * / | 88 88 \\ \\ * / | 88 88 \\ \\ * / / \\ | * / | ________ \\ | * \\ | \\______/ / | * /\u0026#34;\\ \\ \\____________ / | * | |__________\\_ | | / / * /\u0026#34;\u0026#34;\u0026#34;\u0026#34;\\ \\_------\u0026#39; \u0026#39;-------/ -- * \\____/,___________\\ -------/ * ------* | \\ * || | \\ * || | ^ \\ * || | | \\ \\ * || | | \\ \\ * || | | \\ \\ * \\| / /\u0026#34;\u0026#34;\u0026#34;\\/ / * ------------- | | / * |\\--_ \\____/___/ * | |\\-_ | * | | \\_ | * | | \\ | * | | \\_ | * | | ----___ | * | | \\----------| * / | | ----------\u0026#34;\u0026#34;\\ * /\u0026#34;\\--\u0026#34;--_| | | \\ * |_______/ \\______________/ ) * \\___/ */ /*** * d*##$. * zP\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;$e. $\u0026#34; $o * 4$ \u0026#39;$ $\u0026#34; $ * \u0026#39;$ \u0026#39;$ J$ $F * \u0026#39;b $k $\u0026gt; $ * $k $r J$ d$ * \u0026#39;$ $ $\u0026#34; $~ * \u0026#39;$ \u0026#34;$ \u0026#39;$E $ * $ $L $\u0026#34; $F ... * $. 4B $ $$$*\u0026#34;\u0026#34;\u0026#34;*b * \u0026#39;$ $. $$ $$ $F * \u0026#34;$ R$ $F $\u0026#34; $ * $k ?$ u* dF .$ * ^$. $$\u0026#34; z$ u$$$$e * #$b $E.dW@e$\u0026#34; ?$ * #$ .o$$# d$$$$c ?F * $ .d$$#\u0026#34; . zo$\u0026gt; #$r .uF * $L .u$*\u0026#34; $\u0026amp;$$$k .$$d$$F * $$\u0026#34; \u0026#34;\u0026#34;^\u0026#34;$$$P\u0026#34;$P9$ * JP .o$$$$u:$P $$ * $ ..ue$\u0026#34; \u0026#34;\u0026#34; $\u0026#34; * d$ $F $ * $$ ....udE 4B * #$ \u0026#34;\u0026#34;\u0026#34;\u0026#34;` $r @$ * ^$L \u0026#39;$ $F * RN 4N $ * *$b d$ * $$k $F * $$b $F * $\u0026#34;\u0026#34; $F * \u0026#39;$ $ * $L $ * \u0026#39;$ $ * $ $ */ 网站 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 /*** * ,%%%%%%%%, * ,%%/\\%%%%/\\%% * ,%%%\\c \u0026#34;\u0026#34; J/%%% * %. %%%%/ o o \\%%% * `%%. %%%% _ |%%% * `%% `%%%%(__Y__)%%\u0026#39; * // ;%%%%`\\-/%%%\u0026#39; * (( / `%%%%%%%\u0026#39; * \\\\ .\u0026#39; | * \\\\ / \\ | | * \\\\/ ) | | * \\ /_ | |__ * (___________))))))) 攻城湿 * * _ _ * __ _(_)_ _(_) __ _ _ __ * \\ \\ / / \\ \\ / / |/ _` |\u0026#39;_ \\ * \\ V /| |\\ V /| | (_| | | | | * \\_/ |_| \\_/ |_|\\__,_|_| |_| */ /*** * https://gold.xitu.io/ *　１１１　１　*　１１１　１１１１１１１１１１１１　１１１　*　１１　１１１１１１１１１１１１　１１１１１　*　１１　１１１　１１　１１１１１１１　*　１１１１　１　１１１１１１１１１１１　１１１　１１１１　*　１１１１１１　１１１１１１１１１１１　１１１１　１１１１１　*　１１１１１１　１１　１１１１　１１１１１１　*　１１　１１１１１１１１　１１　１１１１１１１１１１１１１１１１１１　*　１１　１１１１１１１１１１１　１１１１１１１１１１１１１１１１１１１　*　１１１１１１１１１　１１　１１　１１　１１　*　１１１１１１１１１１１１１１１１１１　１１　*　１１１１　１１１１１１１１１１１１　１１１１１１１１１１１１１１　*　１１１１　１１　１１　１１１１１１１１１１１１１１　*　１１　１１　１１　１１　１１１　１１　１１　１１１　*　１１　１１　１１　１１　１１　１１１　１１　１１１　*　１１　１１１　１１　１１　１１　１１１　１１　１１１　*　１１１１　１１１　１１１１１１１１１　１１　１１１　１１　１１１１１１１　*　１１１１１１　１１１１１１１１１１　１１１１１１１１１１１１１１１１１　*　１１　１１１　１１１　１１１１１１１１１１１１１１１１１　*/ /*** * https://www.zhihu.com/ * _____ _____ _____ _____ * /\\ \\ /\\ \\ /\\ \\ /\\ \\ * /::\\____\\ /::\\ \\ /::\\ \\ /::\\ \\ * /:::/ / \\:::\\ \\ /::::\\ \\ /::::\\ \\ * /:::/ / \\:::\\ \\ /::::::\\ \\ /::::::\\ \\ * /:::/ / \\:::\\ \\ /:::/\\:::\\ \\ /:::/\\:::\\ \\ * /:::/____/ \\:::\\ \\ /:::/__\\:::\\ \\ /:::/__\\:::\\ \\ * /::::\\ \\ /::::\\ \\ /::::\\ \\:::\\ \\ /::::\\ \\:::\\ \\ * /::::::\\ \\ _____ ____ /::::::\\ \\ /::::::\\ \\:::\\ \\ /::::::\\ \\:::\\ \\ * /:::/\\:::\\ \\ /\\ \\ /\\ \\ /:::/\\:::\\ \\ /:::/\\:::\\ \\:::\\____\\ /:::/\\:::\\ \\:::\\ \\ * /:::/ \\:::\\ /::\\____\\/::\\ \\/:::/ \\:::\\____\\/:::/ \\:::\\ \\:::| |/:::/__\\:::\\ \\:::\\____\\ * \\::/ \\:::\\ /:::/ /\\:::\\ /:::/ \\::/ /\\::/ |::::\\ /:::|____|\\:::\\ \\:::\\ \\::/ / * \\/____/ \\:::\\/:::/ / \\:::\\/:::/ / \\/____/ \\/____|:::::\\/:::/ / \\:::\\ \\:::\\ \\/____/ * \\::::::/ / \\::::::/ / |:::::::::/ / \\:::\\ \\:::\\ \\ * \\::::/ / \\::::/____/ |::|\\::::/ / \\:::\\ \\:::\\____\\ * /:::/ / \\:::\\ \\ |::| \\::/____/ \\:::\\ \\::/ / * /:::/ / \\:::\\ \\ |::| ~| \\:::\\ \\/____/ * /:::/ / \\:::\\ \\ |::| | \\:::\\ \\ * /:::/ / \\:::\\____\\ \\::| | \\:::\\____\\ * \\::/ / \\::/ / \\:| | \\::/ / * \\/____/ \\/____/ \\|___| \\/____/ */ /*** * http://www.freebuf.com/ * _.._ ,------------. * ,\u0026#39; `. ( We want you! ) * / __) __` \\ `-,----------\u0026#39; * ( (`-`(-\u0026#39;) ) _.-\u0026#39; * /) \\ = / ( * /\u0026#39; |--\u0026#39; . \\ * ( ,---| `-.)__` * )( `-.,--\u0026#39; _`-. * \u0026#39;/,\u0026#39; ( Uu\u0026#34;, * (_ , `/,-\u0026#39; ) * `.__, : `-\u0026#39;/ /`--\u0026#39; * | `--\u0026#39; | * ` `-._ / * \\ ( * /\\ . \\. freebuf * / |` \\ ,-\\ * / \\| .) / \\ * ( ,\u0026#39;|\\ ,\u0026#39; : * | \\,`.`--\u0026#34;/ } * `,\u0026#39; \\ |,\u0026#39; / * / \u0026#34;-._ `-/ | * \u0026#34;-. \u0026#34;-.,\u0026#39;| ; * / _/[\u0026#34;---\u0026#39;\u0026#34;\u0026#34;] * : / |\u0026#34;- \u0026#39; * \u0026#39; | / * ` | */ /*** * https://campus.alibaba.com/ * `:::::::::::, * `::;:::::::;:::::::, ` * `::;;:::::::@@@@;:::::::` * ,:::::::::::::@ #@\u0026#39;:::::` * :::::::::::::::\u0026#39;@@ @;:::: * ::::::::::::\u0026#39;@@@@\u0026#39;``` .+:::` * ::::::::::;@@@#. ,:::, * .::::::::+@#@` :::: * :::::::+@@\u0026#39; :::: * `:::::\u0026#39;@@: `:::. * ,::::@@: ` :::: * ;::::::@ .:::; * :;:::::;@` ` :::; * :::::::::@` @ ;:::: * :::::::::#` @` ,:::: * :::::::::@` +@ @ .::::` * .::::::\u0026#39;@@` `@@\u0026#39; @ ::::, * :::::::++@@@@@@@@@@. ::::; * ;:::::::+, `..` ::::: * ,::::::::\u0026#39;, ::::: * :::::::::+, :::::` * :::::::::+@. ,::::.` `, * ::::::;;@+ .::;:: `; * :::::::@@ `:::;: `::`` * ::::::#@ ;:::: .::` * :::::;@ :::::` .;::` * :::::@ `:;::: `::::; * :::::# :::::. `,;::::: * :::::: ` ::::::,.,::::::::::. * ,::::::` .:: ::::::::::::::::;` * ;::::::::,````.,:::::, ::::::::::::::. * :::::::::::::::::: ` `::::::::::` * `::::::::::::, .:::. * `..` */ /*** * http://www.flvcd.com/ * .--, .--, * ( ( \\.---./ ) ) * \u0026#39;.__/o o\\__.\u0026#39; * {= ^ =} * \u0026gt; - \u0026lt; * / \\ * // \\\\ * //| . |\\\\ * \u0026#34;\u0026#39;\\ /\u0026#39;\u0026#34;_.-~^`\u0026#39;-. * \\ _ /--\u0026#39; ` * ___)( )(___ * (((__) (__))) 高山仰止,景行行止.虽不能至,心向往之。 */ 👁-👁⃢ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /*** 无可奉告 一颗赛艇 * uJjYJYYLLv7r7vJJ5kqSFFFUUjJ7rrr7LLYLJLJ7 * JuJujuYLrvuEM@@@B@@@B@B@B@@@MG5Y7vLjYjJL * JYjYJvr7XM@BB8GOOE8ZEEO8GqM8OBBBMu77LLJ7 * LJLY7ru@@@BOZ8O8NXFFuSkSu25X0OFZ8MZJ;vLv * YvL7i5@BM8OGGqk22uvriiriii;r7LuSZXEMXrvr * vv7iU@BMNkF1uY7v7rr;iiii:i:i:ii7JEPNBPir * L7iL@BM8Xjuujvv77rr;ri;i;:iiiii:iLXFOBJ: * 7ri@B@MOFuUS2Y7L7777rii;:::::i:iirjPG@O: * 7:1B@BBOPjXXSJvrL7rr7iiii:i::::i;iv5MBB, * r:0@BBM8SFPX2Y77rri::iirri:::::iii75O@G. * 7:SB@BBGqXPk0122UJL::i::r:::i:i;i:v2@Bk. * ri:MB@BBEqEMGq2JLLL1u7.iX51u77LF27iSB@r, * ri,v@B@MB8@qqNEqN1u:5B8BOFE0S7ii7qMB@F:: * ii,J80Eq1MZkqPPX5YkPE@B@iXPE52j7:vBjE7:: * ii:7MSqkS0PvLv7rrii0@L.Z1iLr::ir:rO,vi:: * ii::EZXPSkquLvii:iF@N:.,BUi7ri,::UY;r::: * i::.2ONXqkPXS5FUUEOPP;..iSPXkjLYLLrr:::, * :::,iMXNP0NPLriiLGZ@BB1P87;JuL7r:7ri:::, * :::,.UGqNX0EZF2uUjUuULr:::,:7uuvv77::::. * ::::..5OXqXNJ50NSY;i:.,,,:i77Yvr;v;,,::. * :::,:.jOEPqPJiqBMMMO8NqP0SYLJriirv:.:,:. * ,:,,,.,Zq0P0X7vPFqF1ujLv7r:irrr7j7.,,::. * ,,,....0qk0080v75ujLLv7ri:i:rvj2J...,,,. * ......8@UXqZEMNvJjr;ii::,:::7uuv...,.,,. * .....B@BOvX88GMGk52vririiirJS1i.......,. * .JEMB@B@BMvL0MOMMMO8PE8GPqSk2L:......... * @B@@@B@M@B@L:7PGBOO8MOMOEP0Xri@B@Mk7,... * B@B@BBMBB@B@0::rJP8MO0uvvu7..,B@B@B@B@Z7 * MMBM@BBB@B@B@Br:i,..:Lur:....7@OMMBM@B@@ * 8OOMMMOMMMMBB@B:....,PZENNi..JBOZ8GMOOOO */ 参考链接 有趣的代码注释整理（魔性图注释） ","permalink":"https://lewky.cn/posts/program-comment-funny.html/","tags":["代码注释","funny"],"title":"分享一些有趣的代码注释"},{"categories":["前端"],"contents":"css绘制三角形 在盒子模型中border也占据了宽高，对于下面的样式：\n1 2 3 4 5 6 7 #div1{ width: 100px; height: 100px; border-style: solid; border-width: 100px 100px 100px 100px; border-color: red forestgreen blue cyan; } 效果如下：\n可以看到边框是由上下左右4个部分组成的，如果将div1的宽高设置为0，就变成如下效果：\n可以发现边框变成了4个等腰直角三角形，如果继续将上边框的宽度设置为0，如下：\n1 2 3 4 5 6 7 #div1{ width: 0; height: 0; border-style: solid; border-width: 0 100px 100px 100px; border-color: red forestgreen blue cyan; } 可以看到，上面的三角形不见了，而左右两个三角形变小了，所以可以通过设置4个边框宽度来自由调整三角形的形状。如果只需要其中某个三角形，只要将不需要的三角形颜色设置为透明即可，如下：\n1 2 3 4 5 6 7 8 #div1{ width: 0; height: 0; border-style: solid; border-width: 0 100px 100px 100px; border-color: transparent transparent blue transparent; } 效果如下：\n还可以通过设置不同的border-style来得到其他特殊的图形：\ncss绘制小猪佩奇 偶然看到的大佬的作品，这是效果页面，这是源码页面。\n好看的404页面 猴子动态SVG图 图片上方的文字我自己加的，可以无视之，关注本体的猴子动态图即可。\n这是效果页面，这是源码页面。\n参考链接 css如何将div画成三角形 用 CSS 画小猪佩奇，你就是下一个社会人！ 分享一个404页面（猴子动态SVG图） ","permalink":"https://lewky.cn/posts/front-end-funny.html/","tags":["前端","funny"],"title":"分享一些有趣的前端图形和页面"},{"categories":["PostgreSQL"],"contents":"前言 本文基于PostgreSQL 12.6版本，不同版本的函数可能存在差异。\n拼接字符串 ||是字符串连接操作符，在拼接字符串时要求前两个操作数至少有一个是字符串类型，不然会报错。如下：\n1 2 3 select \u0026#39;a\u0026#39; || 1; select 2 || \u0026#39;a\u0026#39; || 1; select 2 || 44 || \u0026#39;a\u0026#39; || 1; --Error 填充字符串 lpad(string text, length int [, fill text])是在字符串左边填充字符，如果不指定要填充的字符，则默认填充空格，如下：\n1 2 3 select LPAD((99 - 1)::text, 6); -- 98 select LPAD((99 - 1)::text, 6, \u0026#39;0\u0026#39;); --000098 select LPAD((99 + 1)::text, 6, \u0026#39;ab\u0026#39;); --aba100 rpad函数与lpad函数相反，是在字符串右边填充字符。\n大小写转换 upper和lower函数，如下：\n1 2 select upper(\u0026#39;test\u0026#39;); --TEST select lower(\u0026#39;TEST\u0026#39;); --test 获取字符串长度 length、char_length和character_length函数，如下：\n1 2 3 select length(\u0026#39;test\u0026#39;); --4 select char_length(\u0026#39;test\u0026#39;); --4 select character_length(\u0026#39;test\u0026#39;); --4 截取字符串 substring函数，支持下标范围截取或者正则表达式截取，如下：\n1 2 select substring(\u0026#39;PostgreSQL\u0026#39; from 2 for 4); --ostg select substring(\u0026#39;PostgreSQL\u0026#39; from \u0026#39;[a-z]+\u0026#39;); --ostgre 也可以用substr函数，如下：\n1 2 3 4 select substr(\u0026#39;PostgreSQL\u0026#39;, 2, 0); --空字符串 select substr(\u0026#39;PostgreSQL\u0026#39;, 2, 1); --o select substr(\u0026#39;PostgreSQL\u0026#39;, 2, 4); --ostg select substr(\u0026#39;PostgreSQL\u0026#39;, 2); --ostgreSQL 裁剪字符串 trim函数，从字符串的开头/结尾/两边（leading/trailing/both）尽可能多地裁剪指定的字符，不指定则裁剪空白符，如下：\n1 2 3 4 5 6 select trim(leading \u0026#39;x\u0026#39; from \u0026#39;xTestxx\u0026#39;); --Testxx select trim(trailing \u0026#39;x\u0026#39; from \u0026#39;xTestxx\u0026#39;); --xTest select trim(both \u0026#39;x\u0026#39; from \u0026#39;xTestxx\u0026#39;); --Test select trim(both from \u0026#39; Test \u0026#39;); --Test select trim(\u0026#39; Test \u0026#39;); --Test 也可以用ltrim，rtrim或者btrim函数，效果同上：\n1 2 3 select ltrim(\u0026#39;xTestxxy\u0026#39;, \u0026#39;xy\u0026#39;); --Testxxy select rtrim(\u0026#39;xTestxxy\u0026#39;, \u0026#39;xy\u0026#39;); --xTest select btrim(\u0026#39;xTestxxy\u0026#39;, \u0026#39;xy\u0026#39;); --Test 获取第一个字符的ASCII码 ascii函数，如下：\n1 2 select ascii(\u0026#39;test\u0026#39;); --116 select ascii(\u0026#39;t\u0026#39;); --116 如果想从ASCII码转成字符，则使用chr函数，参数是int，如下：\n1 select chr(65); --A 计算string的MD5散列 md5函数，以十六进制返回结果，如下：\n1 select md5(\u0026#39;abc\u0026#39;); --900150983cd24fb0d6963f7d28e17f72 null和\u0026rsquo;\u0026lsquo;的区别与判断以及COALESCE函数 null是一种类型，''是空字符串，打个比方，''是你参加了考试且得了零分，而null则是你压根就没有参加考试。\n如果要在sql中对两者进行判断，是有区别的：\n1 2 3 4 5 6 7 8 9 10 11 --null只能和is或is not搭配，不能使用=、!=或者\u0026lt;\u0026gt; select * from student where name is null; select * from student where name is not null; --\u0026#39;\u0026#39;的判断可以使用=、!=或者\u0026lt;\u0026gt; select * from student where name = \u0026#39;\u0026#39;; select * from student where name != \u0026#39;\u0026#39;; select * from student where name \u0026lt;\u0026gt; \u0026#39;\u0026#39;; --任何与null的运算比较，结果都是null select 1 \u0026gt; null; --null COALESCE函数是返回参数中的第一个非null的值，在PostgreSQL 10里，它要求参数中至少有一个是非null的，如果参数都是null会报错。\n不过在PostgreSQL 12.6版本COALESCE函数允许参数里只有null，此时返回值是null。\n1 2 3 4 5 6 select COALESCE(null,null); //报错 select COALESCE(null,null,now()::varchar,\u0026#39;\u0026#39;); //结果会得到当前的时间 select COALESCE(null,null,\u0026#39;\u0026#39;,now()::varchar); //结果会得到\u0026#39;\u0026#39; //可以和其他函数配合来实现一些复杂点的功能：查询学生姓名，如果学生名字为null或\u0026#39;\u0026#39;则显示“姓名为空” select case when coalesce(name,\u0026#39;\u0026#39;) = \u0026#39;\u0026#39; then \u0026#39;姓名为空\u0026#39; else name end from student; nullif函数 nullif(a, b)用来检测a参数是否与b参数相等，这里的a、b参数必须是同一种数据类型，否则会报错。当a参数与b参数相等时会返回null，否则返回a参数。\n可以用这个函数来检测期望以外的值，一般用于检测字符串比较多。如下：\n1 2 3 4 select nullif(\u0026#39;test\u0026#39;, \u0026#39;unexpected\u0026#39;);\t--test select nullif(\u0026#39;unexpected\u0026#39;, \u0026#39;unexpected\u0026#39;);\t--null select nullif(233, 111);\t--233 判断是否包含字符串 position函数会返回字符串首次出现的位置，如果没有出现则返回0。因此可以通过返回值是否大于0来判断是否包含指定的字符串。\n1 2 3 select position(\u0026#39;aa\u0026#39; in \u0026#39;abcd\u0026#39;);\t--0 select position(\u0026#39;bc\u0026#39; in \u0026#39;abcd\u0026#39;);\t--2 select position(\u0026#39;bc\u0026#39; in \u0026#39;abcdabc\u0026#39;);\t--2 strpos函数也是同样的效果：\n1 2 3 select strpos(\u0026#39;abcd\u0026#39;,\u0026#39;aa\u0026#39;);\t--0 select strpos(\u0026#39;abcd\u0026#39;,\u0026#39;bc\u0026#39;);\t--2 select strpos(\u0026#39;abcdabc\u0026#39;,\u0026#39;bc\u0026#39;);\t--2 此外还可以用正则表达式来判断，返回值是true或false：\n1 2 3 select \u0026#39;abcd\u0026#39; ~ \u0026#39;aa\u0026#39;;\t--false select \u0026#39;abcd\u0026#39; ~ \u0026#39;bc\u0026#39;;\t--true select \u0026#39;abcdabc\u0026#39; ~ \u0026#39;bc\u0026#39;;\t--true 合并字符串 string_agg函数可以将一个字符串列合并成一个字符串，该函数需要指定分隔符，还可以指定合并时的顺序，或者是对合并列进行去重：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 select ref_no from cnt_item where updated_on between \u0026#39;2021-05-05\u0026#39; and \u0026#39;2021-05-30 16:13:25\u0026#39;; --结果如下： --ITM2105-000001 --ITM2105-000002 --ITM2105-000003 --ITM2105-000003 select string_agg(ref_no, \u0026#39;,\u0026#39;) from cnt_item where updated_on between \u0026#39;2021-05-05\u0026#39; and \u0026#39;2021-05-30 16:13:25\u0026#39;; --合并结果：ITM2105-000001,ITM2105-000002,ITM2105-000003,ITM2105-000003 select string_agg(distinct ref_no, \u0026#39;,\u0026#39;) from cnt_item where updated_on between \u0026#39;2021-05-05\u0026#39; and \u0026#39;2021-05-30 16:13:25\u0026#39;; --合并结果：ITM2105-000001,ITM2105-000002,ITM2105-000003 select string_agg(distinct ref_no, \u0026#39;,\u0026#39; order by ref_no desc) from cnt_item where updated_on between \u0026#39;2021-05-05\u0026#39; and \u0026#39;2021-05-30 16:13:25\u0026#39;; --合并结果：ITM2105-000003,ITM2105-000002,ITM2105-000001 将字符串合并成一个数组 array_agg和string_agg函数类似，但会把一个字符串列合并成一个数组对象，同样支持指定合并顺序和去重操作；合并成数组后意味着你可以像数组那样去读取它，需要注意的是，数据库的数组下标是从1开始的，而不是从0开始：\n1 2 3 4 5 select array_agg(distinct ref_no) from cnt_item where updated_on between \u0026#39;2021-05-05\u0026#39; and \u0026#39;2021-05-30 16:13:25\u0026#39;; --合并结果：{ITM2105-000001,ITM2105-000002,ITM2105-000003} select (array_agg(distinct ref_no order by ref_no desc))[1] from cnt_item where updated_on between \u0026#39;2021-05-05\u0026#39; and \u0026#39;2021-05-30 16:13:25\u0026#39;; --结果：ITM2105-000003 该函数还可以搭配array_to_string函数将数组转合并成一个字符串：\n1 2 select array_to_string(array_agg(distinct ref_no), \u0026#39;\u0026amp;\u0026#39;) from cnt_item where updated_on between \u0026#39;2021-05-05\u0026#39; and \u0026#39;2021-05-30 16:13:25\u0026#39;; --合并结果：ITM2105-000001\u0026amp;ITM2105-000002\u0026amp;ITM2105-000003 分割字符串 string_to_array函数可以分割字符串，返回值是一个数组：\n1 2 select string_to_array(\u0026#39;ITM2105-000001\u0026amp;ITM2105-000002\u0026amp;ITM2105-000003\u0026#39;, \u0026#39;\u0026amp;\u0026#39;); --结果：{ITM2105-000001,ITM2105-000002,ITM2105-000003} 使用正则表达式分割字符串 regexp_split_to_table可以通过正则表达式来定义分隔符，将一个字符串分割成多个字符串，即将一条数据分隔成多条数据。有两个参数，第一个参数是需要被分隔的字符串，第二个参数是正则表达式。\n1 2 3 4 5 6 7 select regexp_split_to_table(trim(both \u0026#39;{}\u0026#39; from \u0026#39;{lbl.codelist} \u0026gt; {lbl.codelist.tabHeader} \u0026gt; {lbl.codelist.tabHeader.codelists}: 115 (993) \u0026gt; {lbl.codelist.tabHeader.codelists.name}\u0026#39;), \u0026#39;}[^}]*{\u0026#39;) as label; --结果：原字符串被分隔成四个字符串，并返回四行数据 lbl.codelist lbl.codelist.tabHeader lbl.codelist.tabHeader.codelists lbl.codelist.tabHeader.codelists.name raise函数打印字符串 在PostgreSQL中，raise函数用于打印字符串，类似于Java中的System.out.println()，Oracle中的dbms_output.put_line()。\n用法如下：\n1 raise notice \u0026#39;My name is %, I am a %.\u0026#39;, \u0026#39;Lewis\u0026#39;, \u0026#39;coder\u0026#39;; 以上sql会在控制台输出My name is Lewis, I am a coder.。如果是在DBeaver里使用该函数，则会在output的tab里输出字符串。\nraise后面的notice是级别，一共有debug/log/info/notice/warning/exception这些级别，可以任意指定一个级别。有些类似于Java里的日志框架，比如Log4j2之类的。\n接着级别后面的是要输出的字符串参数，用一对单引号包括起来。这个字符串支持占位符的写法，也就是%这个字符。如果在字符串里使用了这个%，那么会自动使用字符串参数后面的参数来替换掉这里的%。有多少个占位符，就需要在第一个字符串参数后面加上多少个对应的参数。\n这个占位符输出的用法，也和Log4j2类似。\n由raise打印出来的信息可以输出到服务端日志，也可以输出到客户端，亦或者同时输出到二者。这个是由log_min_messages和client_min_messages两个参数控制的，这两个参数在数据库初始化时用到。\n参考链接 postgresql 常用函数汇总 字符串函数和操作符 PostgreSQL 判断字符串包含的几种方法 PostgreSql 聚合函数string_agg与array_agg postgreSQL学习记录之raise用法 ","permalink":"https://lewky.cn/posts/postgresql-string.html/","tags":["工作记录"],"title":"PostgreSQL - 字符串函数汇总"},{"categories":["计算机"],"contents":"方法一 可能是rdpclip.exe进程出了问题，在任务管理器中找到该进程，选中后并结束进程。接着重启该进程：\nwin + R组合键打开运行窗口 输入rdpclip.exe，按下回车或确定按钮。 此时可以在任务管理器重新看到该进程，一般情况下就可以正常的在远程桌面复制粘贴了。\n方法二 如果方法一无效，可能是远程桌面的配置不对。在进行远程桌面之前，查看远程桌面窗口里的本地资源这个tab，勾选剪贴板。\n如果看不到本地资源这个tab，需要先点击窗口左下角的显示选项。\n参考链接 远程桌面无法复制粘贴的解决方法汇总 ","permalink":"https://lewky.cn/posts/remote-desktop-issue.html/","tags":["计算机"],"title":"远程桌面无法复制粘贴"},{"categories":["Java"],"contents":"日期格式化的跨年问题 通常格式化日期时，都是使用的YYYY/MM/dd来格式化日期，但是在遇到跨年日期时，就会遇到很神奇的现象，如下：\n1 2 3 4 5 6 7 8 9 10 11 final Calendar calendar = Calendar.getInstance(); // 2020-12-26 calendar.set(2020, 11, 26); final Date date1226 = calendar.getTime(); // 2020-12-27 calendar.set(2020, 11, 27); final Date date1227 = calendar.getTime(); // YYYY final DateFormat Y = new SimpleDateFormat(\u0026#34;YYYY/MM/dd\u0026#34;); System.out.println(\u0026#34;2020-12-26用YYYY/MM/dd表示:\u0026#34; + Y.format(date1226)); System.out.println(\u0026#34;2020-12-27用YYYY/MM/dd表示:\u0026#34; + Y.format(date1227)); 上述代码输出如下：\n1 2 2020-12-26用YYYY/MM/dd表示:2020/12/26 2020-12-27用YYYY/MM/dd表示:2021/12/27 可以看到，只是一天之差，格式化后却相差了整整一年！这是因为YYYY是基于周最后一天所在年份来格式化年份的，周日是每周第一天。而2020-12-27这天是周日，这一周最后一天属于2021年，于是就发生了上述的神奇现象。下面是官方文档：\nJava\u0026rsquo;s DateTimeFormatter pattern \u0026ldquo;YYYY\u0026rdquo; gives you the week-based-year, (by default, ISO-8601 standard) the year of the Thursday of that week.\n所以，想要得到正确的结果，需要使用yyyy来替代YYYY，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 final Calendar calendar = Calendar.getInstance(); // 2020-12-26 calendar.set(2020, 11, 26); final Date date1226 = calendar.getTime(); // 2020-12-27 calendar.set(2020, 11, 27); final Date date1227 = calendar.getTime(); // YYYY final DateFormat Y = new SimpleDateFormat(\u0026#34;YYYY/MM/dd\u0026#34;); System.out.println(\u0026#34;2020-12-26用YYYY/MM/dd表示:\u0026#34; + Y.format(date1226)); System.out.println(\u0026#34;2020-12-27用YYYY/MM/dd表示:\u0026#34; + Y.format(date1227)); // yyyy final DateFormat y = new SimpleDateFormat(\u0026#34;yyyy/MM/dd\u0026#34;); System.out.println(\u0026#34;2020-12-26用yyyy/MM/dd表示:\u0026#34; + y.format(date1226)); System.out.println(\u0026#34;2020-12-27用yyyy/MM/dd表示:\u0026#34; + y.format(date1227)); 结果如下：\n1 2 3 4 2020-12-26用YYYY/MM/dd表示:2020/12/26 2020-12-27用YYYY/MM/dd表示:2021/12/27 2020-12-26用yyyy/MM/dd表示:2020/12/26 2020-12-27用yyyy/MM/dd表示:2020/12/27 日期格式化异常 使用新的日期API格式化日期时发生如下异常：\n1 2 3 4 5 java.time.DateTimeException: Field DayOfYear cannot be printed as the value 320 exceeds the maximum print width of 2 at java.time.format.DateTimeFormatterBuilder$NumberPrinterParser.format(DateTimeFormatterBuilder.java:2548) at java.time.format.DateTimeFormatterBuilder$CompositePrinterParser.format(DateTimeFormatterBuilder.java:2179) at java.time.format.DateTimeFormatter.formatTo(DateTimeFormatter.java:1746) at java.time.format.DateTimeFormatter.format(DateTimeFormatter.java:1720) 这个跟日期格式有关，这里我使用的是YYMMDD来格式化日期：\n1 String currentDate = DateTimeFormatter.ofPattern(\u0026#34;yyMMDD\u0026#34;).format(LocalDateTime.now()) 如果当前日期是从四月的10号（闰年是四月9号）即之后的日期，就会遇到上述的异常。原因是格式化字符串中的D指的是一年的第几天，而这里用了两个D，表明天数是两位数（不足两位数会补前缀0）。如果使用了前文提及的日期，也就是说当前属于一年的100天以上的天数（即天数是3位数），与格式化指定的两位数冲突，因此抛出异常。\n这里想要的是每个月的天数，应当使用d，而不是大写的D。其实关于这类格式化字符需要注意大小写的问题，比如y和Y的含义也是不一样的。\nJDK 8新的日期和时间API 新版本的日期时间API主要分为：LocalDate、LocalTime、LocalDateTime、ZonedDateTime四个类。\n其中关系如下：\n1 2 3 4 5 LocalDateTime = LocalDate + LocalTime ZonedDateTime = LocalDateTime + ZoneOffset + ZoneId // ZoneId是时区id // ZoneOffset继承自ZoneId，表示时区对应的时间偏移量，比如东八区对比零时区的偏移量是+08:00，即快了八个小时 GMT，即格林尼治标准时间，也就是世界时。GMT的正午是指当太阳横穿格林尼治子午线（本初子午线）时的时间。但由于地球自转不均匀不规则，导致GMT不精确，现在已经不再作为世界标准时间使用。\nUTC，即协调世界时。UTC是以原子时秒长为基础，在时刻上尽量接近于GMT的一种时间计量系统。为确保UTC与GMT相差不会超过0.9秒，在有需要的情况下会在UTC内加上正或负闰秒。UTC现在作为世界标准时间使用。\n计算机中的UNIX时间戳，是以GMT/UTC时间「1970-01-01T00:00:00」为起点，到具体时间的秒数，不考虑闰秒。这么做当然是为了简化计算机对时间操作的复杂度。Java调试时经常使用到的System.currentTimeMillis()就是获取该时间戳对应的时间毫秒值。\n本地日期API 在不需要处理时区时使用：LocalDate、LocalTime、LocalDateTime，也就是获取系统默认时区的日期时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 // 本地日期 LocalDate localDate = LocalDate.now(); System.out.println(localDate); // 2021-05-12 System.out.println(localDate.getYear()); // 2021 System.out.println(localDate.getMonthValue()); // 5 System.out.println(localDate.getDayOfMonth()); // 12 System.out.println(localDate.withYear(2017).withMonth(7).withDayOfMonth(1)); // 2017-07-01 // 本地时间 LocalTime localTime = LocalTime.now(); System.out.println(localTime); // 00:13:19.738 System.out.println(localTime.getHour()); // 0 System.out.println(localTime.plusHours(1)); // 01:13:19.738 // 本地日期时间 LocalDateTime localDateTime = LocalDateTime.now(); System.out.println(localDateTime); // 2021-05-12T00:13:19.738 System.out.println(localDateTime.toLocalDate()); // 2021-05-12 System.out.println(localDateTime.toLocalTime()); // 00:13:19.738 System.out.println(localDateTime.getHour()); // 0 // 指定日期 System.out.println(LocalDate.of(2017, 7, 1)); // 2017-07-01 System.out.println(LocalTime.of(0, 0)); // 00:00 // 解析日期字符串 System.out.println(LocalTime.parse(\u0026#34;20:15:30\u0026#34;)); // 20:15:30 时区日期API 时区日期类是ZonedDateTime：\n1 2 3 4 5 6 7 8 9 10 // 时区日期时间 ZonedDateTime zonedDateTime = ZonedDateTime.now(); System.out.println(zonedDateTime); // 2021-05-12T08:22:21.404+08:00[Asia/Shanghai] System.out.println(zonedDateTime.getYear()); // 2021 System.out.println(zonedDateTime.getOffset()); // +08:00 System.out.println(zonedDateTime.getZone()); // Asia/Shanghai System.out.println(ZoneId.systemDefault()); // Asia/Shanghai System.out.println(ZoneId.SHORT_IDS.get(\u0026#34;CTT\u0026#34;));// Asia/Shanghai 日期和时区的转换 可以给本地日期加上时区信息，以此获取对应的时区日期。\n时区日期在转换时区时可以分为两种，一种是本地日期不变，单纯改变时区；另一种是将一个时区日期转换为其他时区的日期，此时不仅会改变时区，还会改变本地日期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 LocalDate localDate = LocalDate.parse(\u0026#34;2021-01-05\u0026#34;); // LocalDate转换为LocalDateTime LocalDateTime localDateTime = LocalDateTime.of(localDate, LocalTime.MIN); // 指定为东八区时间 ZonedDateTime zonedDateTime = localDateTime.atZone(ZoneId.of(\u0026#34;UTC+08:00\u0026#34;)); System.out.println(localDate); // 2021-01-05 System.out.println(localDateTime); // 2021-01-05T00:00 System.out.println(zonedDateTime); // 2021-01-05T00:00+08:00[UTC+08:00] // 日期格式化 // 2021-01-05T00:00:00.000Z System.out.println(localDateTime.format(DateTimeFormatter.ofPattern(\u0026#34;yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss.SSS\u0026#39;Z\u0026#39;\u0026#34;))); System.out.println(zonedDateTime.toLocalDateTime()); // 2021-01-05T00:00 System.out.println(zonedDateTime.toOffsetDateTime()); // 2021-01-05T00:00+08:00 System.out.println(zonedDateTime.getOffset()); // +08:00 System.out.println(zonedDateTime.getZone()); // UTC+08:00 // 换算为零时区时间 ZonedDateTime withZoneSameInstant = zonedDateTime.withZoneSameInstant(ZoneId.of(\u0026#34;Z\u0026#34;)); // 单纯修改时区信息 ZonedDateTime withZoneSameLocal = zonedDateTime.withZoneSameLocal(ZoneId.of(\u0026#34;Z\u0026#34;)); System.out.println(withZoneSameInstant.toLocalDateTime()); // 2021-01-04T16:00 System.out.println(withZoneSameLocal.toLocalDateTime()); // 2021-01-05T00:00 java.sql包下的类和新的日期类的转换： 1 2 3 4 5 6 7 8 9 10 11 12 13 // 2021-05-01 LocalDate localDate = LocalDate.of(2021, 5, 1); // 2021-05-01 final Date sqlDate = Date.valueOf(localDate); // 2021-05-01 localDate = sqlDate.toLocalDate(); // 2021-05-01T00:16:44.032 LocalDateTime localDateTime = LocalDateTime.of(localDate, LocalTime.now()); // 2021-05-01 00:16:44.032 final Timestamp timestamp = Timestamp.valueOf(localDateTime); // 2021-05-01T00:16:44.032 localDateTime = timestamp.toLocalDateTime(); 获取月份、年份的最后一天 JDK 8提供了TemporalAdjusters工具类来实现调整时间的功能：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 2021-07-27 final LocalDate localDate = LocalDate.now(); // 2021-07-01 System.out.println(localDate.with(TemporalAdjusters.firstDayOfMonth())); // 2021-01-01 System.out.println(localDate.with(TemporalAdjusters.firstDayOfYear())); // 2021-08-01 System.out.println(localDate.with(TemporalAdjusters.firstDayOfNextMonth())); // 2022-01-01 System.out.println(localDate.with(TemporalAdjusters.firstDayOfNextYear())); // 当月第一个周一： 2021-07-05 System.out.println(localDate.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY))); // 当月最后一个周五： 2021-07-30 System.out.println(localDate.with(TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY))); 比较两个日期 1 2 3 4 5 6 7 8 9 10 11 12 final LocalDate date1 = LocalDate.of(2021, 5, 1); final LocalDate date2 = LocalDate.of(2021, 5, 2); final LocalDate date3 = LocalDate.of(2021, 6, 2); // 1 System.out.println(Period.between(date1, date2).getDays()); // 1 System.out.println(Period.between(date1, date3).getDays()); // 1 System.out.println(date1.until(date2, ChronoUnit.DAYS)); // 32 System.out.println(date1.until(date3, ChronoUnit.DAYS)); Period只能用来比较两个日期之间的相对时间差，比如单纯比较年份、月份或者天数之间的相对差额，在比较的时候不会计算其他的时间单位，因此在比较2021-05-01和2021-06-02的天数差是1天，而不是32天。\n如果想要比较完整的天数差，需要用until()方法，要用日期更小的那个来调用这个方法，否则会得到负数结果。另外这个until()方法有两个，要使用带有时间单位的那个方法，如果不指定时间单位，返回值是Period，这样就变成Period一样的用法了。\n参考链接 Java YYYY/MM/dd遇到跨年日期的问题 YYYY-MM-DD 的黑锅，我们不背！ Java日期时间API系列19\u0026ndash;Jdk8，ZonedDateTime和时区转换。 【java8中的时间操作】java8中获取月的最后一天或者总天数，JDK8 LocalDate AP localdate 比较两个时间_Java 8中处理日期和时间示例 日期格式‘YYYY-MM-DD’中的BUG ","permalink":"https://lewky.cn/posts/java-date-issues.html/","tags":["Java","工作记录"],"title":"Java日期问题汇总"},{"categories":null,"contents":"主题相关 本站原主题是Hugo-LoveIt，感谢本主题的开发者们！\ndillonzq / LoveIt\r\"Hugo-LoveIt主题\"\rLoveIt官方文档\r\"Hugo-LoveIt主题官方文档\"\r★小伙伴★ 一只会飞的旺旺\r\"爱分享的Java程序猿\"\r肥子的Web Tools\r\"高级搬砖工 · Geek肥\"\r【群大佬】 欲穷三千界的博客\r\"十年饮冰，码血难凉的组长，大虎yyds~\"\r琉璃君的日常\r\"群龙王名号的长期持有者，兼职群共享女友~\"\r夜雨柠檬的博客\r\"追：追赶、追求、追梦\"\r【大佬们】 BBing\u0026#39;s Blog\r\"自由 分享 合作\"\rkirito\r\"被带歪也不能怨我\"\r框架师\r\"代码改变世界！\"\r徐泽林的博客\r\"唯书籍不朽\"\rpai233の小窝\r\"Write Down My Life.\"\rcywhat\u0026#39;s blog\r\"一位摸爬滚打的测开Dog.\"\rSukun的博客\r\"Sukun的博客，记录学习历程！\"\r低调小熊猫\r\"读万卷书，行万里路，赚很多钱\"\rDuan1v’s Blog\r\"一步两步是魔鬼的步伐\"\r亲自巡山的大王\r\"做一个有趣的人\"\rhao同学的技术博客\r\"一个痴迷于技术的厨艺爱好者\"\rFireGuo论坛\r\"FireGuo论坛-一个免费的讨论论坛，尽情发表言论吧！\"\rFireGuo博客\r\"一个普通初中生的普通博客，为了分享普通的技术知识\"\r企鹅小屋\r\"企鹅的小屋\"\rSMallTIAN’s Blog\r\"写我想写的，做我想做的。\"\r滑翔闪 Blog\r\"试图衡量有趣和深度的天平座\"\rRick’s Web Site\r\"路遙知碼力，日久練成精\"\rLS-Shandong\r\"LS-Shandong 的博客网站\"\rLogDict\r\"一个专注于记录, 分享, 学习的网站\"\r【网络安全】 W4J1e\u0026#39;s blog\r\"总是偏爱不务正业\"\r勤奋的思远\r\"一个网络安全爱好者的博客\"\rThrower的博客\r\"一名网络安全技术爱好者，汪峰的老歌迷。\"\r【Java】 Youth的时光录\r\"主要是Java技术栈的博客，比较偏原理，源码类型的博主\"\r牛牛技术客栈\r\"学习改变命运，分享创造价值\"\rLing\r\"羽翎轩\"\rSky\u0026#39;s Blog\r\"山河浪漫，人间温暖！\"\r〇°\r\"今天快乐\"\r【Go】 飞鸟记\r\"记录「技术」与「温度」\"\r【前端】 itsNekoDeng\r\"十万伏特皮卡丘，梦想是世界和平，想要发光发热\"\r小康博客\r\"一个收藏回忆与分享技术的地方！\"\r【十年之约】 十年之约，即从加入这个活动起，我们的博客十年不关闭，保持更新和活力！\n☞ 本站已加入【十年之约】！有兴趣的朋友可以点击下面的链接了解一哈~\n【十年之约】\r\"一个人的寂寞，一群人的狂欢。\"\r雨临Lewis的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r本站友链信息 1 2 3 4 5 6 name=\u0026#34;雨临Lewis的博客\u0026#34; url=\u0026#34;https://lewky.cn\u0026#34; logo=\u0026#34;https://lewky.cn/images/avatar.jpg\u0026#34; word=\u0026#34;不想当写手的码农不是好咸鱼_(xз」∠)_\u0026#34; screenshot=\u0026#34;https://lewky.cn/images/common/screenshot.jpg\u0026#34; group=\u0026#34;Java\u0026#34; 2233-line.png\r如何交换友链 请在本页评论区里（也可以通过邮件、或者提交GitHub Issue的方式）添加如下格式，添加友链成功后会通过回复评论的邮件通知进行反馈：\n1 2 3 4 5 //必填项 name=\u0026#34;站点名字\u0026#34; url=\u0026#34;站点地址\u0026#34; logo=\u0026#34;站点图标或个人头像\u0026#34; word=\u0026#34;站点描述\u0026#34; 下面是可选项：\n1 2 3 4 5 6 7 8 9 10 11 12 //默认分组是大佬们 group=\u0026#34;分组\u0026#34; //边框及鼠标悬停的背景颜色，允许设置渐变色 //支持7种：default、red、green、blue、linear-red、linear-green、linear-blue primary-color=\u0026#34;default\u0026#34; //头像动画：rotate(鼠标悬停时旋转，此为默认效果)、auto_rotate_left(左旋转)、auto_rotate_right(右旋转) img-animation=\u0026#34;rotate\u0026#34; //边框动画：shadow(阴影，此为默认效果)、borderFlash(边框闪现)、led(跑马灯)、bln(主颜色呼吸灯) border-animation=\u0026#34;shadow\u0026#34; 友链须知 上述的友链格式请使用英文的双引号。 若您的头像无法获取时，会自动使用默认头像。 当您的网站存在无法访问、404、友链入口难以发现、删除本站友链等情况时，本站可能会在不通知的情况下撤掉贵站链接！如需恢复需要再次申请。 ","permalink":"https://lewky.cn/friends/","tags":null,"title":"友链墙"},{"categories":["Hugo系列"],"contents":"前言 本文主要记录从Hexo迁移至Hugo所遇到的一些坑，以及Hugo的LoveIt主题的一些bug之类的应对方案。下面是涉及到的Hexo、Hugo以及LoveIt各自的版本：\n1 2 3 4 5 hexo: 3.8.0 hugo: v0.74.2/extended windows/amd64 BuildDate: unknown LoveIt: v0.2.10 Hugo无法使用abbrlink导致的URL与原本Hexo的URL不同步 原本的Hexo博客使用了hexo-abbrlink插件，目的是为每篇文章生成由字母和数字组成的随机URL，这样有利于SEO。迁移到Hugo后没找到类似的插件，只能用自带的slug功能来代替。\n原本的文章文件头里有一个abbrlink属性，如下：\n1 2 3 --- abbrlink: 71bd19d3 --- 为了让旧的文章url和以前保存一致，于是全部加上一个slug属性，如下：\n1 2 3 4 --- abbrlink: 71bd19d3 slug: 71bd19d3 --- 然后在站点配置文件里这样配置：\n1 2 [permalinks] posts = \u0026#34;/posts/:slug.html\u0026#34; 这样就可以避免旧文章的URL在迁移后不一致的问题，但是这也引入了另一个问题，那就是每一篇新文章都要手动添加slug属性，否则就还是会直接拿文章标题来作为URL的一部分。\n不过这点还是可以接受的，每篇文章额外配置slug也不算麻烦，毕竟博客园同样有提供这种给URL起别名的功能，可以把一系列的文章起一些比较接近的URL，更有利于访问。\nValine评论功能无法使用 LoveIt主题的评论功能默认情况下是无法在本地使用的，除非修改模板渲染文件，或者启动本地服务时添加参数，如下：\n1 hugo server -e production 这样就可以在本地调试时使用\u0026quot;评论系统\u0026quot;, \u0026ldquo;CDN\u0026rdquo; 和 \u0026ldquo;fingerprint\u0026rdquo;。\n但是对于v0.2.10版本的LoveIt主题，只是加入启动参数依然无法使用Valine评论功能，原因是评论功能的模板文件有问题，需要我们自己修改才能正常使用，如下：\n把\\themes\\LoveIt\\layouts\\partials\\comment.html拷贝到站点根目录下的\\layouts\\partials\\comment.html 打开拷贝后的comment.html，找到Valine相关的代码，把{{- if $valine.enable -}}和{{- end -}}之间的代码改成如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 {{- if $valine.enable -}} \u0026lt;div id=\u0026#34;valine\u0026#34; class=\u0026#34;comment\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;//cdn1.lncld.net/static/js/3.0.4/av-min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#39;{{ $cdn.valineJS }}\u0026#39;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; new Valine({ el: \u0026#39;#valine\u0026#39; , appId: \u0026#39;{{ $valine.appId }}\u0026#39;, appKey: \u0026#39;{{ $valine.appKey }}\u0026#39;, notify: \u0026#39;{{ $valine.notify }}\u0026#39;, verify: \u0026#39;{{ $valine.verify }}\u0026#39;, avatar:\u0026#39;{{ $valine.avatar }}\u0026#39;, placeholder: \u0026#39;{{ $valine.placeholder }}\u0026#39;, visitor: \u0026#39;{{ $valine.visitor }}\u0026#39; }); \u0026lt;/script\u0026gt; {{- end -}} 之后在站点配置文件里启用valine，然后填上从LeanCloud的应用中得到的appId和appKey就可以用了。并且在使用了valine的同时，还可以顺带启用阅读次数的统计功能。以前用Hexo的时候，就是用的LeanCloud来帮忙统计阅读次数的。\nLeanCloud的使用也很简单，去官网注册个账号，然后创建一个应用，然后进入该应用的配置，选择设置 -\u0026gt; 应用Keys，然后复制该应用的appId和appKey到站点配置文件里就行了。\nlightgallery图片相册功能无法使用 在启用了lightgallery功能后无法触发，然后在LoveIt仓库里找到了类似的issue，发现必须使用带标题的图片才能使用相册功能，如下：\n1 ![Alt Text](/url/to/your/image \u0026#34;Title\u0026#34;) 但是一般情况下在引入图片时都不会再特地起一个标题，尤其是原本就已经有大量文章里使用了不带标题的图片，想全部改过来是不可能的。\n接着发现已经有人发起了PR修复了该issue，只是作者还没merge，所以只能把这段代码自行合并到自己的博客项目了。做法也很简单：\n在站点根目录下创建的/layouts/_default/_markup/render-image.html 在新创建的这个render-image.html文件里黏贴下面的代码即可： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 {{ $figcap := or .Title .Text }} {{ $caption := or .Text \u0026#34; \u0026#34; }} {{- if eq $figcap $caption -}} {{ $caption = \u0026#34; \u0026#34; }} {{- end -}} {{- if $figcap -}} \u0026lt;figure\u0026gt; {{- dict \u0026#34;Src\u0026#34; .Destination \u0026#34;Title\u0026#34; $figcap \u0026#34;Caption\u0026#34; $caption \u0026#34;Linked\u0026#34; true \u0026#34;Resources\u0026#34; .Page.Resources | partial \u0026#34;plugin/image.html\u0026#34; -}} \u0026lt;figcaption class=\u0026#34;image-caption\u0026#34;\u0026gt; {{- $figcap | safeHTML -}} \u0026lt;/figcaption\u0026gt; \u0026lt;/figure\u0026gt; {{- else -}} {{- dict \u0026#34;Src\u0026#34; .Destination \u0026#34;Title\u0026#34; (path.Base .Destination) \u0026#34;Resources\u0026#34; .Page.Resources | partial \u0026#34;plugin/image.html\u0026#34; -}} {{- end -}} 另外，该做法会导致生成的图片下方多出一个figcaption标签，觉得这个图片名字标签太碍眼的，可以用下面的样式隐藏掉：\n1 2 3 4 /* 图片 */ figcaption { display: none !important; } lightgallery启用时，第二次加载页面时图片会变小 该issue可见于lightgallery启用时，图片会显示得很小，是设计如此还是bug#311\n这是lazysizes的问题，具体参见[aFarkas/lazysizes#508]，解决方法是修改样式：\n1 2 3 4 img[data-sizes=\u0026#34;auto\u0026#34;] { display: block; width: 100%; } 如果觉得100%太大可以改成别的比例，我用的是width: 50%;。\n翻页后首页的图片显示不了 首页的头像和文章图片显示正常，但是点击跳转到第二页或者其他除第一页以外的页数时，所有的图片全部显示不了。按下F12查看显示不了的图片的url，可以发现图片的地址不正确，并没有附加上正确的网站地址前缀。\n这个是因为图片的url配置不正确导致的。整个网站所使用的图片，其url要以/开头！这个涉及到站点的相对路径和绝对路径。\n比如站点头像，是在站点配置文件里的avatarURL属性决定的。如果你的头像是存放在images/avatar.jpg，那么就要配置成avatarURL = \u0026quot;/images/avatar.jpg\u0026quot;。\n其他图片同理，在文章里插入图片一般用法如下：\n1 ![avatar](/images/avatar.jpg) 当然了，如果你有图床之类的，直接写完整的地址也不会出现这个问题，如：\n1 ![avatar](https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/avatar.jpg) 自定义样式文件_custom.scss无法生效 LoveIt主题有提供\\themes\\LoveIt\\assets\\css\\_custom.scss，可以在该文件内自定义页面的样式，但是经过测试并无法生效。不过最终还是在stackoverflow上找到了答案：\nYou can use hugo\u0026rsquo;s extended (like https://github.com/gohugoio/hugo/releases/download/v0.53/hugo_extended_0.53_Windows-64bit.zip) version which automatically compiles SCSS to CSS for you. You can then customize all the setup. If you don\u0026rsquo;t want to/aren\u0026rsquo;t using the extended version, then ofc you will have to go old school with a watcher like ruby SASS or Gulp, etc.\n简单的说，只有使用的是扩展版本的Hugo，才能令_custom.scss文件生效！！！因为原生的Hugo并不支持编译sass文件，必须使用扩展版本的Hugo才行。\n所以请查看你所使用的Hugo版本，如果不是hugo_extended版本，请前往Hugo Release页面下载你当前版本Hugo所对应的hugo_extended版本。\n比如我原本使用的是hugo_0.74.0_Windows-64bit.zip，就需要改为使用hugo_extended_0.74.0_Windows-64bit.zip。\n无法直接自定义JavaScript LoveIt主题没有直接提供自定义JavaScript的文件，只能通过修改页面的模板文件来引入自定义的JavaScript文件，具体做法可以参考Hugo系列(3) - LoveIt主题美化与博客功能增强#添加自定义的custom.js。\n文章摘要标志不生效 和Hexo不同，Hugo的文章摘要标志必须是\u0026lt;!--more--\u0026gt;，在more的两边不能有任何空格，且必须全小写，否则便不会生效。用法如下：\n1 2 3 4 ## Title Content. \u0026lt;!--more--\u0026gt; 文章标题里的特殊符号不需要使用字符实体 在Hexo里，如果文章的标题里存在英文的双引号、冒号等特定的符号，必须使用字符实体来替代，否则就会报错。而在Hugo里，则没有这个需要，直接使用原本的符号就行。如果在标题里使用字符实体，并不会被自动解析成对应的字符。\nConsole报错找不到site.webmanifest 该文件和Progressive web applications (PWA) 有关，通过添加PWA到Hugo站点，可以实现离线访问的功能，也就是说断网状态下依然可以访问到你之前访问过的网页，换言之就是通过PWA来将访问过的网页资源缓存到了本地，所以断网下仍然可以继续访问网站。当然，恢复网络时会自动更新最新的页面资源。\n有兴趣的可以去看看下面这几个网站：\nAdd PWA to your Hugo site 改造你的网站，变身 PWA 基于Service Worker 的XSS攻击面拓展 后来又在LoveIt主题作者的一篇文章中找到了答案，如下：\n强烈建议你把:\napple-touch-icon.png (180x180) favicon-32x32.png (32x32) favicon-16x16.png (16x16) mstile-150x150.png (150x150) android-chrome-192x192.png (192x192) android-chrome-512x512.png (512x512) 放在/static目录. 利用 https://realfavicongenerator.net/ 可以很容易地生成这些文件. 可以自定义browserconfig.xml和site.webmanifest文件来设置theme-color和background-color.\n打开上面提及的网站，上传你想要作为网站图标的图片，按照提示走，会生成上述提及的所有文件，最后再下载下来，解压后将所有文件放置到站点根目录下的/static目录里即可。\n记得把site.webmanifest的name和short_name填上你的网站名字。\n远程部署到GitHub Pages后build失败 在本地调试没问题，部署到Coding Pages也没问题，偏偏部署到GitHub Pages 就一直build失败，并一直发送邮件，可以从邮件里看到报错的原因，如下：\n1 2 3 4 5 6 7 8 9 The page build failed for the `master` branch with the following error: Page build failed. For more information, see https://docs.github.com/github/working-with-github-pages/troubleshooting-jekyll-build-errors-for-github-pages-sites#troubleshooting-build-errors. For information on troubleshooting Jekyll see: https://docs.github.com/articles/troubleshooting-jekyll-builds If you have any questions you can submit a request on the Contact GitHub page at https://support.github.com/contact?repo_id=130235157\u0026amp;page_build_id=208464262 可以看到报错说是Page build failed.，描述太过模糊不清，我只能一篇篇文章的排查测试。最终发现，问题出在了某篇文章里的代码块，如下：\n1 2 3 4 5 6 \u0026lt;body\u0026gt; .... {% include \u0026#39;_custom/custom-foot.swig\u0026#39; %} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 问题就出在了这个{% %}上，经过几番测试，发现一旦启用了LoveIt主题的Markdown输出功能（即将每篇文章link到原本的Markdown文件），就会造成GitHub Pages服务build失败。\n全局禁用Markdown输出功能 由于不想把这些造成问题的代码块删掉，于是最佳的解决方案就变成了禁用Markdown输出功能，在站点配置文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 [params] [params.page] # whether to show link to Raw Markdown content of the content # 是否显示原始 Markdown 文档内容的链接 linkToMarkdown = false # Options to make output .md files # 用于输出 Markdown 格式文档的设置 #[mediaTypes] # [mediaTypes.\u0026#34;text/plain\u0026#34;] # suffixes = [\u0026#34;md\u0026#34;] # Options to make output .md files # 用于输出 Markdown 格式文档的设置 #[outputFormats.MarkDown] # mediaType = \u0026#34;text/plain\u0026#34; # isPlainText = true # isHTML = false # Options to make hugo output files # 用于 Hugo 输出文档的设置 [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;JSON\u0026#34;] # page = [\u0026#34;HTML\u0026#34;, \u0026#34;MarkDown\u0026#34;] page = [\u0026#34;HTML\u0026#34;] section = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomy = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;] taxonomyTerm = [\u0026#34;HTML\u0026#34;] 在站点配置文件了将linkToMarkdown配置为false，并将对应的三项Markdown输出的属性注释掉，终于解决了GitHub Pages编译失败的问题。\n这个做法属于一刀切，后面考虑到依然需要输出md文件，于是想到了另一个解决方法，那就是把某些在GitHub Pages解析有问题的md文件给干掉，让这些引入了“问题”代码块的md文件不生成即可。\n局部禁用Markdown输出功能 首先要改模板文件，将\\themes\\LoveIt\\layouts\\_default\\single.md拷贝到\\layouts\\_default\\single.md，打开拷贝后的文件修改成如下内容：\n1 2 3 4 5 6 {{- $params := .Scratch.Get \u0026#34;params\u0026#34; -}} {{- if $params.linkToMarkdown -}} # {{ .Title }} {{ .RawContent }} {{- end -}} 然后在不想生成md文件的文章头里加上linkToMarkdown: false，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 --- title: Hexo系列(3) - NexT主题和Markdown的写作技巧 tags: - Hexo - NexT主题 - 写作技巧 categories: - Hexo系列 abbrlink: 576ee548 slug: hexo-3 date: 2018-07-19T23:00:36+08:00 linkToMarkdown: false --- 这样就不会生成对应的md文件，也不会在页面尾部有阅读原始文档这个链接。\n终极方案：新增.nojekyll文件 在学习docsify的时候意外找到了最简单有效的解决方法，就是在站点根目录的static目录下添加一个名为.nojekyll的空内容文件。\n.nojekyll文件会告知GitHub Pages不使用jekyll来渲染静态站点，这样就不会和md文件里的某些代码冲突而build失败。\n网站配置了keywords没有生效 在 https://seo.chinaz.com 里查询站点时发现页面TDK信息里的关键词(KeyWords)为空，然而站点配置文件里是有配置的，如下：\n1 2 # 网站关键词 keywords = \u0026#34;雨临Lewis,Java,hugo,hexo,博客\u0026#34; F12查看网站源码后发现缺少keywords这个meta标签，检查了模板文件后发现是LoveIt没有引入该标签，需要修改模板才行。\n将\\themes\\LoveIt\\layouts\\partials\\head\\meta.html拷贝到\\layouts\\partials\\head\\meta.html，打开该文件并在\u0026lt;meta name=\u0026quot;Description\u0026quot; content=\u0026quot;{{ $params.description | default .Site.Params.description }}\u0026quot;\u0026gt;上方加上如下代码：\n1 \u0026lt;meta name=\u0026#34;keywords\u0026#34; content=\u0026#34;{{ $params.keywords | default .Site.Params.keywords }}\u0026#34;\u0026gt; 配置文件里的license不生效 这个是模板文件有问题，拷贝\\themes\\LoveIt\\layouts\\partials\\single\\footer.html到\\layouts\\partials\\single\\footer.html，打开拷贝后的文件，找到如下内容：\n1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;post-info-license\u0026#34;\u0026gt; {{- with $params.license | string -}} \u0026lt;span\u0026gt; {{- . | safeHTML -}} \u0026lt;/span\u0026gt; {{- end -}} \u0026lt;/div\u0026gt; 改成如下：\n1 2 3 4 5 6 7 \u0026lt;div class=\u0026#34;post-info-license\u0026#34;\u0026gt; {{- with $params.license | default .Site.Params.footer.license | string -}} \u0026lt;span\u0026gt; {{- . | safeHTML -}} \u0026lt;/span\u0026gt; {{- end -}} \u0026lt;/div\u0026gt; 参考链接 add more markdown images to gallery when lightgallery is enabled Valine中文文档 How to setup SCSS with Hugo Hugo Release - 0.74.0 lightgallery启用时，图片会显示得很小，是设计如此还是bug#311 主题文档 - 基本概念 ","permalink":"https://lewky.cn/posts/hugo-4.html/","tags":["Hugo","LoveIt主题","博客迁移","踩坑记录"],"title":"Hugo系列(4) - 从Hexo迁移至Hugo以及使用LoveIt主题的踩坑记录"},{"categories":["Hugo系列"],"contents":"前言 本博客使用的是Hugo的LoveIt主题，本文也是基于该主题而写的，不过Hugo的美化步骤应该大同小异，版本如下：\n1 2 3 hugo: v0.74.2/extended windows/amd64 BuildDate: unknown LoveIt: v0.2.10 请注意，本文的所有功能都离不开两个新增加的文件：_custom.scss和custom.js，部分功能还需要jquery，在第一章中会提及如何引入。\n另外本文篇幅太长，阅读体验不好，将其进行分章如下：\nHugo系列(3.0) - LoveIt主题美化与博客功能增强 · 第一章 Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章 Hugo系列(3.2) - LoveIt主题美化与博客功能增强 · 第三章 Hugo系列(3.3) - LoveIt主题美化与博客功能增强 · 第四章 添加自定义的_custom.scss LoveIt主题提供了一个自定义的_custom.scss，可以在该文件里添加自定义的css样式。该文件目录位于\\themes\\LoveIt\\assets\\css\\_custom.scss，不建议直接在该文件里写css代码。\nHugo在渲染页面时优先读取站点根目录下的同名字的目录和文件，所以可以利用这个特点来美化主题。只需要把想修改的主题模板文件拷贝到根目录下同样的目录中并进行修改，这样就可以在不改动原本的主题文件的情况下实现主题美化。\n首先在站点根目录下创建一个自定义的文件：\\assets\\css\\_custom.scss，这样Hugo就会最终以该文件来渲染页面的样式。\n这是我个人站点的_custom.scss文件，有兴趣的可以看看。\n注意！！！ 这里有个很关键的点，只有使用的是扩展版本的Hugo，才能令_custom.scss文件生效！！！因为原生的Hugo并不支持编译sass文件，必须使用扩展版本的Hugo才行。\n所以请查看你所使用的Hugo版本，如果不是hugo_extended版本，请前往Hugo Release页面下载你当前版本Hugo所对应的hugo_extended版本。\n比如我原本使用的是hugo_0.74.0_Windows-64bit.zip，就需要改为使用hugo_extended_0.74.0_Windows-64bit.zip。\n此外，本文会涉及多个文件的修改，包括hmtl、js、scss等文件类型，且由于引入了中文字符，可能导致页面显示乱码，这是因为文件的编码使用的是ANSI，需要改为UTF-8的编码。\n添加自定义的custom.js LoveIt主题并没有提供一个文件来让我们自定义JavaScript，所以需要自己创建一个js文件来自定义JavaScript。\n首先在站点根目录下创建一个自定义的JavaScript文件：\\static\\js\\custom.js。这个文件需要在body的闭合标签之前引入，并且要在theme.min.js的引入顺序之后。这样可以防止样式被其他文件覆盖，并且不会因为JavaScript文件加载太久导致页面长时间的空白。\n对于LoveIt主题，custom.js添加在\\themes\\LoveIt\\layouts\\partials\\assets.html里。\n首先把该文件拷贝到根目录下的\\layouts\\partials\\assets.html，然后打开拷贝后的文件，把自定义的JavaScript文件添加到最末尾的{{- partial \u0026quot;plugin/analytics.html\u0026quot; . -}}的上一行：\n1 2 {{- /* 自定义的js文件 */ -}} \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/js/custom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 由于本文提及的部分功能会用到jQuery，建议一起引入，最终如下：\n1 2 3 4 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; {{- /* 自定义的js文件 */ -}} \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/js/custom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 如果有其他的JavaScript文件要引入，加在一样的地方就行，但是要放在自定义的custom.js之前。这是我的custom.js文件，有兴趣的可以看看。\n添加全局cdn变量 对于一些静态资源，比如图片、音乐文件、第三方库等，如果有自己的cdn或者图床等，可以在站点配置文件自定义一个cdn变量，如下：\n1 2 3 [params] # cdn变量，末尾不需要加/ cdnPrefix = \u0026#34;http://xxxx\u0026#34; 接下来就可以在你需要的地方使用该变量，大概有如下3种用法。\n在md文件中使用 在md文件中可以用内置的shortcodes来使用该变量：\n1 2 3 {{\u0026lt; param cdnPrefix \u0026gt;}} ![avatar.jpg]({{\u0026lt; param cdnPrefix \u0026gt;}}/images/avatar.jpg) 在模板文件中使用 在layouts目录下有很多html文件，这些是用来渲染站点的模板文件，可以用Hugo的语法来引入该变量：\n1 {{ .Site.Params.cdnPrefix }} 如果在一个模板文件里有多个地方使用到该变量，可以定义一个局部变量来使用：\n1 2 3 4 {{- $cdn := .Site.Params.cdnPrefix -}} /* 使用局部变量 */ {{ $cdn }} 在JavaScript文件中使用 由于JavaScript文件中不能使用上述的shortcodes或Hugo语法来引用变量，只能通过在\\layouts\\partials\\assets.html中用JavaScript语法来引入该变量，如下：\n1 2 3 4 5 /* 这是可以应用于JavaScript文件的全局变量 */ \u0026lt;script\u0026gt; /* cdn for some static resources */ var $cdnPrefix = {{ .Site.Params.cdnPrefix }}; \u0026lt;/script\u0026gt; 这样就可以在其他被引入的JavaScript文件中使用这个$cdnPrefix变量：\n1 2 3 4 5 $(function () { $.backstretch([ $cdnPrefix + \u0026#34;/images/background/saber1.jpg\u0026#34; ], { duration: 60000, fade: 1500 }); }); 如果是想在模板文件里引入某个自定义的JavaScript文件，如下：\n1 2 {{- /* 自定义的js文件 */ -}} \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;{{ .Site.Params.cdnPrefix }}/js/custom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 主题自带的admonition样式 LoveIt提供了admonition shortcode，支持 12 种样式，可以在页面中插入提示的横幅。代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 {{\u0026lt; admonition \u0026gt;}} 一个 **注意** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition abstract \u0026gt;}} 一个 **摘要** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition info \u0026gt;}} 一个 **信息** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition tip \u0026gt;}} 一个 **技巧** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition success \u0026gt;}} 一个 **成功** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition question \u0026gt;}} 一个 **问题** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition warning \u0026gt;}} 一个 **警告** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition failure \u0026gt;}} 一个 **失败** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition danger \u0026gt;}} 一个 **危险** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition bug \u0026gt;}} 一个 **Bug** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition example \u0026gt;}} 一个 **示例** 横幅 {{\u0026lt; /admonition \u0026gt;}} {{\u0026lt; admonition quote \u0026gt;}} 一个 **引用** 横幅 {{\u0026lt; /admonition \u0026gt;}} 效果如下： 注意 一个 注意 横幅 摘要 一个 摘要 横幅 信息 一个 信息 横幅 技巧 一个 技巧 横幅 成功 一个 成功 横幅 问题 一个 问题 横幅 警告 一个 警告 横幅 失败 一个 失败 横幅 危险 一个 危险 横幅 Bug 一个 Bug 横幅 示例 一个 示例 横幅 引用 一个 引用 横幅 如果想设置默认不展示文本内容，可以设置open=false，还可以设置标题：\n1 2 3 {{\u0026lt; admonition title=\u0026#34;这是一个默认不展开的横幅\u0026#34; open=false \u0026gt;}} 一个 **注意** 横幅 {{\u0026lt; /admonition \u0026gt;}} 效果如下：\n这是一个默认不展开的横幅 一个 注意 横幅 自定义404页面 主题默认的404页面太普通，可以通过新增\\layouts\\404.html来自定义自己想要的404页面。这是本站的404页面，有兴趣的可以看看源码页面。\n添加背景图片轮播 这个功能需要引入图片轮播插件jquery-backstretch的cdn，并且该插件依赖于jQuery，需要在引入该插件之前引入jQuery。\n打开\\layouts\\partials\\assets.html，在你引入的custom.js的上面一行添加如下代码（必须要在custom.js之前引入这两个文件才有效果）：\n1 2 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 然后在custom.js里添加如下代码，具体想要轮播哪些图片可以自行修改，如下：\n1 2 3 4 5 6 7 8 /* 轮播背景图片 */ $(function () { $.backstretch([ \u0026#34;/images/background/saber1.jpg\u0026#34;, \u0026#34;/images/background/saber2.jpg\u0026#34;, \u0026#34;/images/background/wlop.jpg\u0026#34; ], { duration: 60000, fade: 1500 }); }); 添加搜索功能 LoveIt主题自带的搜索插件是lunr和algolia，这两个的使用都比较麻烦，后者甚至还想要去注册账号，虽然可以免费使用搜索服务，但是抓取收录时间好像是一小时一次，并且还有每月使用量的限制，太不便利了。\n之前在Hexo那边用的是自带的搜索插件，是每次部署时自动为所有文章生成索引到一个文件里，然后直接搜索该文件来实现本地搜索功能。这个还是比较方便个人站点使用的，于是在网上找到了类似的一个Hugo专用的搜索插件hugo-search-fuse-js。\n2024.04.22更新：由于hugo-search-fuse-js项目更新换代了，使用时需要安装其他的依赖，不满足开箱即用的需求，我将最原始最简单的版本上传到了新建的仓库里lewky/hugo-search-fuse-js，下文都基于该原始版本进行教程！！\n安装搜索插件hugo-search-fuse-js到本地 hugo-search-fuse-js并不是一个单独的主题，而是Hugo主题的一个组件：\n下载hugo-search-fuse-js到站点的主题目录/themes/hugo-search-fuse-js下，注意，目录名必须是hugo-search-fuse-js 把该主题组件名字添加到站点配置文件里，注意，搜索组件名字要在最前面，后面跟着的是你的主题的文件夹名字： 1 theme = [\u0026#34;hugo-search-fuse-js\u0026#34;, \u0026#34;my-theme\u0026#34;] 新建一个content/search.md文件，内容如下： 1 2 3 4 5 6 7 +++ title = \u0026#34;Search\u0026#34; layout = \u0026#34;search\u0026#34; outputs = [\u0026#34;html\u0026#34;, \u0026#34;json\u0026#34;] [sitemap] priority = 0.1 +++ 修改页面模板文件baseof.html 把主题目录下的\\themes\\LoveIt\\layouts\\_default\\baseof.html拷贝到站点根目录下的\\layouts\\_default\\baseof.html 在拷贝后的baseof.html的适当位置插入两段代码：{{ block \u0026quot;main\u0026quot; . }}{{ end }}和{{ block \u0026quot;footer\u0026quot; . }}{{ end }}，下面是一个修改后的样例： 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;div class=\u0026#34;wrapper\u0026#34;\u0026gt; {{- partial \u0026#34;header.html\u0026#34; . -}} \u0026lt;main class=\u0026#34;main\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; {{ block \u0026#34;main\u0026#34; . }}{{ end }} {{- block \u0026#34;content\u0026#34; . }}{{ end -}} \u0026lt;/div\u0026gt; \u0026lt;/main\u0026gt; {{- partial \u0026#34;footer.html\u0026#34; . -}} {{ block \u0026#34;footer\u0026#34; . }}{{ end }} \u0026lt;/div\u0026gt; 添加搜索按钮 在站点配置文件里添加一个新的按钮给搜索功能使用，如下：\n1 2 3 4 5 6 7 [menu] [[menu.main]] pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-fw fa-search\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; name = \u0026#34;搜索\u0026#34; weight = 7 identifier = \u0026#34;search\u0026#34; url = \u0026#34;/search/\u0026#34; 如果你的配置文件里的菜单属性是多语言的，样例如下：\n1 2 3 4 5 6 7 8 9 [languages] [languages.en] [languages.en.menu] [[languages.en.menu.main]] pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-fw fa-search\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; name = \u0026#34;Search\u0026#34; weight = 7 identifier = \u0026#34;search\u0026#34; url = \u0026#34;/search/\u0026#34; 关闭LoveIt主题默认的搜索插件 在站点配置文件里把默认的搜索插件关闭，如下：\n1 2 3 4 [params] [params.app] [params.search] enable = false 如果你使用的是多语言的配置，则应该把每个语言的搜索插件都关闭，如下：\n1 2 3 4 5 6 7 8 9 10 [languages] [languages.en] [languages.en.params] [languages.en.params.search] enable = false [languages.zh-cn] [languages.zh-cn.params] [languages.zh-cn.params.search] enable = false 修改搜索页面的样式 如果对该插件生成的搜索页面样式不满意，可以自行修改，下面是我的样式代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 /* 搜索页面 */ .search { position: relative; padding-top: 3.5rem; padding-bottom: 1rem; width: 57.5%; margin: 0 auto; background: white; opacity: .95; } [theme=dark] .search { background: #3a3535; } [theme=dark] .search header, .search header { background-color: #f8f8f8; } [theme=dark] .search header:hover, .search header:hover { -webkit-box-shadow: none; box-shadow: none; } .search header h1 { padding-left: 1rem; background: white; } [theme=dark] .search header h1 { background: #3a3535; } [theme=dark] .search input, .search input { height: initial; width: initial; color: initial; background-color: white; margin: 0 0 0 1rem; border-width: 2px; border-style: inset; border-color: initial; border-image: initial; -webkit-border-radius: 0; -moz-border-radius: 0; border-radius: 0; } .search #search-results { padding-left: 1rem; padding-right: 1rem; } [theme=dark] a:active, [theme=dark] a:hover { color: #2d96bd; } .search hr { margin-left: 1rem; margin-right: 1rem; } 优化中文搜索效果 这个搜索功能借助了Fuse.js模糊搜索引擎，为了更好的适配中文搜索结果，需要修改模糊搜索的相关参数，相对的会导致英文搜索结果变多，不过这个可以接受。因为搜索结果变多了，总好过搜索不出来想要的中文结果。而且可以通过设置搜索结果的权重来改变结果的排序，这样越前面的搜索结果就越是我们想要的。\n打开\\themes\\hugo-search-fuse-js\\static\\js\\search.js，这里面配置了fuse.js的搜索配置选项，可以参考下我的配置，我已经添加了部分中文注释：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // Options for fuse.js let fuseOptions = { shouldSort: true, // 是否按分数对结果列表排序 includeMatches: true, // 是否应将分数包含在结果集中。0分表示完全匹配，1分表示完全不匹配。 tokenize: true, matchAllTokens: true, threshold: 0.2, // 匹配算法阈值。阈值为0.0需要完全匹配（字母和位置），阈值为1.0将匹配任何内容。 location: 0, // 确定文本中预期找到的模式的大致位置。 /** * 确定匹配与模糊位置（由位置指定）的距离。一个精确的字母匹配，即距离模糊位置很远的字符将被视为完全不匹配。 * 距离为0要求匹配位于指定的准确位置，距离为100则要求完全匹配位于使用阈值0.2找到的位置的20个字符以内。 */ distance: 100, maxPatternLength: 64, // 模式的最大长度 minMatchCharLength: 2, // 模式的最小字符长度 keys: [ {name:\u0026#34;title\u0026#34;,weight:0.8}, {name:\u0026#34;tags\u0026#34;,weight:0.5}, {name:\u0026#34;categories\u0026#34;,weight:0.5}, {name:\u0026#34;contents\u0026#34;,weight:0.4} ] }; 这里和中文搜索有关的主要就3个选项：threshold，location，distance。\nthreshold是阈值，这个参数搭配distance使用。如果阈值填了0.0，相当于distance没有意义。location填0就行，distance填100就足够了，太大了会导致搜索到过多的结果。上面根据我个人的中文搜索测试结果，选择了这样的配置：\n1 2 3 threshold: 0.2, location: 0, distance: 100 可以根据个人情况来修改这几个参数的值，另外我还将minMatchCharLength的值改成了2，不过经过测试，和之前默认的3并没有什么差别。\n如何添加自定义的页面 除了发布草稿和正文，我们还可以添加自定义的页面page。page不会像文章那样被渲染，而是被渲染成一个单独的页面，类似于你的文档、标签页面。\n方法很简单：\n在站点根目录的/content/目录下，新建一个文件夹，比如about文件夹。然后在该文件夹里新建一个index.md文件，该文件将作为站点访问该目录的页面，你可以将其当成一篇特殊的文章。 在index.md文件里加上下面的内容，实际上这里只需要title就够了，date这个日期属性可要可不要，因为page页面是看不到这个日期的： 1 2 3 4 --- title: \u0026#34;关于\u0026#34; date: 2018-04-24T22:01:44+08:00 --- 接下来你就可以像写普通文章一样，在这个index.md文件里随便写你想要展示的内容就行了。 添加友链页面 新建Page页面 首先在站点根目录的/content/目录下，新建一个friends文件夹。在该文件夹里新建一个index.md文件，内容如下：\n1 2 3 --- title: \u0026#34;友链墙\u0026#34; --- 上述这种方式创建的page页面作为友链，有个缺点，就是无法使用目录。\n由于博主想要将友链分类，并能使用上目录，所以不使用这种page形式的友链页面；而是改用下面第二种方式（post形式），直接创建一篇文章作为友链使用，文件头如下：\n1 2 3 title: \u0026#34;友链墙\u0026#34; url: friends hiddenFromHomePage: true 添加friend.html 我们通过自定义一个shortcode来实现该功能，以后就可以方便地通过这个shortcode快速新增友链到页面上。\n在站点根目录下新增一个文件：/layouts/shortcodes/friend.html，其内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 {{ if .IsNamedParams }} {{ $defaultImg := \u0026#34;https://sdn.geekzu.org/avatar/d41d8cd98f00b204e9800998ecf8427e?d=retro\u0026#34; }} \u0026lt;a target=\u0026#34;_blank\u0026#34; href={{ .Get \u0026#34;url\u0026#34; }} title={{ .Get \u0026#34;name\u0026#34; }}---{{ .Get \u0026#34;word\u0026#34; }} class=\u0026#34;friend url\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;friend block whole {{ .Get \u0026#34;primary-color\u0026#34; | default \u0026#34;default\u0026#34;}} {{ .Get \u0026#34;border-animation\u0026#34; | default \u0026#34;shadow\u0026#34;}}\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;friend block left\u0026#34;\u0026gt; \u0026lt;img class=\u0026#34;friend logo {{ .Get \u0026#34;img-animation\u0026#34; | default \u0026#34;rotate\u0026#34;}}\u0026#34; src={{ .Get \u0026#34;logo\u0026#34; }} onerror=\u0026#34;this.src=\u0026#39;{{ $defaultImg }}\u0026#39;\u0026#34; /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;friend block right\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;friend name\u0026#34;\u0026gt;{{ .Get \u0026#34;name\u0026#34; }}\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;friend info\u0026#34;\u0026gt;\u0026#34;{{ .Get \u0026#34;word\u0026#34; }}\u0026#34;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/a\u0026gt; {{ end }} 添加样式文件并引入 在站点根目录下新增一个文件：/assets/css/_partial/_single/_friend.scss，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 .friend.url { text-decoration: none !important; color: black; } .friend.logo { width: 56px !important; height: 56px !important; border-radius: 50%; border: 1px solid #ddd; padding: 2px; margin-top: 14px !important; margin-left: 14px !important; background-color: #fff; } .friend.block.whole { height: 92px; margin-top: 8px; margin-left: 4px; width: 31%; display: inline-flex !important; border-radius: 5px; background: rgba(14, 220, 220, 0.15); \u0026amp;.shadow { margin-right: 4px; box-shadow: 4px 4px 2px 1px rgba(0, 0, 255, 0.2); } \u0026amp;.borderFlash { border-width: 3.5px; border-style: solid; animation: borderFlash 2s infinite alternate; } \u0026amp;.led { animation: led 3s infinite alternate; } \u0026amp;.bln { animation: bln 3s infinite alternate; } } .friend.block.whole { \u0026amp;:hover { color: white; \u0026amp; .friend.info { color: white; } } \u0026amp;.default { --primary-color: #215bb3bf; \u0026amp;:hover { background: rgba(33, 91, 179, 0.75); } } \u0026amp;.red { --primary-color: #e72638; \u0026amp;:hover { background: rgba(231, 38, 56, 0.75); } } \u0026amp;.green { --primary-color: #2ec58d; \u0026amp;:hover { background: rgba(21, 167, 33, 0.75); } } \u0026amp;.blue { --primary-color: #2575fc; \u0026amp;:hover { background: rgba(37, 117, 252, 0.75); } } \u0026amp;.linear-red { --primary-color: #e72638; \u0026amp;:hover { background: linear-gradient(to right, #f9cdcd 0, #e72638 35%); } } \u0026amp;.linear-green { --primary-color: #2ec58d; \u0026amp;:hover { background: linear-gradient(to right, #1d7544 0, #2ec58d 35%); } } \u0026amp;.linear-blue { --primary-color: #2575fc; \u0026amp;:hover { background: linear-gradient(to right, #6a11cb 0, #2575fc 35%); } } } .friend.block.whole .friend.block.left img { \u0026amp;.auto_rotate_left { animation: auto_rotate_left 3s linear infinite; } \u0026amp;.auto_rotate_right { animation: auto_rotate_right 3s linear infinite; } } .friend.block.whole:hover .friend.block.left img { \u0026amp;.rotate { transition: 0.9s !important; -webkit-transition: 0.9s !important; -moz-transition: 0.9s !important; -o-transition: 0.9s !important; -ms-transition: 0.9s !important; transform: rotate(360deg) !important; -webkit-transform: rotate(360deg) !important; -moz-transform: rotate(360deg) !important; -o-transform: rotate(360deg) !important; -ms-transform: rotate(360deg) !important; } } .friend.block.left { width: 92px; min-width: 92px; float: left; } .friend.block.left { margin-right: 2px; } .friend.block.right { margin-top: 18px; margin-right: 18px; } .friend.name { overflow: hidden; font-weight: bolder; word-wrap:break-word; word-break: break-all; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 1; -webkit-box-orient: vertical; } .friend.info { margin-top: 3px; overflow: hidden; word-wrap:break-word; word-break: break-all; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; line-height: normal; font-size: 0.8rem; color: #7a7a7a; } @media screen and (max-width: 900px) { .friend.info { display: none; } .friend.block.whole { width: 45%; } .friend.block.left { width: 84px; margin-left: 15px; } .friend.block.right { height: 100%; margin: auto; display: flex; align-items: center; justify-content: center; } .friend.name { font-size: 14px; } } @keyframes bln { 0% { box-shadow: 0 0 5px grey,inset 0 0 5px grey,0 1px 0 grey; box-shadow: 0 0 5px var(--primary-color,grey),inset 0 0 5px var(--primary-color,grey),0 1px 0 var(--primary-color,grey) } to { box-shadow: 0 0 16px grey,inset 0 0 8px grey,0 1px 0 grey; box-shadow: 0 0 16px var(--primary-color,grey),inset 0 0 8px var(--primary-color,grey),0 1px 0 var(--primary-color,grey) } } @keyframes led { 0% { box-shadow: 0 0 4px #ca00ff } 25% { box-shadow: 0 0 16px #00b5e5 } 50% { box-shadow: 0 0 4px #00f } 75% { box-shadow: 0 0 16px #b1da21 } to { box-shadow: 0 0 4px red } } @keyframes borderFlash { 0% { border-color: white; } to { border-color: grey; border-color: var(--primary-color,grey) } } @keyframes auto_rotate_left { 0% { transform: rotate(0) } to { transform: rotate(-1turn) } } @keyframes auto_rotate_right { 0% { transform: rotate(0) } to { transform: rotate(1turn) } } 请注意，该文件是.scss文件，只有你使用的是扩展版本的Hugo时才能生效。\n然后把\\themes\\LoveIt\\assets\\css\\_page\\_single.scss这个文件拷贝到\\assets\\css\\_page\\_single.scss，然后修改我们新增的_single.scss，在第一行加一行新代码：\n1 @import \u0026#34;../_partial/_single/friend\u0026#34;; 这样Hugo就会用我们新增的这个文件来渲染友链页面了。\n另一种添加样式文件并引入的方案 感谢@kirito的建议，原友链样式的方案会侵入原本的主题样式，并且也不是所有页面都需要这个友链样式，所以可以采用另一种方案来选择性地引入友链样式：即同样使用shortcode来引入。\n首先创建一个/assets/css/friend.scss文件，内容跟上文的_friend.scss文件一样。然后新增一个/layouts/shortcodes/friend-css.html文件：\n1 2 3 4 {{ $options := (dict \u0026#34;targetPath\u0026#34; \u0026#34;/css/friend.css\u0026#34; \u0026#34;outputStyle\u0026#34; \u0026#34;compressed\u0026#34; \u0026#34;enableSourceMap\u0026#34; true) }} {{ $style := resources.Get \u0026#34;css/friend.scss\u0026#34; | resources.ToCSS $options }} \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;{{ $style.RelPermalink }}\u0026#34;\u0026gt; 在需要使用友链的页面、文章中添加如下shortcode来引入友链样式即可：\n1 {{\u0026lt; friend-css \u0026gt;}} 在菜单栏里新增一个友链按钮 打开站点配置文件config.toml，添加友链按钮：\n1 2 3 4 5 6 7 8 # 菜单配置 [menu] [[menu.main]] pre = \u0026#34;\u0026lt;i class=\u0026#39;fas fa-fw fa-fan fa-spin\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; name = \u0026#34;友链\u0026#34; identifier = \u0026#34;friends\u0026#34; url = \u0026#34;/friends/\u0026#34; weight = 6 使用示例和效果展示 在你想要引入友链的文章里使用下面的代码即可自动渲染成对应的友链：\n1 2 3 4 5 6 {{\u0026lt; friend name=\u0026#34;雨临Lewis的博客\u0026#34; url=\u0026#34;lewky.cn\u0026#34; logo=\u0026#34;https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/avatar.jpg\u0026#34; word=\u0026#34;不想当写手的码农不是好咸鱼_(xз」∠)_\u0026#34; \u0026gt;}} 上面代码里的四个属性为必填项，还可以额外指定三个不同的属性来选择友链内置的多种样式，如下：\n1 2 3 4 5 6 7 8 9 //边框及鼠标悬停的背景颜色，允许设置渐变色 //支持7种：default、red、green、blue、linear-red、linear-green、linear-blue primary-color=\u0026#34;default\u0026#34; //头像动画：rotate(鼠标悬停时旋转，此为默认效果)、auto_rotate_left(左旋转)、auto_rotate_right(右旋转) img-animation=\u0026#34;rotate\u0026#34; //边框动画：shadow(阴影，此为默认效果)、borderFlash(边框闪现)、led(跑马灯)、bln(主颜色呼吸灯) border-animation=\u0026#34;shadow\u0026#34; 雨临Lewis的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r雨临Lewis的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r雨临Lewis的博客\r\"不想当写手的码农不是好咸鱼_(xз」∠)_\"\r如果友链的头像无法正常显示，会以一个默认的Gravatar头像显示。此外，在移动端会隐藏站点描述，只显示头像和站点名称，你可以通过将当前窗口缩小到宽度最小即可看到效果。\n参考链接 自定义Hugo主题样式 kaushalmodi / hugo-search-fuse-js Hugo 篇四：添加友链卡片 shortcodes img标签设置默认图片 Fuse.js模糊搜索引擎 使用fuse.js进行搜索 ","permalink":"https://lewky.cn/posts/hugo-3.html/","tags":["Hugo","LoveIt主题","主题美化","功能增强"],"title":"Hugo系列(3.0) - LoveIt主题美化与博客功能增强 · 第一章"},{"categories":["Hugo系列"],"contents":"前言 Hugo本身可以通过修改站点配置文件来完成页面的部分定制，如按钮、多语言等功能。本文基于LoveIt主题【v0.2.10】，且所使用的Hugo版本如下，不同版本且不同主题可能无法适用某些属性：\n1 2 \u0026gt;hugo version Hugo Static Site Generator v0.74.2/extended windows/amd64 BuildDate: unknown 配置文件 Hugo默认使用根目录下的config.toml、config.yaml或config.json中的某一个作为站点的配置文件，可以通过--config来配置读取一个或多个配置文件，如下：\n1 2 hugo --config debugconfig.toml hugo --config a.toml,b.toml,c.toml 配置文件的目录 除了使用单一的站点配置文件，还可以通过使用configDir变量（默认值为config/）来维护不同环境下的各组件的配置文件：\n每个文件各自对应配置文件的根对象，比如Params, Menus, Languages等。 每个子目录对应不同的环境配置，类似于Maven的Profile功能。 这些文件可以应用国际化功能，即区分不同的语言版本。 下面是一个简单的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 ├── config │ ├── _default │ │ ├── config.toml │ │ ├── languages.toml │ │ ├── menus.en.toml │ │ ├── menus.zh.toml │ │ └── params.toml │ ├── production │ │ ├── config.toml │ │ └── params.toml │ └── staging │ ├── config.toml │ └── params.toml 可以发现上述的结构中，存在着三种不同的环境配置：_default默认环境、production生成环境、staging演示环境。_default下的配置是通用配置，Hugo每次生成站点时都会读取。如果运行hugo --environment staging，则还会额外合并staging的配置（会替换_default下冲突的配置）。\n一般情况下我们用不到多环境的功能，只需要在站点根目录下存放一个config.toml文件，直接在该配置文件中指定各种属性，就可以实现相当程度的个性化了。下面是一些常用的配置文件的属性的用法，这些属性都是配置在站点配置文件里的。\ntheme主题属性 配置你的Hugo主题款式，本文基于LoveIt主题【v0.2.10】，所以配置是：\n1 theme = \u0026#34;LoveIt\u0026#34; 网站路径相关的属性 baseURL 网站的根路径，用法如下：\n1 baseURL = \u0026#34;https://mySite.com/\u0026#34; disablePathToLower 是否禁止将网站路径转换成小写，建议设置成true：\n1 disablePathToLower = true permalinks 生成的文章的路径，默认配置如下：\n1 2 [permalinks] posts = \u0026#34;/:year/:month/:title/\u0026#34; 这里可以使用的变量如下：\n:year：4位数的年份\n:month：2位数的月份\n:monthname：月份名字\n:day：2位数的日期\n:weekday：1位数，每周的第几天，星期日对应0\n:weekdayname：星期几\n:yearday：1到3位数，每年的第几天\n:section：当前文章对应的section分类\n:sections：当前文章对应的完整的section分类层次\n:title：文章的标题\n:slug：文章的slug，和title一样是定义在文件头里的属性，当没有定义slug时会使用title作为url\n:filename：文章的文件名，不包括文件扩展名。\n出于seo考虑，不建议在url里加上年月日之类的，由于标题大多有中文或者特殊字符，所以也不建议直接使用标题作为url的一部分。这里建议使用slug的方式，自己手动给每篇文章提取若干个关键词作为slug，以此作为url的一部分，如下：\n1 2 [permalinks] posts = \u0026#34;/posts/:slug.html\u0026#34; 然后文章的slug可以这样配置 （permalinks是配置在站点配置文件里的，slug是配置在每篇文章的文件头里的） ：\n1 2 3 4 --- title: 建站日志 slug: e62c38c45 --- 我这里是因为文章是从hexo迁移过来的，hexo那边使用了abbrlink插件来生成随机且不重复的名字，为了和之前的文章url对齐就这样配置了。而hugo没有找到类似的插件，所以选择了slug来自定义url，这个功能倒是和博客园的自定义博文的url类似。\n另外值得一提的是，默认用的是pretty Url的配置，所有url的末尾都有个/，而Hexo那边url末尾是没有这个/的，算是一点小小的不同。\nuglyurls 这个属性针对默认的pretty Url，比如有个url是/posts/e62c38c45/。如果设置了uglyurls = true，则会把末尾的/改成.html，新的url就变成了/posts/e62c38c45.html。但是这个属性有个问题，它会把文章以外的url也变成这种“丑陋”的格式，比如分类、标签等url，这样就不美观了。\n所以不推荐使用该属性，如果希望文章的url不是纯目录格式的，可以像上文的permalinks那样配置。\nmarkup标记属性 配置markdown解析器、代码块高亮、文章目录等。\nmarkdown解析器 Hugo提供了asciidocExt、blackFriday和goldmark三种markdown解析器，默认使用goldmark来解析markdown，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 markup: asciidocExt: attributes: {} backend: html5 extensions: [] failureLevel: fatal noHeaderOrFooter: true safeMode: unsafe sectionNumbers: false trace: false verbose: false workingFolderCurrent: false blackFriday: angledQuotes: false extensions: null extensionsMask: null footnoteAnchorPrefix: \u0026#34;\u0026#34; footnoteReturnLinkContents: \u0026#34;\u0026#34; fractions: true hrefTargetBlank: false latexDashes: true nofollowLinks: false noreferrerLinks: false plainIDAnchors: true skipHTML: false smartDashes: true smartypants: true smartypantsQuotesNBSP: false taskLists: true defaultMarkdownHandler: goldmark goldmark: extensions: definitionList: true footnote: true linkify: true strikethrough: true table: true taskList: true typographer: true parser: attribute: true autoHeadingID: true autoHeadingIDType: github renderer: hardWraps: false unsafe: false xhtml: false Highlight代码高亮 hugo默认的配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 markup: highlight: anchorLineNos: false codeFences: true guessSyntax: false hl_Lines: \u0026#34;\u0026#34; lineAnchors: \u0026#34;\u0026#34; lineNoStart: 1 lineNos: false lineNumbersInTable: true noClasses: true style: monokai tabWidth: 4 guessSyntax：自动推断代码属于某种语言。 hl_Lines：仅在使用goldmark解析器时该属性才起效，表示对某几行代码进行高亮处理，比如： lineAnchors: \u0026quot;2\u0026quot;表示第二行代码高亮； lineAnchors: \u0026quot;1-8\u0026quot;表示第一到八行代码高亮； lineAnchors: \u0026quot;1 3\u0026quot;表示第一行和第三行代码高亮。 lineNoStart：表示行数从多少开始计数。 lineNos：配置行数，false表示不显示行数。 lineNumbersInTable：值为true时可以在显示行数时提供友好的代码块复制黏贴功能。\nTable Of Contents文章目录 配置如下：\n1 2 3 4 5 markup: tableOfContents: endLevel: 3 ordered: false startLevel: 2 startLevel：从几级标题开始生成目录，值为2表示从h2开始生成目录。 endLevel：到几级标题为止生成目录，值为3表示大于h3的标题就不再生成目录。 ordered：是否生成排序目录，建议启用该功能，生成的目录会更为美观。\n补充一个完整的toml格式的markup配置 上面分别给出了yaml格式的3种配置，下面是对应toml格式的完整配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 [markup] defaultMarkdownHandler = \u0026#34;goldmark\u0026#34; [markup.asciidocExt] backend = \u0026#34;html5\u0026#34; extensions = [] failureLevel = \u0026#34;fatal\u0026#34; noHeaderOrFooter = true safeMode = \u0026#34;unsafe\u0026#34; sectionNumbers = false trace = false verbose = false workingFolderCurrent = false [markup.asciidocExt.attributes] [markup.blackFriday] angledQuotes = false footnoteAnchorPrefix = \u0026#34;\u0026#34; footnoteReturnLinkContents = \u0026#34;\u0026#34; fractions = true hrefTargetBlank = false latexDashes = true nofollowLinks = false noreferrerLinks = false plainIDAnchors = true skipHTML = false smartDashes = true smartypants = true smartypantsQuotesNBSP = false taskLists = true [markup.goldmark] [markup.goldmark.extensions] definitionList = true footnote = true linkify = true strikethrough = true table = true taskList = true typographer = true [markup.goldmark.parser] attribute = true autoHeadingID = true autoHeadingIDType = \u0026#34;github\u0026#34; [markup.goldmark.renderer] hardWraps = false unsafe = false xhtml = false [markup.highlight] anchorLineNos = false codeFences = true guessSyntax = false hl_Lines = \u0026#34;\u0026#34; lineAnchors = \u0026#34;\u0026#34; lineNoStart = 1 lineNos = false lineNumbersInTable = true noClasses = true style = \u0026#34;monokai\u0026#34; tabWidth = 4 [markup.tableOfContents] endLevel = 3 ordered = false startLevel = 2 menu菜单属性 侧边栏菜单是在配置文件里配置的，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 [menu] [[menu.main]] identifier = \u0026#34;about\u0026#34; name = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-heart\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;about hugo\u0026#34; url = \u0026#34;/about/\u0026#34; weight = -110 [[menu.main]] identifier = \u0026#34;start\u0026#34; name = \u0026#34;getting started\u0026#34; post = \u0026#34;\u0026lt;span class=\u0026#39;alert\u0026#39;\u0026gt;New!\u0026lt;/span\u0026gt;\u0026#34; pre = \u0026#34;\u0026lt;i class=\u0026#39;fa fa-road\u0026#39;\u0026gt;\u0026lt;/i\u0026gt;\u0026#34; url = \u0026#34;/getting-started/\u0026#34; weight = -100 identifier的值不能重复。 weight是比重，值越小则该菜单的位置越靠上面。 name是菜单名字。 pre和post分别对应当前菜单的前缀和后缀，可以定义fontawesome等图标。\nlanguages语言属性 该属性可以提供站点的国际化功能，即区分多语言版本的站点，比如若设定了en、zh两个语言，设定默认语言是zh；则默认的站点url的根目录后会加上/zh/，并可以通过站点首页的切换语言下拉框来切换到其他语音，如：/en/。\nlanguages一般用来跟上面的menu一起配合使用，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 [Languages] [Languages.en] title = \u0026#34;Yulin Lewis\u0026#39; Blog\u0026#34; weight = 1 languageName = \u0026#34;English\u0026#34; [[Languages.en.menu.main]] name = \u0026#34;\u0026lt;i class=\u0026#39;fab fa-fw fa-github\u0026#39;\u0026gt;\u0026lt;/i\u0026gt; GitHub\u0026#34; identifier = \u0026#34;github\u0026#34; url = \u0026#34;https://github.com/lewky\u0026#34; weight = 1 [Languages.zh] title = \u0026#34;雨临Lewis的博客\u0026#34; weight = 2 languageName = \u0026#34;简体中文\u0026#34; [[Languages.zh.menu.main]] name = \u0026#34;\u0026lt;i class=\u0026#39;fab fa-fw fa-github\u0026#39;\u0026gt;\u0026lt;/i\u0026gt; GitHub\u0026#34; identifier = \u0026#34;github\u0026#34; url = \u0026#34;https://github.com/lewky\u0026#34; weight = 1 此外，也可以将languages和params搭配使用，用法和上面类似，其实就是在这些属性的前面加上languages前缀而已。但是不知道为什么，在本文背景里提及的hugo和LoveIt版本下，站点无法正常读取到多语言参数，比如[languages.zh-cn.params]这种属性会读取不了。\nminify压缩属性 该属性用于压缩站点的各种静态资源，比如html、css、json、xml等，官方的默认配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 [minify] disableCSS = false disableHTML = false disableJS = false disableJSON = false disableSVG = false disableXML = false minifyOutput = false [minify.tdewolff] [minify.tdewolff.css] decimals = -1 keepCSS2 = true [minify.tdewolff.html] keepConditionalComments = true keepDefaultAttrVals = true keepDocumentTags = true keepEndTags = true keepQuotes = false keepWhitespace = false [minify.tdewolff.js] [minify.tdewolff.json] [minify.tdewolff.svg] decimals = -1 [minify.tdewolff.xml] keepWhitespace = false 但实际上在配置文件中加入上述的配置并没有效果，也无法进行修改，这可能是个bug，因为和启用压缩的命令参数冲突了。不过从上面的配置可以看出，hugo自带的压缩功能是默认会压缩CSS、HTML、JS、JSON、SVG、XML；并且在压缩HTML的时候会保留注释、属性、文档标签和闭合标签，但是会去掉引号和空格。\n如果想启用压缩功能，可以运行如下命令（记得运行前要先删掉public目录）：\n1 hugo --minify 也可以直接把这个参数配置到配置文件中，这样就可以不在运行命令时指定压缩参数：\n1 minify = true 参考链接 Configure Hugo Syntax Highlighting Menus Multilingual Mode ","permalink":"https://lewky.cn/posts/hugo-2.html/","tags":["Hugo","个性化配置"],"title":"Hugo系列(2) - 通过配置文件来定制个人站点"},{"categories":["生活"],"contents":"前言 简单快速地记录下一个直男癌的肤浅护肤笔记，方便日后回顾。\n首先是区分肤质，大部分男生都是油性皮肤或者混合型皮肤（夏天时出油，换季时掉皮，即半油半干性肤质）。少部分是干性皮肤。还有的是过敏性肤质（敏感肌），属于很多护肤品都不能用的类型。\n本人属于混合型皮肤，这里只记录混合型或者油性皮肤相关的护肤品。\n护肤品使用步骤：洗面奶，爽肤水，精华，乳液，面霜。\n洗面奶洗去毛孔的油脂和垃圾，爽肤水补充水分，精华补充皮肤营养物质（精华是小分子物质，要在乳液前使用），乳液锁住水分，面霜进一步修复肌肤（面霜是最后使用的）。\n以上护肤品都应该避开眼眶周围肌肤，早晚各护肤一次，晚上睡前还可以涂个润唇膏。\n洗面奶 旁氏米粹洁面乳。\n一款高性价比、相对温和的洗面奶，干皮，中皮，混合皮全天适用，油皮可作为晨间洁面。不过我是懒人，早晚都用这个洗面奶。\n爽肤水 MUJI基础润肤爽肤水（无印良品的敏感肌用爽肤水）。\n啥肤质都能用，400ml能用到天荒地老。\n精华 OLAY水感透白光塑精华。\n锦上添花的东西，提亮，控油，抗衰老。\n乳液 无印良品muji基础润肤乳清爽型（同样是无印良品的敏感肌用乳液）。\n一大瓶400ml，量大管饱，同样是用到天荒地老的分量。\n面霜 薇诺娜修红霜。\n适用于易泛红肌肤和中干性敏感肌肤，用于修复脸上的泛红部位。\n参考链接 男士护肤一篇搞定：直男百元护肤攻略 ","permalink":"https://lewky.cn/posts/boy-skin/","tags":["护肤"],"title":"直男护肤"},{"categories":["Hugo系列"],"contents":"前言 使用Hexo搭建个人博客也有两年多时间了，当文章数量达到上百篇之后，开始发现Hexo生成文章的效率越来越慢，直到每次生成都需要至少五分钟的时间。我发现生成效率和文章涉及到的分类和标签有很大关系，由于文章数量多，每篇文章又都关联了若干个分类和标签，再加上我使用了压缩样式的插件，最终导致极其低下的生成效率。\n在经过一段时间的考量后，决定将Hexo博客迁移到Hugo。Hugo是用go语言开发的，在用法上和Hexo类似，可以简单地把Hugo当成go语言版的Hexo，但是它拥有更快的生成效率。下面是官网的原话：\nThe world’s fastest framework for building websites\nHugo is one of the most popular open-source static site generators. With its amazing speed and flexibility, Hugo makes building websites fun again.\n安装 和Hexo不同，Hugo安装非常简单，只需要去Hugo Release下载操作系统对应的二进制文件即可（hugo或者hugo.exe)。\n对于Windows平台，一般是一个zip文件，解压后里面有个hugo.exe文件。将该文件所在目录添加到环境变量path里，即可在cmd里通过hugo version检测是否能正常运行hugo命令。\n如下是我安装的hugo版本：\n1 2 \u0026gt;hugo version Hugo Static Site Generator v0.74.2/extended windows/amd64 BuildDate: unknown 其他平台的安装方法可以参考官方文档：Install Hugo\n创建站点 首先需要创建一个新的个人站点：\n1 hugo new site blog blog就是你的博客站点所在的目录，也是这个站点的根目录，创建站点后目录结构如下：\n1 2 3 4 5 6 7 archetypes/ content/ data/ layouts/ static/ themes/ config.toml 下面简单介绍下Hugo根目录下的各个文件目录的作用：\narchetypes存放创建文件时使用的模板，可以自定义front matter属性。 assets存放需要被Hugo Pipes处理的文件，且只有使用了.Permalink或者.RelPermalink的文件才能被发布到public目录。 注意，默认不会创建assets目录。 config是配置文件，可以有JSON、 YAML或者TOML三种格式，默认使用根目录下的config.toml、config.yaml或config.json中的某一个。可以通过--config来配置读取一个或多个配置文件，如：hugo --config a.toml,b.toml,c.toml。 注意，默认不会创建config目录。 content存放的各种md文件用于部署站点，该目录下可以自行创建若干个子目录来便于对文章进行分类，这些子目录被称为section。 data目录存放的是用于定义变量的模板文件，相当于Java里的常量类，这些文件有JSON、 YAML或者TOML三种格式，会在生成站点时被使用到。一般用不到该功能，具体用法可以参考：data templates layouts目录存放的模板文件用于渲染html页面，模板里可以定义不同页面的html代码。 static目录存放的是静态内容：图片、CSS、JavaScript等。 resources目录用于缓存某些文件来提高生成效率。 注意，默认不会创建resources目录。 添加主题 为新站点添加一个主题，以我使用的LoveIt主题为例，先将主题代码放置到themes目录下：\n1 2 3 cd blog git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 接着修改config.toml：\n1 theme = \u0026#34;LoveIt\u0026#34; 这里的LoveIt对应themes目录下的主题的文件夹名字。\n新建文章 新建一篇文章：\n1 hugo new posts/first.md 该命令会在content/posts目录下生成first.md文件，打开进行编辑：\n1 2 3 4 5 6 7 8 --- title: \u0026#34;First\u0026#34; date: 2020-09-08T21:57:28+08:00 draft: true --- ## First First blog. 两行---里的属性是front matter，用来设置当前文章的属性配置。front matter的内容可以使用3种不同的格式来定义，两行---之间对应的是YAML格式，两行+++之间对应的是TOML格式，{和}之间对应的是JSON格式。\n建议用YAML格式来定义，这样从Hexo迁移到Hugo的成本会更低。\n下面是官方文档提供的3种不同格式的front matter的样例，有兴趣的可以了解下。\nTOML Example 1 2 3 4 5 6 7 8 9 10 11 12 +++ title = \u0026#34;spf13-vim 3.0 release and new website\u0026#34; description = \u0026#34;spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\u0026#34; tags = [ \u0026#34;.vimrc\u0026#34;, \u0026#34;plugins\u0026#34;, \u0026#34;spf13-vim\u0026#34;, \u0026#34;vim\u0026#34; ] date = \u0026#34;2012-04-06\u0026#34; categories = [ \u0026#34;Development\u0026#34;, \u0026#34;VIM\u0026#34; ] slug = \u0026#34;spf13-vim-3-0-release-and-new-website\u0026#34; +++ Content of the file goes Here YAML Example 1 2 3 4 5 6 7 8 9 10 11 12 13 --- title: \u0026#34;spf13-vim 3.0 release and new website\u0026#34; description: \u0026#34;spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\u0026#34; tags: [ \u0026#34;.vimrc\u0026#34;, \u0026#34;plugins\u0026#34;, \u0026#34;spf13-vim\u0026#34;, \u0026#34;vim\u0026#34; ] lastmod: 2015-12-23 date: \u0026#34;2012-04-06\u0026#34; categories: - \u0026#34;Development\u0026#34; - \u0026#34;VIM\u0026#34; slug: \u0026#34;spf13-vim-3-0-release-and-new-website\u0026#34; --- Content of the file goes Here JSON Example 1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;title\u0026#34;: \u0026#34;spf13-vim 3.0 release and new website\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;spf13-vim is a cross platform distribution of vim plugins and resources for Vim.\u0026#34;, \u0026#34;tags\u0026#34;: [ \u0026#34;.vimrc\u0026#34;, \u0026#34;plugins\u0026#34;, \u0026#34;spf13-vim\u0026#34;, \u0026#34;vim\u0026#34; ], \u0026#34;date\u0026#34;: \u0026#34;2012-04-06\u0026#34;, \u0026#34;categories\u0026#34;: [ \u0026#34;Development\u0026#34;, \u0026#34;VIM\u0026#34; ], \u0026#34;slug\u0026#34;: \u0026#34;spf13-vim-3-0-release-and-new-website\u0026#34;, } Content of the file goes Here 启动Hugo服务 输入命令：\n1 hugo server -D 在本地启动服务后可以在 http://localhost:1313/ 访问个人站点。该命令仅用于本地调试，支持热修改，也就是说在启动服务时修改文章会实时生效，但是该命令不会真正生成静态文件。\n生成静态页面 输入命令：\n1 hugo -D 默认会在站点根目录的public/目录下生成对应的静态页面，可以通过在命令行指定-d或者--destination参数来改变静态页面的存放路径，也可以通过在配置文件中设置publishDir来指定。\n该命令生成的静态页面文件是用来部署到pages服务的，比如GitHub pages或者Coding pages等。\n另外，hugo允许对生成的静态页面设置特殊的参数，比如在文章的front matter里设置参数：draft, publishdate和expirydate。如下：\n1 2 3 4 5 6 7 --- title: \u0026#34;First\u0026#34; date: 2020-09-08T21:57:28+08:00 draft: true publishdate: 2020-09-18T21:57:28+08:00 expirydate: 2020-09-28T21:57:28+08:00 --- draft: true表明该文章是草稿，如果在启用服务时不指定参数-D或--buildDrafts，或者在配置文件config.toml中配置buildDrafts = true，则会在生成文章时忽略草稿。如果不想指定该参数就生成文章，需要改为draft: false或者将其删去。\npublishdate: 2020-09-18T21:57:28+08:00表示将来发布的时间，如果不指定参数-F或--buildFuture，或者在配置文件config.toml中配置buildFuture = true，则无法在规定的日期之前生成该文章。\nexpirydate: 2020-09-28T21:57:28+08:00表示过期时间，如果不指定参数-E或--buildExpired，或者在配置文件config.toml中配置buildExpired = true，则无法在规定的日期之后生成该文章。\n远程部署到Pages服务 Hugo和Hexo一样是静态站点生成工具，不需要服务器即可进行部署运行，为了可以在网络上也访问到我们的博客，需要将静态博客部署到某些网站的pages服务上，借用人家的服务器进行托管。\n常用的Pages服务有GitHub pages、Coding pages等，由于暂时没有找到好用的Hugo的远程部署插件，所以这里使用Git命令来进行远程部署。\n注意，所谓的远程部署，其实就是把hugo命令生成的public目录里的所有文件push到远程库，然后启用Pages服务进行静态网站的部署。这样，当有人访问静态站点的主页时，Pages服务就会去读取根目录下的index.html。\n本文以部署到GitHub Pages为例。\n安装Git 首先要安装Git，Git是一个版本控制工具，可以用来帮忙管理我们的博客，直接前往官网下载安装包即可。\n下载链接\n在安装的时候会问你是否安装git的cmd工具，把这个也一起安装了后就可以不需要配置环境变量了。这样就可以直接在cmd窗口里运行Git命令，如git version。\n当然也可以直接使用安装时自带的Git Bash，个人更喜欢用Git Bash。\n在GitHub上创建一个仓库 首先在GitHub上创建一个仓库，仓库的名字格式为\u0026lt;username\u0026gt;.github.io。比如我的GitHub用户名是lewky，那么这个仓库就命名为lewky.github.io。\n之所以这样规定命名，是因为GitHub默认会把\u0026lt;username\u0026gt;.github.io的master分支的内容部署到GitHub Pages站点上。\nSSH key的创建与配置 因为要使用SSH的方式来和GitHub仓库进行交互，我们需要生成一对密钥对，然后将公钥配置到GitHub账号上。关于SSH key的创建与配置到GitHub，可以看我的另一篇文章的一个小章节：#四、SSH key的创建与配置 的4.1 ~ 4.3的部分。\n在本地关联GitHub的站点仓库 在本地创建一个新的文件夹，比如名为hugo-deploy。首先是初始化该文件夹为Git项目，命令如下：\n1 git init 然后把本地的Hugo博客通过hugo命令生成的public目录下的所有文件都复制到这个新建的文件夹hugo-deploy里，然后用Git命令把这些复制过来的文件添加到本地仓库：\n1 git add . 接着是提交修改，命令如下：\n1 git commit -m \u0026#34;第一次提交\u0026#34; -m参数代表提交信息，用于说明本次提交的目的，比如你发布了什么文章、修改了什么样式之类的信息说明。该参数不可以省略，不然会报错，另外要注意这里的双引号是英文的双引号。\n接着把刚刚在GitHub上创建的仓库的SSH地址复制下来：点击GitHub仓库的Code绿色按钮，点击SSH就可以看到该仓库的SSH地址，然后点击地址后面的复制按钮即可。\n用Git命令把这个SSH地址添加到我们的本地仓库，这样这个GitHub仓库就将作为我们的远程仓库，然后就可以通过Git命令把站点文件部署到GitHub上：\n1 git remote add origin git@github.com:lewky/lewky.github.io.git 这里的origin是远程库的别名，后面是要关联的远程库SSH地址。\n然后就是最后一步了，把我们刚刚提交到本地库的文件给推送到远程库。由于远程库刚刚创建，还不存在本地的分支（默认是master分支），所以第一次提交的命令要加是一个-u参数：\n1 git push -u origin master 这样GitHub远程库上会创建出对应的master分支，以后推送文件的时候，就不需要再加上该参数了：\n1 git push origin master 启用GitHub Pages服务 通过master分支来启用GitHub Pages 现在我们的GitHub仓库里已经有站点的文件了，接下来点击Settings进入该仓库的设置页面，找到Github Pages这一项，选择以master分支作为Source，然后保存；接下来这个仓库就会被部署到https://{username}.github.io/{仓库名}。\n你会发现这里的url里多了子路径，但是如果仓库名是{username}.github.io的格式，那该url就会被简化为https://{username}.github.io/，这样就不需要在url后边添加上仓库名来访问个人站点了。\n通过gh-pages分支来启用GitHub Pages 还有一种启用的方式是给仓库创建一个名为gh-pages的分支，然后把该分支设置为Source，同样可以让该仓库使用到GitHub Pages服务。\n这种启用方式是只有当存在多个项目都要使用GitHub Pages才使用的，因为目前GitHub只允许一个仓库可以通过master分支来启用GitHub Pages。如果其他仓库也要使用GitHub Pages，就需要创建gh-pages分支来部署。\n怎么同时部署到两个不同的Pages服务 进入本地仓库的目录，打开隐藏文件夹.git下的config文件，多添加一行url = xxx，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true [remote \u0026#34;origin\u0026#34;] url = git@github.com:lewky/lewky.github.io.git url = git@e.coding.net:lewky/hugo-deploy/hugo-deploy.git fetch = +refs/heads/*:refs/remotes/origin/* [pull] rebase = true [branch \u0026#34;master\u0026#34;] remote = origin merge = refs/heads/master 此后只需要git push origin master就可以同时推送到多个远程库。\n个人技巧 部署时使用的是public目录下的文件，如果不想把原本整个项目仓库对外暴露，可以新建一个单独的项目仓库用来部署，通过一个脚本来自动本地构建public文件，并拷贝到用以部署的另一个项目仓库。\n比如我个人使用的站点仓库是lewky-hugo，用来部署的仓库是hugo-deploy，cmd脚本内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @echo off rd /s /q D:\\projects\\lewky-hugo\\public hugo ::删除hugo-deploy下的文件 del /q D:\\projects\\hugo-deploy for /d %%i in (D:\\projects\\hugo-deploy\\*) do ( ::因为不会遍历到隐藏文件夹.git，所以会删掉.git以外的文件夹 rd /s /q %%i ) xcopy .\\public D:\\projects\\hugo-deploy /e /y /h /q pause 参考链接 Hugo Front Matter Hugo Quick Start Install Hugo Directory Structure Explained Git的使用\u0026ndash;如何将本地项目上传到Github git push同时推送到两个远程仓库 ","permalink":"https://lewky.cn/posts/hugo-1.html/","tags":["Hugo","搭建教程","远程部署"],"title":"Hugo系列(1) - 简单搭建教程与远程部署"},{"categories":["Java"],"contents":"前言 一般开发项目时可以直接本地借助IDE工具进行debug调试，但对于线上的项目，则需要借助Java提供的远程debug功能来进行调试。可以在启动项目前通过配置对应的JVM参数来启用远程debug，也可以把参数添加到Tomcat或者Jetty之类的启动脚本里。\n配置JVM参数 1 -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=4000,server=y,suspend=n 参数说明：\n-XDebug：启用调试。 -Xnoagent：禁用默认sun.tools.debug调试器。 -Djava.compiler=NONE：禁止 JIT 编译器的加载，目的是提供远程debug的效率。 -Xrunjdwp：加载JDWP的JPDA参考执行实例。JPDA为Java平台上的调试器定义了一个标准的体系结构。 transport：用于在调试程序和 VM 使用的进程之间通讯。 dt_socket：套接字传输，即socket通信。 dt_shmem：共享内存传输，仅限于Windows平台。一般不用这种通信方式。 address：远程debug监听的端口号。远程服务器要开放这个端口号，客户端才能远程连接上。 server：值为y或n，VM是否需要作为调试服务器执行。设置为y后该程序才能作为服务器被我们的客户端(比如Eclipse)连接上。 suspend：值为y或n，是否在调试客户端建立连接之后启动VM。简单来说，如果设置为y，程序就会在调试客户端连接进来之前一直挂起着不执行。一般都是设置为n，除非你的程序是启动后很快就执行完毕结束进程。 Eclipse启用远程调试 Eclipse可以作为远程调试的客户端，在debug菜单里打开Debug Configurations...，找到Remote Java Application，右键点击New，然后给这个远程调试填写Name，选择对应需要被调试的项目Project。\nConnection Type选择Standard(Socket Attach)，Host填写远程调试服务器的地址，Port填写远程调试的端口号。\n最后点击Debug即可开始远程调试。\n补充 启动参数中的-D是什么，-X又是什么 -D是在启动项目时用来设置系统属性值，如果值包含空格则需要用一对双引号包括起来。这些属性值可以在代码中用System.getProperty(key)来获取。我们可以用-D来随意设置需要的键值对，然后在代码中去获取。\n-X是Java提供的非标准选项, 不同版本中可能有所更改，并且在更改后不会另行通知。\n为什么要配置-Djava.compiler=NONE 一个Java程序在将代码编译为字节码后，在执行时由JVM解释为对应平台的机器码，然后再执行。JVM有两种技术来实现解释执行：转译器和JIT。\n转译器将每个Java指令都转译成对等的微处理器指令，并根据转译后的指令先后次序依序执行，由于一个Java指令可能被转译成十几或数十几个对等的微处理器指令，这种模式执行的速度相当缓慢。\nJIT针对一个具体的class进行编译，经过编译后的程序，被优化成相当精简的原生型指令码（native code）。但是，JIT也不是万能的，比如：某些极少执行到的Java指令在编译时所额外花费的时间可能比转译器在执行时的时间还长，这时候就不如直接使用转译器。\n所以，转译器和JIT各有优缺点。\n极少执行到或者执行次数较少的Java代码，使用转译器更划算。 重复执行或者执行次数较多的Java代码，采用JIT更划算。 我们一般debug程序的时候，只是关注其中的一部分代码，而且大部分情况下是设置断点，然后单步执行，而JIT的编译单位是class，只要我们执行了class里面的代码，JIT就会对整个class进行编译，而我们实际执行的代码一般都是其中的一部分代码，所以从整个时间效率上来看，采用JIT反而更费时间。也就是说在JVM远程调试这个事情上，禁用JIT（只使用转译器，解释一行执行一条）更合理，所以通过-Djava.compiler=NONE来禁止JIT。\n参考链接 java debug suspend_【Java远程debug】 Java远程调试 java -Xdebug各参数说明 请问JVM远程调试的配置中为什么要配置-Djava.compiler=NONE java程序启动参数-D含义详解 java x_Java -X命令 ","permalink":"https://lewky.cn/posts/java-remote-debug.html/","tags":["Java","远程调试"],"title":"Java的远程调试Remote Debug"},{"categories":["Java"],"contents":"将中文转换为ASCII码的工具 在jdk的安装目录下，有一个bin文件夹，这里隐藏了一个将中文转换为ASCII码的工具：native2ascii.exe。双击运行该程序，输入要转换的中文，按下Enter，就可以得到相应的ASCII码了。\n接下来要如何将该ASCII码复制到文本上？\n右键cmd窗口，选择编辑菜单里的标记，选定了要复制的内容后按下Enter就自动复制到系统的剪贴板了，在想要粘贴的地方按Ctrl+V就可以粘贴成功了。\n","permalink":"https://lewky.cn/posts/jdk-tools.html/","tags":["Java","JDK Tools"],"title":"JDK自带的那些好用的工具"},{"categories":["数据库"],"contents":"on和where的区别 on和where后都表示查询条件，它们的区别如下：\n1、on只能用于连接查询（内连接、外连接、交叉连接），在其他情况下使用on会报错，比如：\n1 select* from test on id = 1; -- 报错，不能在普通查询里使用on，需要使用where 2、连接查询会产生一张中间表(临时表)，on是在生成中间表时使用的条件；而where是在中间表生成后对中间表进行过滤使用的条件。比如：\ntest1表：\nid name 1 A 2 B 3 C test2表：\nid name 1 E 3 F 1 2 select* from test1 left join test2 on test1.id = test2.id and test1.id = 1; select* from test1 left join test2 on test1.id = test2.id where test1.id = 1; 对于第一个语句，结果是：\nid name id name 1 A 1 E 2 B null null 3 C null null 对于第二个语句，结果是：\nid name id name 1 A 1 E 3、外连接必须使用on，不然会报错。比如：\n1 2 select* from test1 left join test2; -- 报错，没有使用on select* from test1 left join test2 where test1.id = test2.id; -- 报错，没有使用on 4、在一个内连接和交叉连接中，单独使用on和where对结果集没有区别。比如：\n1 2 select* from test1 inner join test2 on test1.id = test2.id; select* from test1 inner join test2 where test1.id = test2.id; 注：以上语句都是在MySQL5.0的情况下测试的。\n单引号和双引号的区别 在标准SQL中，字符串使用的是单引号。\n如果字符串本身也包括单引号，则使用两个单引号（注意，不是双引号，字符串中的双引号不需要另外转义）。\n但在其它的数据库中可能存在对SQL的扩展，比如在MySQL中允许使用单引号和双引号两种。\nMySQL参考手册：\n字符串指用单引号'或双引号\u0026quot;引起来的字符序列。例如：\n\u0026lsquo;a string\u0026rsquo;\n\u0026ldquo;another string\u0026rdquo;\n如果SQL服务器模式启用了NSI_QUOTES，可以只用单引号引用字符串。用双引号引用的字符串被解释为一个识别符。\n!=会过滤值为null的数据 在测试数据时忽然发现，使用如下的SQL是无法查询到对应column为null的数据的：\n1 select * from test where name != \u0026#39;Lewis\u0026#39;; 本意是想把表里name的值不为Lewis的所有数据都搜索出来，结果发现这样写无法把name的值为null的数据也包括进来。\n上面的!=换成\u0026lt;\u0026gt;也是一样的结果，这可能是因为在数据库里null是一个特殊值，有自己的判断标准，如果想要把null的数据也一起搜索出来，需要额外加上条件，如下：\n1 select * from test where name != \u0026#39;Lewis\u0026#39; or name is null; 虽然这只是个小知识点，不过还是值得记录注意下，以免日后在开发中犯小错误。\nnull值的比较 SQL里任何与null值的比较结果，最后都会变成null，以PostgreSQL为例，如下：\n1 2 3 4 select null != null; select null = null; select null \u0026gt; 1; select null \u0026lt;\u0026gt; 1; 以上结果都是null，而不是什么true或者false。另外有些函数是不支持null值作为输入参数的，比如count()或者sum()等。\nnulls值排序问题 使用order by来为指定的字段进行排序时，如果db中该字段的值存在着null值，那么在排序时不同的DB对于null值的默认值不同，这会导致默认情况下不同DB中null值的顺序不同。\n在PostgreSQL中，null值默认最大 如果对一个学生表里的数据按照age字段进行顺序排序，如下：\n1 select * from student order by age 如果name字段存在null值，那么这条sql的结果集就如下所示：\n1 2 3 4 5 |id|student|age| |1|小明|10| |2|小红|12| |3|小黑|null| |4|小白|null| 因为null值默认是最大，所以在升序排列中null值的记录就会被排到最后。同样地，如果是降序排列，null值记录就会被排到最前面。\n在Oracle中，null值默认最大 Oracle中同样认为null值最大，也就是说，升序排列时null值默认排在最后；降序排列时null值默认排在最前。\n在MySQL和SQLServer中，null值默认最小 MySQL和SQLServer则相反，null值默认是最小。当升序排列时null值默认排在最前；降序排列时null值默认排在最后。\n在实际的业务中，null值参与的排序这可能会造成一些不必要的问题，有时候甚至会造成一个bug并且难以被发现。\n所以，在对这些有可能存在null值的字段进行排序时需要注意使用关键字nulls last/first。\nnulls last/first的具体用法 我们可以通过nulls last或者nulls first关键字来指定这些null值的record是排在最后还是最前，如下：\n1 select * from student order by age desc nulls last; 该语句指定了降序排列时，null值排到最后；需要注意的是，该关键字只能搭配order by来使用。一共也就四种用法：\norder by [asc] nulls first order by [asc] nulls last order by desc nulls first order by desc nulls last 参考链接 Sql 中 不等于\u0026rsquo;\u0026lsquo;与 NULL mysql 空值排序问题 PostgreSQL 数据库NULL值的默认排序行为与查询、索引定义规范 - nulls first\\last, asc\\desc SQL中的单引号和双引号有区别吗？ ","permalink":"https://lewky.cn/posts/sql-issues/","tags":["SQL","工作记录"],"title":"SQL - where条件里的!=会过滤值为null的数据"},{"categories":["工作记录"],"contents":"问题与分析 某天领导report了一个问题：线上的CPU自从上一个版本迭代后就一直处于居高不下的状况，领导看着这段时间的曲线图判断是有两条线程在不停的死循环。\n接到任务后去查看了AWS的CloudWatch，发现线上CPU确实一直居高不下，使用率基本是之前的两倍；另外发现线程使用率以比之前频繁很多。后来公司的大佬拿到dump后经过分析发现，是由正则表达式造成的CPU持续高使用率的问题。\n堆栈信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 at java.util.regex.Pattern$Loop.match(Pattern.java:4787) at java.util.regex.Pattern$GroupTail.match(Pattern.java:4719) at java.util.regex.Pattern$Curly.match0(Pattern.java:4281) at java.util.regex.Pattern$Curly.match(Pattern.java:4236) at java.util.regex.Pattern$Curly.match0(Pattern.java:4274) at java.util.regex.Pattern$Curly.match(Pattern.java:4236) at java.util.regex.Pattern$GroupCurly.match0(Pattern.java:4487) at java.util.regex.Pattern$GroupCurly.match(Pattern.java:4407) at java.util.regex.Pattern$Curly.match0(Pattern.java:4274) at java.util.regex.Pattern$Curly.match(Pattern.java:4236) at java.util.regex.Pattern$GroupHead.match(Pattern.java:4660) at java.util.regex.Pattern$Loop.match(Pattern.java:4787) at java.util.regex.Pattern$GroupTail.match(Pattern.java:4719) at java.util.regex.Pattern$Curly.match0(Pattern.java:4281) at java.util.regex.Pattern$Curly.match(Pattern.java:4236) at java.util.regex.Pattern$Curly.match0(Pattern.java:4274) at java.util.regex.Pattern$Curly.match(Pattern.java:4236) at java.util.regex.Pattern$GroupCurly.match0(Pattern.java:4487) at java.util.regex.Pattern$GroupCurly.match(Pattern.java:4407) at java.util.regex.Pattern$Curly.match0(Pattern.java:4274) at java.util.regex.Pattern$Curly.match(Pattern.java:4236) at java.util.regex.Pattern$GroupHead.match(Pattern.java:4660) at java.util.regex.Pattern$Loop.match(Pattern.java:4787) at java.util.regex.Pattern$GroupTail.match(Pattern.java:4719) at java.util.regex.Pattern$Curly.match0(Pattern.java:4274) at java.util.regex.Pattern$Curly.match(Pattern.java:4236) at java.util.regex.Pattern$Curly.match0(Pattern.java:4274) at java.util.regex.Pattern$Curly.match(Pattern.java:4236) at java.util.regex.Pattern$GroupCurly.match0(Pattern.java:4487) at java.util.regex.Pattern$GroupCurly.match(Pattern.java:4407) at java.util.regex.Pattern$Curly.match0(Pattern.java:4274) at java.util.regex.Pattern$Curly.match(Pattern.java:4236) at java.util.regex.Pattern$GroupHead.match(Pattern.java:4660) at java.util.regex.Pattern$Loop.matchInit(Pattern.java:4803) at java.util.regex.Pattern$Prolog.match(Pattern.java:4743) at java.util.regex.Pattern$GroupCurly.match0(Pattern.java:4487) at java.util.regex.Pattern$GroupCurly.match(Pattern.java:4407) at java.util.regex.Pattern$GroupTail.match(Pattern.java:4719) at java.util.regex.Pattern$BranchConn.match(Pattern.java:4570) at java.util.regex.Pattern$BmpCharProperty.match(Pattern.java:3800) at java.util.regex.Pattern$Branch.match(Pattern.java:4606) at java.util.regex.Pattern$GroupHead.match(Pattern.java:4660) at java.util.regex.Pattern$Start.match(Pattern.java:3463) at java.util.regex.Matcher.search(Matcher.java:1248) at java.util.regex.Matcher.find(Matcher.java:637) at com.core.cbx.mybatis.plugin.sql.TableAliasParseInjector.getTableAlias(TableAliasParseInjector.java:48) 还是第一次知道正则表达式也会引发这种问题，网上查了下资料，原来有不少人也遇到同样的问题。而这个问题，是由正则表达式的灾难性回溯（Catastrophic Backtracking），或者说回溯陷阱造成的。\n另外，可以发现在jdk的JIRA里也有人提出了这个issue，不过目前依然还没有解决这个bug，下面是官方的issue链接：StackOverflowError in java.util.regex.Pattern\n引擎与回溯 这里引用下一位老哥的原文，简单介绍下正则表达式的引擎和回溯机制。\n正则引擎主要可以分为基本不同的两大类：一种是DFA（确定型有穷自动机），另一种是NFA（不确定型有穷自动机）。简单来讲，NFA 对应的是正则表达式主导的匹配，而 DFA 对应的是文本主导的匹配。\nDFA从匹配文本入手，从左到右，每个字符不会匹配两次，它的时间复杂度是多项式的，所以通常情况下，它的速度更快，但支持的特性很少，不支持捕获组、各种引用等等；而NFA则是从正则表达式入手，不断读入字符，尝试是否匹配当前正则，不匹配则吐出字符重新尝试，通常它的速度比较慢，最优时间复杂度为多项式的，最差情况为指数级的。但NFA支持更多的特性，因而绝大多数编程场景下（包括java，js），我们面对的是NFA。\nJava的正则表达式引擎用的是NFA算法，在根据正则表达式来匹配文本时，拥有回溯机制。在遇到以下字符时就有可能发生回溯：\n? + * {min, max} 以上四种默认是贪婪模式去匹配文本，也就是说，会尽可能多地去匹配更多的字符。在这个匹配的过程中，必然会一次次地匹配文本，一直到匹配不上时，才会回溯一次，重新用正则表达式的下一个字符去匹配回溯之前匹配不上的文本。\n这里说的比较抽象，有兴趣的可以自行搜索下正则表达式的回溯以及贪婪模式、懒惰模式（也叫勉强模式）和独占模式（也叫侵占模式），下面附上一篇图文并茂的文章：正则表达式三种模式：贪婪模式、懒惰模式、独占模式\n总之，简单地说，由于正则表达式的回溯，如果我们的正则表达式写得不够好，并且被匹配的字符串文本又非常长，就有可能大量触发回溯，导致CPU飙升，甚至是堆栈溢出。这也就是所谓的灾难性回溯，或者说回溯陷阱。\n这里还是拿上面文章里的例子来举例：为了校验马来西亚的商店名字，写了如下一条正则表达式：\n1 ^([A-Za-z0-9._()\u0026amp;\u0026#39;\\\\- ]|[aAàÀảẢãÃáÁạẠăĂằẰẳẲẵẴắẮặẶâÂầẦẩẨẫẪấẤậẬbBcCdDđĐeEèÈẻẺẽẼéÉẹẸêÊềỀểỂễỄếẾệỆfFgGhHiIìÌỉỈĩĨíÍịỊjJkKlLmMnNoOòÒỏỎõÕóÓọỌôÔồỒổỔỗỖốỐộỘơƠờỜởỞỡỠớỚợỢpPqQrRsStTuUùÙủỦũŨúÚụỤưƯừỪửỬữỮứỨựỰvVwWxXyYỳỲỷỶỹỸýÝỵỴzZ])+$ 这就是一个很简单的^()+$结构，由于校验允许使用英文字母大小写、数字、越南文和一些特殊字符如“\u0026amp;”，“-”，“_”等，于是直接把这些字符都塞到[]里，然后为了方便观看把越南文特地抽出来塞到另一个[]里，最后把这两个[]用|拼接起来。\n看上去非常简单的结构，但却会在线上时不时引发CPU过高的问题，可以用下面的测试类简单跑一下看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import java.util.regex.Matcher; import java.util.regex.Pattern; public class Test { private static final String REGEX_TABLE_ALIAS = \u0026#34;^([A-Za-z0-9._()\u0026amp;\u0026#39;\\\\- ]|[aAàÀảẢãÃáÁạẠăĂằẰẳẲẵẴắẮặẶâÂầẦẩẨẫẪấẤậẬbBcCdDđĐeEèÈẻẺẽẼéÉẹẸêÊềỀểỂễỄếẾệỆfFgGhHiIìÌỉỈĩĨíÍịỊjJkKlLmMnNoOòÒỏỎõÕóÓọỌôÔồỒổỔỗỖốỐộỘơƠờỜởỞỡỠớỚợỢpPqQrRsStTuUùÙủỦũŨúÚụỤưƯừỪửỬữỮứỨựỰvVwWxXyYỳỲỷỶỹỸýÝỵỴzZ])+$\u0026#34;; public static void main(final String[] args) { final String string = \u0026#34;aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!\u0026#34;; final Pattern pattern = Pattern.compile(REGEX_TABLE_ALIAS); final Matcher matcher = pattern.matcher(string); final boolean result = matcher.find(); System.out.println(result); } } 你会发现，当在校验这个aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!字符串时，竟然无法立刻打印出校验结果，需要等待相当长的一段时间。如果把这个字符串改成这个，!aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa，就可以秒出结果。\n这两个字符串是一样长，区别仅仅是!在首位和末位而已，但在校验时花费的时间却完全不同，原因是!是非法字符，但在末位时，会触发大量回溯，如果这个字符串文本有数百位，上千位，就很有可能会发生堆栈溢出。\n原文作者的解决方法是把原来的正则表达式改为独占模式，也就是在+后加上+，将^()+$结构变成^()++$结构。这种做法我认为其实不太好，独占模式也是会尽可能地匹配更多的字符，但是却不会发生回溯，如果正则表达式写得不好，就可能会校验漏。\n其实有个更好的改法，就是单纯把原来的表达式里的两个[]合并成一个[]，如下：\n1 ^([A-Za-z0-9._()\u0026amp;\u0026#39;\\\\- aAàÀảẢãÃáÁạẠăĂằẰẳẲẵẴắẮặẶâÂầẦẩẨẫẪấẤậẬbBcCdDđĐeEèÈẻẺẽẼéÉẹẸêÊềỀểỂễỄếẾệỆfFgGhHiIìÌỉỈĩĨíÍịỊjJkKlLmMnNoOòÒỏỎõÕóÓọỌôÔồỒổỔỗỖốỐộỘơƠờỜởỞỡỠớỚợỢpPqQrRsStTuUùÙủỦũŨúÚụỤưƯừỪửỬữỮứỨựỰvVwWxXyYỳỲỷỶỹỸýÝỵỴzZ])+$ 这时候再去跑上面的测试类，你会发现在校验上面的两个字符串文本时，都可以秒出校验结果。原因是新的表达式减少了回溯的机会，相当于把Java里连续多个if语句给合并成一个了，这样就减少了分支，自然就降低了灾难性回溯的可能性。\n具体案例与解决方案 上面是其他人遇到的案例，这里说下博主遇到的case以及最终的解决方案。在系统中我们用的是自己魔改过的mybatis，其中有个正则表达式是用来获取sql中的表别名的，如下：\n1 (FROM|JOIN|,)(\\\\s)+([A-Z0-9_]+(\\\\s)+[A-Z0-9_]+(,| )*)+(\\\\s)+(JOIN|WHERE|INNER|LEFT|OUTER|ON|ORDER) 这个本来一直都没有问题，直到前段时间系统迭代后，有客户在页面上搜索了一段比较长的字符串。这个搜索的操作其实就是向db发出一条sql，用来模糊查询若干个字段是否含有用户搜索的这段字符串。然后在组装这条sql的时候，会使用到上述的正则表达式来获取表别名，具体组装逻辑这里就不说了。最后组装成的sql比较长，大概一万多个字符（已经简化过了）。之所以这么长，是因为我们会拿用户输入的字符串去挨个模糊查询数据表里的很多个字符类型的列，也就是说，会有大量的like '%xxxx%'的部分。\n当这条很长的sql被上述的正则表达式匹配时，就会发生灾难性回溯，导致系统长时间假死。这里就不贴出来具体的sql了，就简单分析下上述正则表达式存在什么问题。\n表达式分成了三块部分，第一部分是(FROM|JOIN|,)(\\\\s)+，第二部分是([A-Z0-9_]+(\\\\s)+[A-Z0-9_]+(,| )*)+，第三部分是(JOIN|WHERE|INNER|LEFT|OUTER|ON|ORDER)。这个很好理解，就是简单匹配下表别名，比如：from Table_A a, Table_B b where ...。\n可以发现，表达式的第一部分和第二部分都有,，而第二部分的末尾使用了+限定必须至少匹配一次，导致当sql过长时并存在大量逗号空格时，会触发大量回溯。为了避免这种情况，应当尽量把第二部分末尾的+去掉，如果可能的话，可以转换成*。\n最终的修改方案是分为了两部分： 第一部分是简化sql，因为原本是直接拿组装后的sql去匹配，其实sql里大量的like '%xxxx%'部分毫无意义，因为目的只是拿到表别名而已。所以在匹配之前，把这些模糊匹配的部分直接去掉了。\n第二部分是修改正则表达式，测试时直接拿简化前的sql去匹配，如果不会发生灾难性回溯就算过关了。最终修改后的样子如下：\n1 (FROM|JOIN)(\\\\s)+([A-Z0-9_]+(\\\\s)+[A-Z0-9_]+((\\\\s)*(,|JOIN)(\\\\s)*[A-Z0-9_]+(\\\\s)+[A-Z0-9_]+)*)(\\\\s)+(JOIN|WHERE|INNER|LEFT|OUTER|ON|ORDER) 这里推荐个在线检查正则表达式匹配字符串文本的网站，可以用来发现是否会触发灾难性回溯：Online regex tester and debugger: PHP, PCRE, Python, Golang and JavaScript 关于这个网站的用法可以看看这篇文章的末尾部分：一个正则表达式引发的血案，让线上CPU100%异常！\n排查高CPU使用率的方法 使用top命令查找在大量占用CPU的进程的PID 使用ps -mp pid -o THREAD,tid,time定位到大量占用CPU的线程TID；也可以用这个命令直接排序下，更方便找到大量占用CPU的线程：ps -mp pid -o THREAD,tid,time|uniq -c|sort -nr 将上述找到的线程TID转换成十六进制：printf “%x\\n” TID，比如原本的线程TID是28802，可以用上面的命令转成十六进制数7082 使用PID以及刚刚转成十六进制的TID来打印出该线程的堆栈信息：jstack PID|grep TID -A 100。也可以把完整的堆栈信息输入到一个log文件里，有两种方法： 方法一是用kill -3 PID \u0026gt; threadDump.log 2\u0026gt;\u0026amp;1，这种方法不适用于JDK1.6以上的版本 方法二是用jstack -l PID \u0026gt; threadDump.log 2\u0026gt;\u0026amp;1 接下来就是分析堆栈信息，定位到问题代码的位置了。 下面简单介绍下上述命令的几个关键参数的含义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ps命令： -m 显示所有的执行者。 -p 指定进程的PID，并列出该进程的状况。 -o 用户自定义输出格式。 uniq命令： -c 检查文件是否已经按照顺序排序，排序过为真 sort命令： -n 按照数值大小进行排序 -r 以相反的顺序进行排序，即降序排序，从大排到小 jstack命令： -l long listing. Prints additional information about locks，会打印出额外的锁信息，可以在发生死锁时用来观察锁持有情况 -m to print both java and native frames (mixed mode),不仅会输出Java堆栈信息，还会输出C/C++堆栈信息（比如Native方法） kill命令： -signal 指定发送的信号类型，比如： -3是打印进程的线程信息，并不会终止进程； -9是强制杀死进程，一般用于立即杀死无响应或者卡死的进程； -15是柔和地终止进程，一般会在终止之前保存数据、关闭连接，需要经过一段时间后才会完全退出进程，效果等同于-TERM 参考链接 一个正则表达式引发的血案，让线上CPU100%异常！ 正则表达式的失控——回溯循环 正则表达式：java.util.regex.Pattern matcher 循环导致高CPU 正则表达式三种模式：贪婪模式、懒惰模式、独占模式 StackOverflowError in java.util.regex.Pattern linux系统中,kill -3查看java进程状态无效的解决方法 Win下，通过Jstack截取Java进程中的堆栈信息 linux ps 命令参数详解 Linux下面ps -o是什么意思 kill与kill -9的区别 使用 kill 命令杀死 java进程，你用对了吗？ sort、uniq命令对文本进行排序、单一和重复操作 ","permalink":"https://lewky.cn/posts/java-regex-issue/","tags":["Java","正则表达式","工作记录"],"title":"由Java正则表达式的灾难性回溯引发的高CPU异常：java.util.regex.Pattern$Loop.match"},{"categories":["中间件"],"contents":"问题与分析 在启动公司项目时发现报错如下：\n1 2 3 4 5 6 7 8 9 10 11 12 [jetty] 2019-10-07 10:28:28.760:WARN:org.apache.jasper.compiler.Compiler:Error compiling file: D:\\lewis.liu\\CBX_KME\\Program\\jetty-temp\\main\\jsp\\org\\apache\\jsp\\invalidatePrevSession_jsp.javanull [jetty] 2019-10-07 10:28:28.763:WARN::/main/invalidatePrevSession.jsp [jetty] org.apache.jasper.JasperException: PWC6033: Unable to compile class for JSP||PWC6199: Generated servlet error:|The import com.core.cbx.ui.zk.cul.grid.renderer.FileLinkCellRenderer cannot be resolved|| [jetty] at org.apache.jasper.compiler.DefaultErrorHandler.javacError(DefaultErrorHandler.java:123) [jetty] at org.apache.jasper.compiler.ErrorDispatcher.javacError(ErrorDispatcher.java:296) [jetty] at org.apache.jasper.compiler.Compiler.generateClass(Compiler.java:376) [jetty] at org.apache.jasper.compiler.Compiler.compile(Compiler.java:437) [jetty] at org.apache.jasper.JspCompilationContext.compile(JspCompilationContext.java:608) [jetty] at org.apache.jasper.servlet.JspServletWrapper.service(JspServletWrapper.java:360) [jetty] at org.apache.jasper.servlet.JspServlet.serviceJspFile(JspServlet.java:486) [jetty] at org.apache.jasper.servlet.JspServlet.service(JspServlet.java:380) [jetty] at javax.servlet.http.HttpServlet.service(HttpServlet.java:820) 非常直观的错误，在启动项目时，jetty报错，无法编译invalidatePrevSession.jsp该文件，原因是FileLinkCellRenderer这个类无法被解析。接着看该jsp文件，可以发现import了不少java类，如下：\n1 2 3 4 5 6 7 \u0026lt;%@page import=\u0026#34;com.core.cbx.action.ActionDispatcher\u0026#34;%\u0026gt; \u0026lt;%@page import=\u0026#34;com.core.cbx.action.exception.ActionException\u0026#34;%\u0026gt; \u0026lt;%@page import=\u0026#34;com.core.cbx.action.actionContext.UserRegisterIp\u0026#34;%\u0026gt; \u0026lt;%@page import=\u0026#34;org.apache.commons.lang3.BooleanUtils\u0026#34; %\u0026gt; \u0026lt;%@page language=\u0026#34;java\u0026#34; import=\u0026#34;java.util.*\u0026#34; pageEncoding=\u0026#34;UTF-8\u0026#34;%\u0026gt; \u0026lt;%@page import=\u0026#34;com.core.cbx.ui.zk.cul.grid.renderer.FileLinkCellRenderer\u0026#34;%\u0026gt; \u0026lt;%@page import=\u0026#34;com.core.cbx.resource.service.LabelManager\u0026#34;%\u0026gt; 那么问题来了，为什么只有FileLinkCellRenderer无法被解析？其它类却可以正常导入？继续查看这个无法导入的类，发现使用了Lambda表达式，将这些Lambda表达式注释掉，重新启动项目，发现不再发生上述错误，这说明JSP页面之所以无法被编译，正是由于导入的Java类中使用了Lambda表达式！\nLambda表达式是jdk1.8的新特性，而项目使用使用的是jetty6.1.26，在查询资料后了解到，这和jetty版本有关系。低版本的jetty并不支持jdk1.8，所以在编译JSP时，如果导入了使用到jdk1.8新特性的java文件就会报错。官网上虽然给出了jetty和jdk对应的版本关系，但并不是很准确。根据本人测试，在使用9.2.20.v20161216的jetty-maven插件时就不会遇到这个问题了。\n解决方法 方案一：使用更高版本的支持jdk1.8的jetty 改用至少9.2版本的jetty来启动项目，如果是maven项目，则可以使用如下版本的jetty插件：\n1 2 3 4 5 6 \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.jetty\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jetty-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;9.2.20.v20161216\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;/plugin\u0026gt; 方案二：不使用jdk1.8的新特性，譬如Lambda表达式 根据具体报错，将JSP里导入的java文件中有关的jdk1.8的新特性去掉，可以规避低版本jetty无法编译JSP文件的问题。\n参考链接 jetty各版本与JDK的对应关系 Jetty Maven 和JDK之间版本关系 页面报错500：无法为jsp编译解析类 ","permalink":"https://lewky.cn/posts/1411dcba.html/","tags":["Jetty","工作记录"],"title":"Jetty - Unable to compile class for JSP"},{"categories":["ELK"],"contents":"启动参数 启动Logstash时可以指定一些参数：\n1 2 3 4 5 -w # 指定线程,默认是cpu核数 -f # 指定配置文件 -r # 启用热加载，可以在运行期间修改配置文件并生效 -t # 测试配置文件是否正常 -b # 执行filter模块之前最大能积累的日志，数值越大性能越好，同时越占内存 关闭Logstash 如果将Logstash作为服务启动的，通过以下方式之一关闭：\n1 2 3 4 5 6 7 8 // systemd systemctl stop logstash // upstart initctl stop logstash // sysv /etc/init.d/logstash stop 如果是在POSIX系统的控制台中直接运行Logstash则这样关闭：\n1 kill -TERM {logstash_pid} 或者在控制台中输入Ctrl-C。\n启动、关闭脚本 下面是一个Logstash启动、关闭的ansible脚本，里面有几个环境变量（logstash_home，logstash_bin_folder，logstash_config）需要替换成对应的值才能作为一个完整的shell文件执行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 #!/bin/sh #LOGSTASH_USAGE is the message if this script is called without any options LOGSTASH_USAGE=\u0026#34;Usage: $0 {start|stop|status|restart}\u0026#34; #SHUTDOWN_WAIT is wait time in seconds for java proccess to stop SHUTDOWN_WAIT=20 #------ private functions logstash_pid() { echo `ps -fe | grep {{ logstash_home }} | grep -v grep | grep -v $0 | tr -s \u0026#34; \u0026#34;|cut -d\u0026#34; \u0026#34; -f2` } start() { pid=$(logstash_pid) if [ -n \u0026#34;$pid\u0026#34; ] then echo -e \u0026#34;Logstash is already running (pid: $pid)\u0026#34; else # Start Logstash echo -e \u0026#34;Starting Logstash\u0026#34; nohup sh {{ logstash_bin_folder }}/logstash -f {{ logstash_config }} \u0026amp; fi return 0 } status(){ pid=$(logstash_pid) if [ -n \u0026#34;$pid\u0026#34; ]; then echo -e \u0026#34;Logstash is running with pid: $pid\u0026#34; else echo -e \u0026#34;Logstash is not running\u0026#34; fi } stop() { pid=$(logstash_pid) if [ -n \u0026#34;$pid\u0026#34; ] then echo -e \u0026#34;Stoping Logstash [$pid]\u0026#34; kill -TERM $pid let kwait=$SHUTDOWN_WAIT count=0; until [ `ps -p $pid | grep -c $pid` = \u0026#39;0\u0026#39; ] || [ $count -gt $kwait ] do echo -n -e \u0026#34;\\nwaiting for processes to exit\u0026#34;; sleep 1 let count=$count+1; done if [ $count -gt $kwait ]; then echo -n -e \u0026#34;\\nkilling processes which didn\u0026#39;t stop after $SHUTDOWN_WAIT seconds\u0026#34; kill -9 $pid fi else echo -e \u0026#34;Logstash is not running\u0026#34; fi return 0 } #----- main program case $1 in start) start ;; stop) stop ;; restart) stop start ;; status) status ;; *) echo -e $LOGSTASH_USAGE ;; esac exit 0 分割字符串并添加新的字段到Elasticsearch 有时需要对收集到的日志等信息进行分割，并且将分割后的字符作为新的字段index到Elasticsearch里。假定需求如下：\nLogstash收集到的日志字段message的值是由多个字段拼接而成的，分隔符是;,;，如下：\n1 2 3 { \u0026#34;message\u0026#34;: \u0026#34;key_1=value_1;,;key_2=value_2\u0026#34; } 现在想要将message的值拆分成2个新的字段：key_1、key_2，并且将它们index到ES里，可以借助Logstash的filter的插件来完成；这里提供两种解决方案。\n方案一：使用mutate插件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 filter { mutate { split =\u0026gt; [\u0026#34;message\u0026#34;,\u0026#34;;,;\u0026#34;] } if [message][0] { mutate { add_field =\u0026gt; { \u0026#34;temp1\u0026#34; =\u0026gt; \u0026#34;%{[message][0]}\u0026#34; } } } if [message][1] { mutate { add_field =\u0026gt; { \u0026#34;temp2\u0026#34; =\u0026gt; \u0026#34;%{[message][1]}\u0026#34; } } } if [temp1][1] { mutate { split =\u0026gt; [\u0026#34;temp1\u0026#34;,\u0026#34;=\u0026#34;] add_field =\u0026gt; { \u0026#34;%{[temp1][0]}\u0026#34; =\u0026gt; \u0026#34;%{[temp1][1]}\u0026#34; } } } if [temp2][1] { mutate { split =\u0026gt; [\u0026#34;temp2\u0026#34;,\u0026#34;=\u0026#34;] add_field =\u0026gt; { \u0026#34;%{[temp2][0]}\u0026#34; =\u0026gt; \u0026#34;%{[temp2][1]}\u0026#34; } remove_field =\u0026gt; [ \u0026#34;temp1\u0026#34;, \u0026#34;temp2\u0026#34;, \u0026#34;message\u0026#34; ] } } } 在filter里可以通过if [varA]来判断一个变量varA是否为空或null，如果需要取反则是if ![varA]。\n从上面代码可以看出，这种做法很麻烦，也不利于日后的维护。每当message里被拼接的字段的数量增加时，就必须同步改动这里的filter逻辑，而且添加的代码量也是呈线性递增的。\n此外，这里使用的诸如temp1等临时变量，可以用[@metadata][temp1]的写法来作为临时变量，这样就不需要去手动remove掉了。\n方案二：使用ruby插件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 filter { ruby { code =\u0026gt; \u0026#34; array1 = event.get(\u0026#39;message\u0026#39;).split(\u0026#39;;,;\u0026#39;) array1.each do |temp1| if temp1.nil? then next end array2 = temp1.split(\u0026#39;=\u0026#39;) key = array2[0] value = array2[1] if key.nil? then next end event.set(key, value) end \u0026#34; remove_field =\u0026gt; [ \u0026#34;message\u0026#34; ] } } ruby插件可以允许你使用ruby的语法来完成各种复杂的逻辑，使用这种方案可以完美解决方案一中的不足之处，便于日后的维护。\nblock in multi_receive_encoded 测试坏境中Logstash总是会down掉，查看了下日志文件，发现报错如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 [2019-06-28T07:56:13,148][FATAL][logstash.runner ] An unexpected error occurred! { : error=\u0026gt;#\u0026lt;Errno: : EPIPE: Brokenpipe-\u0026lt;STDOUT\u0026gt;\u0026gt;, : backtrace=\u0026gt;[\u0026#34;org/jruby/RubyIO.java:1457:in `write\u0026#39;\u0026#34;, \u0026#34;org/jruby/RubyIO.java:1428:in `write\u0026#39;\u0026#34;, \u0026#34;/home/cbx6/software/logstash-6.6.1/vendor/bundle/jruby/2.3.0/gems/logstash-output-stdout-3.1.4/lib/logstash/outputs/stdout.rb:43:in `block in multi_receive_encoded\u0026#39;\u0026#34;, \u0026#34;org/jruby/RubyArray.java:1734:in `each\u0026#39;\u0026#34;, \u0026#34;/home/cbx6/software/logstash-6.6.1/vendor/bundle/jruby/2.3.0/gems/logstash-output-stdout-3.1.4/lib/logstash/outputs/stdout.rb:42:in `multi_receive_encoded\u0026#39;\u0026#34;, \u0026#34;/home/cbx6/software/logstash-6.6.1/logstash-core/lib/logstash/outputs/base.rb:87:in `multi_receive\u0026#39;\u0026#34;, \u0026#34;org/logstash/config/ir/compiler/OutputStrategyExt.java:114:in `multi_receive\u0026#39;\u0026#34;, \u0026#34;org/logstash/config/ir/compiler/AbstractOutputDelegatorExt.java:97:in `multi_receive\u0026#39;\u0026#34;, \u0026#34;/home/cbx6/software/logstash-6.6.1/logstash-core/lib/logstash/pipeline.rb:390:in `block in output_batch\u0026#39;\u0026#34;, \u0026#34;org/jruby/RubyHash.java:1343:in `each\u0026#39;\u0026#34;, \u0026#34;/home/cbx6/software/logstash-6.6.1/logstash-core/lib/logstash/pipeline.rb:389:in `output_batch\u0026#39;\u0026#34;, \u0026#34;/home/cbx6/software/logstash-6.6.1/logstash-core/lib/logstash/pipeline.rb:341:in `worker_loop\u0026#39;\u0026#34;, \u0026#34;/home/cbx6/software/logstash-6.6.1/logstash-core/lib/logstash/pipeline.rb:304:in `block in start_workers\u0026#39;\u0026#34;] } 从堆栈信息里可以看到关键字眼：block in multi_receive_encoded，block in output_batch；另外，还可以发现这些错误信息都是由logstash-output-stdout-3.1.4这个插件引发的。\n简单分析来看，应该是由于测试环境下同一时间内太多message要经由logstash-output-stdout输出到控制台造成的某种未知的并发问题。下面是对应的Logstash的output的配置：\n1 2 3 4 5 6 7 8 9 10 output { stdout { codec =\u0026gt; rubydebug } elasticsearch { hosts =\u0026gt; [\u0026#34;{{ cbx_logstash_es_server }}\u0026#34;] index =\u0026gt; \u0026#34;%{indexName}\u0026#34; action =\u0026gt; \u0026#34;index\u0026#34; } } 根据配置，并结合堆栈信息来分析，可以认为是Logstash的stdout插件在高并发状态下使用rubydebug进行编解码时抛出了异常。\n其实这里的stdout插件是不必要的，之前只是在本地测试使用到的。而在测试环境下，并发量远非本地测试能比，此外将大量的message输出到console上也会对性能产生影响。可以说，这种配置等同于在Java代码中频繁使用System.out.print()语句来输出信息，应该去除掉，最终output的配置如下：\n1 2 3 4 5 6 7 output { elasticsearch { hosts =\u0026gt; [\u0026#34;{{ cbx_logstash_es_server }}\u0026#34;] index =\u0026gt; \u0026#34;%{indexName}\u0026#34; action =\u0026gt; \u0026#34;index\u0026#34; } } 将stdout插件的配置去除后，在之后的一段时间里，测试环境的Logstash不再发生异常退出，证实该issue确实是由stdout的codec所引发的。注意，不要在正式环境使用该插件来输出信息到控制台，有可能会引发类似的并发异常问题或者性能问题。\n参考链接 Logstash事件字段遍历 Logstash详解之——filter模块 logstash filter如何判断字段是够为空或者null Shutting Down Logstash ","permalink":"https://lewky.cn/posts/elk-3/","tags":["Logstash","工作记录"],"title":"ELK系列(3) - Logstash问题汇总"},{"categories":["ELK"],"contents":"修改日期格式Date format Kibana在创建Index Patterns的时候，可以选择某个date类型的field作为排序字段。之后在Discover里打开对应的index，会发现这个date类型的field的格式显示如下：\n1 April 10th 2019, 17:40:32.359 这是Kibana默认的日期格式，有两种修改的方式。\n方式一：全局修改 登录http://localhost:5601/，会进入Kibana的页面，选择Management -\u0026gt; Index Patterns -\u0026gt; Advanced Settings，找到Date format，如何修改这里的值，默认是MMMM Do YYYY, HH:mm:ss.SSS。\n可以改成YYYY-MM-DD HH:mm:ss.SSS，这样页面的所有日期就会显示成2019-04-23 16:30:39.139这种格式了。\n方式二：局部修改 可以只针对某个时间字段进行修改，这样就不会影响到其它的时间字段，允许不同字段用不同的日期格式。\n登录http://localhost:5601/，会进入Kibana的页面，选择Management -\u0026gt; Index Patterns，选择某个已经创建好的index pattern，接着在Fields这个tab里找到对应的日期字段，点击那个字段最后的铅笔图标（Edit）进行编辑。\n对于date类型的字段，其Format默认是选择了- Default -，将其改为选择Date，然后将下面的format改成YYYY-MM-DD HH:mm:ss.SSS，最后再点击下方的Save field。\n关闭Kibana 通过以下方式找到Kibana的进程：\n1 2 3 4 5 6 7 8 ps -ef | grep kibana ps -ef | grep 5601 ps -ef | grep node // 直接用Kibana所在的目录（即下面的$Kibana_home）来查是最准确的 ps -ef | grep $Kibana_home 然后根据上面得到的pid（即下面的$pid）来杀死Kibana的进程：\n1 2 3 4 kill -TERM $pid // 上面的命令不起效果时可以用这个 kill -9 $pid Scripted field Kibana在创建Index Pattern的时候，可以选择创建脚本字段Scripted field，该字段由Painless语言编写，可以为当前的索引创建一个额外的临时字段，用来实现诸如统计等功能。脚本字段虽然强大，但是别滥用，会影响内存和性能。\nPainless具体语法可以看这个官方文档。\n全文搜索 Kibana的搜索框如果输入搜索的关键字，会将关键字进行全文搜索，如果关键字是一个短语（比如带有空格的一段英文），则会自动进行分词再全文搜索。\n如果不希望短语被分词，则需要将短语用一对英文括号包括起来。比如说搜索关键字是\u0026quot;Quick brown fox\u0026quot;，那么就不会匹配到\u0026quot;quick fox brown\u0026quot;。因为被括号包括起来的短语是一个整体，不会被分词，因此匹配顺序不能被颠倒。\nQuery String Kibana的搜索框也支持Query String，即原本完整的ES查询DSL的简化字符串，如下是一个Query DSL：\n1 2 3 4 5 6 7 { \u0026#34;query\u0026#34;:{ \u0026#34;match\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;elastic\u0026#34; } } } 上面的Query DSL可以简化为如下Query String：\n1 name:elastic Kibana的搜索框可以用上面的Query String来查询，也可以直接用DSL来查询：\n1 2 3 4 5 { \u0026#34;match\u0026#34;:{ \u0026#34;name\u0026#34;:\u0026#34;elastic\u0026#34; } } 下面是常用的一些Query String语法：\n字段搜索 1 2 3 4 5 6 7 8 9 10 11 // 字段搜索 field:value // 字段短语搜索（精确搜索，对应的term查询，不会被分词，必须完全匹配） field:\u0026#34;value\u0026#34; // 查询存在某字段的数据 _exists_:field // 查询不存在某字段的数据，NOT要大写 NOT (_exists_:field) 通配符查询wildcard search 通配符：?匹配单个字符，*匹配0到多个字符。\n通配符性能较低下，因此不要把通配符放在最前面，会占用较多内存，谨慎使用。\n1 2 // 如下可以匹配到commandType为EntityChangedEvent的数据 commandType:entit?c*vent 运算符 由于lucene没有实现运算符优先级的解析，所以对于一些复杂的组合查询最好用小括号包括起来。\n如果不用符号来替代运算符，则必须使用大写，否则没有效果（or除外，实际上其他运算符如果不用大写就相当于使用了默认的运算符OR），比如不能使用and，而应该使用AND。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 且运算AND，也可以用\u0026amp;\u0026amp;代替 category:doc \u0026amp;\u0026amp; commandType:senddoc1 category:doc AND commandType:senddoc1 // 或运算OR，也可以用||代替 category:doc || commandType:senddoc1 commandType:(senddoc1 OR senddoc8) // 非运算NOT，也可以用!代替 !(_exists_:category) commandType:(senddoc* NOT senddoc8) // must查询，用+表示，必须用小括号包括起来 commandType:(+senddoc1) // must not查询，用-表示，必须用小括号包括起来 commandType:(-senddoc1) name:(tom +lee -alfred) 正则查询regular expressionsearch 支持部分正则，用一对/包括起来，但是正则内存压力较大，性能较差，谨慎使用。\n1 2 // 如下可以匹配到commandType为EntityChangedEvent的数据 commandType:/[a-z]*event/ 模糊搜索fuzzy search 模糊查询是指允许搜索和匹配的词（term）之间有差异，比如搜索surprize，可以匹配到surprise。\n在value后面加上~即可开启模糊搜索，默认模糊度为2，也可以在~后自行设置0~2之间的浮点数作为模糊度。\n1 2 3 // 如下可以匹配到commandType为EntityChangedEvent的数据 commandType:EntityChangedEvemtt~ commandType:EntityChangedEvemtt~1.1 近似度查询 proximity search 近似度查询是指在一个短语（phrase）中，词（term）与词之间距离的匹配。换言之，这是一个专门给短语使用的模糊搜索。\n1 2 // 匹配时允许tom和lee之间有2个词的距离 name:\u0026#34;tom lee\u0026#34;~2 范围查询range search 数值和日期类型可以用范围查询，闭区间用[]，开区间用{}；也可以用简略写法。\nIP和字符也可以使用范围查询来限制字符。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // 1\u0026lt;=age\u0026lt;=10 age:[1 TO 10] age:(\u0026gt;=1 \u0026amp;\u0026amp; \u0026lt;=10) age:(+\u0026gt;=1 +\u0026lt;=10) // 1\u0026lt;=age\u0026lt;10 age:[1 TO 10} age:(\u0026gt;=1 \u0026amp;\u0026amp; \u0026lt;10) age:(+\u0026gt;=1 +\u0026lt;10) // age\u0026gt;=1 age:[1 TO ] age:\u0026gt;=1 // age\u0026lt;=10 age:[* TO 10] age:\u0026lt;=10 其他例子：\n1 2 3 ip:[\u0026#34;172.24.20.110\u0026#34; TO \u0026#34;172.24.20.140\u0026#34;] date:{\u0026#34;now-6h\u0026#34; TO \u0026#34;now\u0026#34;} tag:{b TO e} // 搜索b到e中间的字符 提升查询权重boosting term 默认查询权重是1，通过调整权重来改变查询结果的优先级\n1 2 // 当name中包含tom时，其权重是lee的4倍 name:(tom^4 lee) 特殊字符过滤 由于Query String本身使用了一些字符作为关键字，因此若想查询这些字符，需要用\\进行转义。\n1 2 // 查询(1+1):2 \\(1\\+1\\)\\:2 参考链接 Kibana顶部的那个输入框你知道怎么用吗？ ","permalink":"https://lewky.cn/posts/elk-2/","tags":["Kibana","工作记录"],"title":"ELK系列(2) - Kibana问题汇总"},{"categories":["ELK"],"contents":"前言 最近公司分了个ELK相关的任务给我，在一边学习一边工作之余，总结下这些天来的学习历程和踩坑记录。\n首先介绍下使用ELK的项目背景：在项目的数据库里有个表用来存储消息队列的消费日志，这些日志用于开发者日后的维护。每当客户端生产一条消息并发送到消息队列后，就会插入一条对应的记录到数据库里。当这条消息被消费之后，又会更新数据库里对应的记录的几个column的值，比如status、updated_on这些常用的column。\n由于客户每天生产消费的消息很多，导致数据库里的这个表里的数据很多，长年累月下来，会达到数以亿计。领导决定不再把这些消费日志保存到数据库，而是改为通过Log4j2 + ELK架构把这些日志保存到Elasticsearch里。\nELK简介 ELk是Elasticsearch + Logstash + Kibana的缩写，ELK一般用来收集分布式架构下各个节点的日志，并进行统一地管理。\nElasticsearch是个开源分布式搜索引擎，提供搜集、分析、存储数据三大功能。它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。\nLogstash主要是用来日志的搜集、分析、过滤日志的工具，支持大量的数据获取方式。一般工作方式为c/s架构，client端安装在需要收集日志的主机上，server端负责将收到的各节点日志进行过滤、修改等操作在一并发往elasticsearch上去。\nKibana也是一个开源和免费的工具，Kibana可以为Logstash和ElasticSearch提供的日志分析友好的Web界面，可以帮助汇总、分析和搜索重要数据日志。\n上面的官方介绍可能会比较抽象，按我个人的理解，可以简单将ELK理解为一个MVC架构的Java web应用：Elasticsearch对应M，Logstash对应C，Kibana对应V。\n由于项目使用的是6.4.2版本的Elasticsearch，所以整个ELK都采用了同样的版本6.4.2。这三个软件都可以直接从官网下载到，下面是官网地址。\n→ 官方下载地址\nELK的下载安装与快速入门 本文只是基于Windows平台下，进行简单的快速入门，先搭建好ELK框架并测试通过，后续文章再记录更多的细节。\nElasticsearch 6.4.2 从官网下载了6.4.2版本的Elasticsearch的压缩版后，解压即可使用，使用默认的配置即可。\n在Elasticsearch的安装目录下，进入/bin目录，可以看到有两个文件：\nelaticsearch elaticsearch.bat 这两个文件都可以启动Elasticsearch，暂时没发现在Windows平台下通过这两个文件启动Elasticsearch有什么不同。我一般使用没有后缀名的那个文件来启动Elasticsearch。\n启动成功后，在浏览器输入127.0.0.1:9200，如果访问成功会反馈信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { \u0026#34;name\u0026#34; : \u0026#34;erwbgE5\u0026#34;, \u0026#34;cluster_name\u0026#34; : \u0026#34;elasticsearch\u0026#34;, \u0026#34;cluster_uuid\u0026#34; : \u0026#34;QQvV3hBnSCSGsf-ycD3fng\u0026#34;, \u0026#34;version\u0026#34; : { \u0026#34;number\u0026#34; : \u0026#34;6.4.2\u0026#34;, \u0026#34;build_flavor\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;build_type\u0026#34; : \u0026#34;zip\u0026#34;, \u0026#34;build_hash\u0026#34; : \u0026#34;04711c2\u0026#34;, \u0026#34;build_date\u0026#34; : \u0026#34;2018-09-26T13:34:09.098244Z\u0026#34;, \u0026#34;build_snapshot\u0026#34; : false, \u0026#34;lucene_version\u0026#34; : \u0026#34;7.4.0\u0026#34;, \u0026#34;minimum_wire_compatibility_version\u0026#34; : \u0026#34;5.6.0\u0026#34;, \u0026#34;minimum_index_compatibility_version\u0026#34; : \u0026#34;5.0.0\u0026#34; }, \u0026#34;tagline\u0026#34; : \u0026#34;You Know, for Search\u0026#34; } 注意，如果使用Elasticsearch5.X及以上的版本，需要使用jdk 1.8；5.X以下版本使用jdk 1.6或1.7。\nLogstash 6.4.2 同样从官网下载6.4.2版本的Logstash安装包，解压之后进入/config目录，创建一个配置文件tcp.conf，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 input { stdin { } } filter { } output { stdout { codec =\u0026gt; rubydebug } } 接着进入/bin目录，运行命令如下：\n1 logstash -f ../config/test.conf 当看到Successfully started Logstash API endpoint的字眼时表示启动成功，此时输入任意字符，比如输入hello，可以得到相应的反馈，如下：\n1 2 3 4 5 6 { \u0026#34;message\u0026#34; =\u0026gt; \u0026#34;hello\\r\u0026#34;, \u0026#34;@timestamp\u0026#34; =\u0026gt; 2019-05-09T14:48:04.033Z, \u0026#34;host\u0026#34; =\u0026gt; \u0026#34;DESKTOP-S7HJJKD\u0026#34;, \u0026#34;@version\u0026#34; =\u0026gt; \u0026#34;1\u0026#34; } 这里解释下，Logstash的配置非常简单，就是一套流程：input -\u0026gt; filter -\u0026gt; output。\ninput用来收集信息，这里配置的是stdin插件，即标准输入，也就是刚刚在控制台里输入的字符串。 filter表示过滤信息，这里没有进行任何过滤。 output表示输出信息，这里配置的是stdout插件，即标准输出，也就是将信息输出到控制台上。这里的codec指明使用rubydebug作为编解码器。\n接着是运行的命令，使用了-f参数来指定使用某个配置文件。如果想要热加载的效果，可以加上-r参数，这样就可以在运行Logstash的时候去修改配置文件并自动重加载生效。这个-r参数等同于--config.reload.automatic。如下：\n1 2 logstash -f ../config/test.conf -r logstash -f ../config/test.conf --config.reload.automatic 注意，如果在输入源里使用了stdin或者syslog等输入插件，是不支持热加载的，会一直报错。\nKibana 6.4.2 从官网上下载Kibana6.4.2的压缩包，解压后即可使用。接着进入/bin目录，运行kibana.bat。运行成功后，在浏览器输入localhost:5601，即可访问Kibana的页面，之后就可以通过这个Kibana提供的web界面来对Elasticsearch里的文档进行各种操作。\nLogstash + Log4j2的快速搭建用例其一 配置tcp插件并启动Logstash 修改之前创建的Logstash的配置文件test.config，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 input { tcp { mode =\u0026gt; \u0026#34;server\u0026#34; host =\u0026gt; \u0026#34;127.0.0.1\u0026#34; port =\u0026gt; 4567 } } filter { } output { stdout { codec =\u0026gt; rubydebug } } 然后运行命令logstash -f ../config/test.conf -r来启动Logstash。由于我们这里通过-r来启用了热加载功能，所以可以在运行中直接修改配置并生效，比如修改input里的port。热加载成功后会看到如下字眼：\n1 Reloading pipeline {\u0026#34;pipeline.id\u0026#34;=\u0026gt;:main} 使用了Socket Appender的Log4j2项目demo 接着准备一个使用了Log4j2的项目demo，如下是一个测试类Test.java：\n1 2 3 4 5 6 7 8 9 10 import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class Test { public static final Logger LOGGER = LogManager.getLogger(\u0026#34;elk.test\u0026#34;); public static void main(final String[] args) { LOGGER.info(\u0026#34;Hello world!\u0026#34;); } } 这里使用的是2.11.1版本的Log4j2，Maven依赖如下：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 接着是配置Log4j2的配置文件log4j2.xml，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration xmlns:xi=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34; monitorInterval=\u0026#34;30\u0026#34;\u0026gt; \u0026lt;Properties\u0026gt; \u0026lt;Property name=\u0026#34;LOG_PATTERN\u0026#34;\u0026gt;{\u0026#34;logger\u0026#34;: \u0026#34;%logger\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;%level\u0026#34;, \u0026#34;msg\u0026#34;: \u0026#34;%message\u0026#34;}%n\u0026lt;/Property\u0026gt; \u0026lt;/Properties\u0026gt; \u0026lt;Appenders\u0026gt; \u0026lt;Console name=\u0026#34;stdout\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;${LOG_PATTERN}\u0026#34; /\u0026gt; \u0026lt;/Console\u0026gt; \u0026lt;Socket name=\u0026#34;logstash-tcp\u0026#34; host=\u0026#34;127.0.0.1\u0026#34; port=\u0026#34;4567\u0026#34; protocol=\u0026#34;TCP\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;${LOG_PATTERN}\u0026#34;/\u0026gt; \u0026lt;/Socket\u0026gt; \u0026lt;/Appenders\u0026gt; \u0026lt;Loggers\u0026gt; \u0026lt;Logger name=\u0026#34;elk.test\u0026#34; level=\u0026#34;info\u0026#34; additivity=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;stdout\u0026#34; /\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;logstash-tcp\u0026#34; /\u0026gt; \u0026lt;/Logger\u0026gt; \u0026lt;Root level=\u0026#34;error\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;stdout\u0026#34; /\u0026gt; \u0026lt;/Root\u0026gt; \u0026lt;/Loggers\u0026gt; \u0026lt;/configuration\u0026gt; 从配置文件中可以看到，这里使用的是Socket Appender来将日志打印的信息发送到Logstash。\n注意了，Socket的Appender必须要配置到下面的Logger才能将日志输出到Logstash里！\n另外这里的host是部署了Logstash服务端的地址，并且端口号要和你在Logstash里配置的一致才行。\n运行该项目demo，可以看到Logstash的控制台收集到了数据，如下：\n1 2 3 4 5 6 7 { \u0026#34;host\u0026#34; =\u0026gt; \u0026#34;127.0.0.1\u0026#34;, \u0026#34;message\u0026#34; =\u0026gt; \u0026#34;{\\\u0026#34;logger\\\u0026#34;: \\\u0026#34;elk.test\\\u0026#34;, \\\u0026#34;level\\\u0026#34;: \\\u0026#34;INFO\\\u0026#34;, \\\u0026#34;msg\\\u0026#34;: \\\u0026#34;Hello world!\\\u0026#34;}\\r\u0026#34;, \u0026#34;@timestamp\u0026#34; =\u0026gt; 2019-05-09T16:20:35.940Z, \u0026#34;@version\u0026#34; =\u0026gt; \u0026#34;1\u0026#34;, \u0026#34;port\u0026#34; =\u0026gt; 49781 } 注意 这里由于使用的是Socket方式来连接Logstash的服务端，如果在连接期间，Logstash的服务停止了或者断掉了，就算接下来重启了Logstash，项目工程也无法自动重新连接上Logstash，除非重启项目工程。\n在生产环境中，Logstash自然是有可能半路出问题重启的，所以不能使用这种Socket方式来传输日志。\n可以使用gelf的方式来传输日志到Logstash，用例如下所示。\nLogstash + Log4j2的快速搭建用例其二 配置gelf插件并启动Logstash 修改之前创建的Logstash的配置文件test.config，内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 input { gelf { host =\u0026gt; \u0026#34;127.0.0.1\u0026#34; port =\u0026gt; 4567 use_tcp =\u0026gt; true } } filter { } output { stdout { codec =\u0026gt; rubydebug } } 运行命令logstash -f ../config/test.conf -r启动Logstash。\n在Log4j2项目中使用Gelf Appender 将之前的项目工程里的log4j2.xml的Socket Appender改为使用Gelf Appender，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration xmlns:xi=\u0026#34;http://www.w3.org/2001/XInclude\u0026#34; monitorInterval=\u0026#34;30\u0026#34;\u0026gt; \u0026lt;Properties\u0026gt; \u0026lt;Property name=\u0026#34;LOG_PATTERN\u0026#34;\u0026gt;{\u0026#34;logger\u0026#34;: \u0026#34;%logger\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;%level\u0026#34;, \u0026#34;msg\u0026#34;: \u0026#34;%message\u0026#34;}%n\u0026lt;/Property\u0026gt; \u0026lt;/Properties\u0026gt; \u0026lt;Appenders\u0026gt; \u0026lt;Console name=\u0026#34;stdout\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;${LOG_PATTERN}\u0026#34; /\u0026gt; \u0026lt;/Console\u0026gt; \u0026lt;Gelf name=\u0026#34;logstash-gelf\u0026#34; host=\u0026#34;tcp:localhost\u0026#34; port=\u0026#34;4567\u0026#34; version=\u0026#34;1.1\u0026#34; ignoreExceptions=\u0026#34;true\u0026#34; extractStackTrace=\u0026#34;true\u0026#34; filterStackTrace=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;Field name=\u0026#34;timestamp\u0026#34; pattern=\u0026#34;%d{yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss.SSSZ}\u0026#34; /\u0026gt; \u0026lt;Field name=\u0026#34;level\u0026#34; pattern=\u0026#34;%level\u0026#34; /\u0026gt; \u0026lt;Field name=\u0026#34;simpleClassName\u0026#34; pattern=\u0026#34;%C{1}\u0026#34; /\u0026gt; \u0026lt;Field name=\u0026#34;className\u0026#34; pattern=\u0026#34;%C\u0026#34; /\u0026gt; \u0026lt;Field name=\u0026#34;server\u0026#34; pattern=\u0026#34;%host\u0026#34; /\u0026gt; \u0026lt;/Gelf\u0026gt; \u0026lt;/Appenders\u0026gt; \u0026lt;Loggers\u0026gt; \u0026lt;Logger name=\u0026#34;elk.test\u0026#34; level=\u0026#34;info\u0026#34; additivity=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;stdout\u0026#34; /\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;logstash-gelf\u0026#34; /\u0026gt; \u0026lt;/Logger\u0026gt; \u0026lt;Root level=\u0026#34;error\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;stdout\u0026#34; /\u0026gt; \u0026lt;/Root\u0026gt; \u0026lt;/Loggers\u0026gt; \u0026lt;/configuration\u0026gt; 另外，这个Gelf Appender需要导入另一个依赖，如下：\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;biz.paluch.logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logstash-gelf\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.11.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 接着运行项目工程，可以看到Logstash的控制台已经把收集到的日志打印出来了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;message\u0026#34; =\u0026gt; \u0026#34;Hello world!\u0026#34;, \u0026#34;@timestamp\u0026#34; =\u0026gt; 2019-05-10T14:09:43.267Z, \u0026#34;className\u0026#34; =\u0026gt; \u0026#34;lewky.cn.Test\u0026#34;, \u0026#34;source_host\u0026#34; =\u0026gt; \u0026#34;127.0.0.1\u0026#34;, \u0026#34;timestamp\u0026#34; =\u0026gt; \u0026#34;2019-05-10T22:09:43.211+0800\u0026#34;, \u0026#34;simpleClassName\u0026#34; =\u0026gt; \u0026#34;Test\u0026#34;, \u0026#34;facility\u0026#34; =\u0026gt; \u0026#34;logstash-gelf\u0026#34;, \u0026#34;level\u0026#34; =\u0026gt; \u0026#34;INFO\u0026#34;, \u0026#34;host\u0026#34; =\u0026gt; \u0026#34;DESKTOP-S7HJJKD\u0026#34;, \u0026#34;@version\u0026#34; =\u0026gt; \u0026#34;1\u0026#34;, \u0026#34;server\u0026#34; =\u0026gt; \u0026#34;DESKTOP-S7HJJKD\u0026#34; } ELK + Log4j2快速搭建用例 接下来就可以把Logstash收集到的日志输出到Elasticsearch，并通过Kibana显示到界面上。\nLogstash配置Elasticsearch插件 修改配置文件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 input { gelf { host =\u0026gt; \u0026#34;127.0.0.1\u0026#34; port =\u0026gt; 4567 use_tcp =\u0026gt; true } } filter { } output { stdout { codec =\u0026gt; rubydebug } elasticsearch { hosts =\u0026gt; [\u0026#34;127.0.0.1:9200\u0026#34;] document_id =\u0026gt; \u0026#34;%{docId}\u0026#34; index =\u0026gt; \u0026#34;%{indexName}\u0026#34; } } output里添加了elasticsearch插件：\nhosts里配置Elasticsearch server的地址 document_id是index到ES时使用的索引id index是index到ES是使用的索引名字 修改log4j2.xml和项目代码 在项目的log4j2.xml里的Gelf Appender加上两个个新的Field：indexName和docId，如下：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;Gelf name=\u0026#34;logstash-gelf\u0026#34; host=\u0026#34;tcp:localhost\u0026#34; port=\u0026#34;4567\u0026#34; version=\u0026#34;1.1\u0026#34; ignoreExceptions=\u0026#34;true\u0026#34; extractStackTrace=\u0026#34;true\u0026#34; filterStackTrace=\u0026#34;false\u0026#34;\u0026gt; \u0026lt;Field name=\u0026#34;timestamp\u0026#34; pattern=\u0026#34;%d{yyyy-MM-dd\u0026#39;T\u0026#39;HH:mm:ss.SSSZ}\u0026#34; /\u0026gt; \u0026lt;Field name=\u0026#34;level\u0026#34; pattern=\u0026#34;%level\u0026#34; /\u0026gt; \u0026lt;Field name=\u0026#34;simpleClassName\u0026#34; pattern=\u0026#34;%C{1}\u0026#34; /\u0026gt; \u0026lt;Field name=\u0026#34;className\u0026#34; pattern=\u0026#34;%C\u0026#34; /\u0026gt; \u0026lt;Field name=\u0026#34;server\u0026#34; pattern=\u0026#34;%host\u0026#34; /\u0026gt; \u0026lt;Field name=\u0026#34;indexName\u0026#34; mdc=\u0026#34;indexName\u0026#34; /\u0026gt; \u0026lt;Field name=\u0026#34;docId\u0026#34; mdc=\u0026#34;docId\u0026#34; /\u0026gt; \u0026lt;/Gelf\u0026gt; 这里添加的两个新的Field对应于上边Logstash配置文件里的两个变量，然后这里用到了mdc，这个是Log4j2里的ThreadContext的东西，有兴趣可以去了解下Log4j2里的MDC和NDC。\n接着修改测试类的代码，如下：\n1 2 3 4 5 6 7 8 9 10 public class Test { public static final Logger LOGGER = LogManager.getLogger(\u0026#34;elk.test\u0026#34;); public static void main(final String[] args) { ThreadContext.put(\u0026#34;docId\u0026#34;, \u0026#34;1\u0026#34;); ThreadContext.put(\u0026#34;indexName\u0026#34;, \u0026#34;test\u0026#34;); LOGGER.info(\u0026#34;Hello world!\u0026#34;); } } 接着依次启动ELK三个软件，然后运行项目，可以发现Logstash控制台里收集到了日志信息：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { \u0026#34;simpleClassName\u0026#34; =\u0026gt; \u0026#34;Test\u0026#34;, \u0026#34;server\u0026#34; =\u0026gt; \u0026#34;DESKTOP-S7HJJKD\u0026#34;, \u0026#34;message\u0026#34; =\u0026gt; \u0026#34;Hello world!\u0026#34;, \u0026#34;@version\u0026#34; =\u0026gt; \u0026#34;1\u0026#34;, \u0026#34;source_host\u0026#34; =\u0026gt; \u0026#34;127.0.0.1\u0026#34;, \u0026#34;indexName\u0026#34; =\u0026gt; \u0026#34;test\u0026#34;, \u0026#34;level\u0026#34; =\u0026gt; \u0026#34;INFO\u0026#34;, \u0026#34;@timestamp\u0026#34; =\u0026gt; 2019-05-11T16:40:14.996Z, \u0026#34;facility\u0026#34; =\u0026gt; \u0026#34;logstash-gelf\u0026#34;, \u0026#34;className\u0026#34; =\u0026gt; \u0026#34;lewky.cn.Test\u0026#34;, \u0026#34;timestamp\u0026#34; =\u0026gt; \u0026#34;2019-05-12T00:40:14.877+0800\u0026#34;, \u0026#34;docId\u0026#34; =\u0026gt; 1, \u0026#34;host\u0026#34; =\u0026gt; \u0026#34;DESKTOP-S7HJJKD\u0026#34; } 而在我们的IDE控制台（我用的是Eclipse）里也可以看到输出了信息：\n1 {\u0026#34;logger\u0026#34;: \u0026#34;elk.test\u0026#34;, \u0026#34;level\u0026#34;: \u0026#34;INFO\u0026#34;, \u0026#34;msg\u0026#34;: \u0026#34;Hello world!\u0026#34;} 配置Kibana查看Elasticsearch的index数据 接下来就是最后一步了，通过Kibana来查看我们刚刚index到Elasticsearch里的数据。\n启动了Kibana后，在浏览器访问localhost:5601，进入界面后，操作如下：\nManagement -\u0026gt; Index Patterns 输入index的名字，我们这里填的是test；然后点击Next step 在Time Filter field name下方的下拉框里选择timestamp作为我们的一个排序字段，默认是desc，即递减排序 最后点击Create index pattern 现在已经配置好了Index pattern，我们就可以直接在左侧菜单栏里的Discover去查看对应的index里的数据了。如果不出意外，现在在Discover里已经看到刚刚被我们index进去的日志信息了。\n默认只会显示Time和_source两个字段的数据，Time就是排序字段，它的值和之前我们选择的那个timestamp一样。_source里则是所有字段的数据总和。\n可以根据需要，在显示字段的左侧把任意的字段add到右侧以显示出来。当你添加了新的字段之后，_source字段会自动消失。\n这就是最简单的一个ELK快速搭建例子，有兴趣的可以接着看后续的文章以了解更多和ELK相关的问题或知识。\n参考链接 ELK入门01—Elasticsearch安装 ELK入门02—Logstash+Log4j2+ES log4j2 + logstash 想问下ELK，不同版本都支持哪些jdk，在哪里查看。 logstash配置之自动重载配置文件 ET001 不可不掌握的 Logstash 使用技巧 ","permalink":"https://lewky.cn/posts/elk-1/","tags":["Elasticsearch","Logstash","Kibana"],"title":"ELK系列(1) - Elasticsearch + Logstash + Kibana + Log4j2快速入门与搭建用例"},{"categories":["三天两题"],"contents":"题目 1 2 3 4 5 6 7 8 public class Test { public static void main(final String[] args) { final int a = 10; final int b = 20; System.out.println(a + \u0026#39;+\u0026#39; + b + \u0026#39;=\u0026#39; + (a + b)); } } 乍一看，可能有的同学会觉得很简单，直接给出如下答案：\n1 10+20=30 其实这是道陷进题，很容易就看混了，正确的答案是：\n1 164 分析 为什么答案会是164？\n这是因为这里并不是字符串拼接，而是整型与字符类型的加法运算。\n用一对单引号'包括起来的是字符，用一对双引号\u0026quot;包括起来的是字符串。\n对于字符串来说，用+拼接起来的结果还是字符串。但这道题中，用+拼接起来的是整型和字符类型，就变成了单纯的加法运算。在加法运算中，数据类型会从低位自动转换成高位，因为高位转低位会有数据溢出导致丢失精度的风险。\n当整型与字符类型相加时，字符类型会转换成整型，也就是转换成对应的ASCII码值。于是乎，a + '+' + b + '=' + (a + b)就变成了10 + 43 + 20 + 61 + (10 + 20)，其运算结果就是164。\n题目变形 其一 1 2 3 4 5 6 7 8 public class Test { public static void main(final String[] args) { final int a = 10; final int b = 20; System.out.println(a + \u0026#34;+\u0026#34; + b + \u0026#34;=\u0026#34; + (a + b)); } } 这道题的答案就是10+20=30了。\n其二 1 2 3 4 5 6 7 public class Test { public static void main(final String[] args) { System.out.println(\u0026#39;A\u0026#39;); System.out.println((int)\u0026#39;A\u0026#39;); } } 这道题的答案是：\n1 2 A 65 如果我们想知道某个字符对应的ASCII码是多少，可以将其转换成整型，这个值就是其ASCII码值。\n","permalink":"https://lewky.cn/posts/a34ffc44.html/","tags":["Java","笔试面试算法题"],"title":"Java - 一道关于整型和字符类型相加的题目"},{"categories":["前端"],"contents":"问题 我在个人站点的左下角和右下角各自使用了如下代码来将页面滚动到顶部和底部：\n1 2 3 $(\u0026#34;body\u0026#34;).animate({scrollTop:0},800); $(\u0026#34;body\u0026#34;).animate({scrollTop:$(document).height()},800); 最近才忽然发现在Chrome浏览器下，上面的代码没有问题，而在Firefox下却是无效的。百度后才知道，原来这是因为这两个浏览器自身的问题导致的。\n对于Chrome而言，支持的是这种写法：\n1 $(\u0026#34;body\u0026#34;）.animate({\u0026#34;scrollTop\u0026#34;:top}); 而对于Firefox，则是支持如下写法：\n1 $(\u0026#34;html\u0026#34;).animate({\u0026#34;scrollTop\u0026#34;:top}); 之前就一直耳闻前端开发需要兼容不同浏览器，非常地麻烦，今天算是见识到了冰山一角。\n解决方法 既然这两个浏览器各自支持一种标签选择器，那么只要把两者统合起来即可实现兼容：\n1 $(\u0026#34;html,body\u0026#34;）.animate({\u0026#34;scrollTop\u0026#34;:top}); 最终，将我的代码改成如下形式便没问题了：\n1 2 3 $(\u0026#34;html,body\u0026#34;).animate({scrollTop:0},800); $(\u0026#34;html,body\u0026#34;).animate({scrollTop:$(document).height()},800); 参考链接 jQuery中animate()方法以及$(\u0026lsquo;body\u0026rsquo;).animate({\u0026ldquo;scrollTop\u0026rdquo;:top})不被Firefox支持问题的解决 ","permalink":"https://lewky.cn/posts/fb7443fc.html/","tags":["前端","jQuery"],"title":"$(\"body\").animate({\"scrollTop\":top})无效的问题"},{"categories":["三天两题"],"contents":"题目 有这样一道有趣的题目：\n1 2 3 4 5 6 7 8 final int[] test = new int[]{1,2,3,4}; final Integer[] test2 = new Integer[]{1,2,3,4}; final List list1 = Arrays.asList(test); final List list2 = Arrays.asList(test2); final List list3 = Arrays.asList(1,2,3,4); System.out.println(list1.size()); System.out.println(list2.size()); System.out.println(list3.size()); 对于上边的3个size()，输出的结果如下：\n1 2 3 1 4 4 这道题考察的是Arrays.asList()这个api以及泛型的知识点，工作时用到该api的情景也挺多的。下面分析下，为什么是这个答案。\n分析 对于list1，为什么size是1？ 这是因为Arrays.asList如果传入的数组是基础数据类型的数组时，会将整个数组作为一个对象来构建ArrayList，所以size是1。在源码实现中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public static \u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; asList(T... a) { return new ArrayList\u0026lt;\u0026gt;(a); } private static class ArrayList\u0026lt;E\u0026gt; extends AbstractList\u0026lt;E\u0026gt; implements RandomAccess, java.io.Serializable { private static final long serialVersionUID = -2764017481108945198L; private final E[] a; ArrayList(E[] array) { a = Objects.requireNonNull(array); } @Override public int size() { return a.length; } …… } 可以看到，Arrays.asList的形参是可变参数T... a，等同于一个数组参数T[]。这里的T是泛型。在调用该api时，会直接用传入的参数来构建一个ArrayList。\n这个ArrayList\u0026lt;E\u0026gt;是Arrays的静态内部类，同样使用了泛型，而泛型是不支持基础数据类型的。\n当传入的参数是一个基础数据类型的数组时，就把整个数组对象解析为泛型T；如果传入的参数是一个对象类型的数组，就把数组中的对象类型解析为泛型T。如下：\n1 2 3 4 5 6 传入的参数是int[]时： int[] -\u0026gt; T[]中的T，此时Arrays.asList()返回的是一个size为1的ArrayList\u0026lt;int[]\u0026gt; 传入的参数是Integer[]时： Integer[] -\u0026gt; T[]，此时Arrays.asList()返回的是一个ArrayList\u0026lt;Integer\u0026gt;，其size的值与Integer[]的length一样 因此，题目里的list1和list2的size会不一样。那为什么直接传入1,2,3,4这四个int参数所得到的结果又是4呢？\n这是因为当直接传入参数为基础数据类型时，由于方法形参是泛型数组，于是就通过自动装箱把基础数据类型的参数包装为对应的包装类。比如传入的是int，就自动装箱成Integer，这样就能被泛型所接收了。\n也就是说，虽然传入参数是1,2,3,4，其实会通过自动装箱变成一个Integer[]参数，然后传递给T[]，最后返回的就是一个ArrayList\u0026lt;Integer\u0026gt;。\n下面是一个可以证明该过程的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 public static void main(final String[] args) { final int[] array1 = new int[]{1,2,3,4}; final Integer[] array2 = new Integer[]{1,2,3,4}; test(array1); test(array2); test(1,2,3,4); } public static \u0026lt;T\u0026gt; void test(final T... a) { System.out.println(a.length); } 其结果如下：\n1 2 3 1 4 4 Arrays.asList的其他知识点 由于Arrays.asList返回的是Arrays的静态内部类ArrayList，这个ArrayList并没有重写add和remove方法的。也就是说，这个ArrayList一旦new出来了，其大小就固定下来了，不能再调用add或者remove方法了，否则就会报错如下：\n1 2 3 Exception in thread \u0026#34;main\u0026#34; java.lang.UnsupportedOperationException at java.util.AbstractList.add(AbstractList.java:148) at java.util.AbstractList.add(AbstractList.java:108) 虽然不能调用add或者remove，但可以调用set、contains、sort等其他的方法，也可以进行遍历。\n如果我们确实需要调用add或者remove方法，可以有以下方法：\n方法一 遍历Arrays.asList返回的集合，然后一个个添加到我们常用的集合里，比如java.util.ArrayList。\n方法二 使用list.addAll(Arrays.asList(a))，直接把Arrays.asList返回的集合给整个添加到新的集合里。\n方法三 可以直接通过new ArrayList\u0026lt;\u0026gt;(Arrays.asList(a))的方法来构建一个有着完善功能的集合。\n方法四 使用Collections.addAll()来替代Arrays.asList()，这样得到的就是一个有着完善功能的集合。\n泛型(Generics)的知识点 泛型的定义：在程序中我们将一个对象放入集合中，但是集合不会记住对象的类型，当我们在次使用对象的时候，对象变为Object类型，而程序中还是原来的类型，我们必须要自己转换其类型，为了解决这个问题，则提出泛型。\n泛型要求包容的是对象类型，而八种基础数据类型不属于对象类型，但是它们有对应的封装类/包装类。并且在调用函数时，会根据参数类型来进行自动装箱或者自动拆箱(Autoboxing and unboxing)。对自动装箱/拆箱有兴趣的可以参考下边的链接。\n参考链接 将数组转换成集合Arrays.asList，不可进行add和remove操作的原因 为什么泛型类的类型不能是基本数据类型 Java 自动装箱与拆箱(Autoboxing and unboxing) ","permalink":"https://lewky.cn/posts/507b2cbc.html/","tags":["Java","笔试面试算法题"],"title":"Java - 一道关于Arrays.asList的题目"},{"categories":["Java"],"contents":"场景 出于业务考虑，将多个字符串拼接起来时，使用的分隔符是;,;。如果要将这样一个拼接来的字符串分割成原本的多个字符串时，就需要使用到jdk自带的split()方法。不过因为公司的编程规范，改为使用了Apache工具类的StringUtils.split()。\n之后就发现，当被拼接的字符串里含有;或,时，就会出现分割不正确的问题。\n具体例子 下面的代码，使用了上述的两种split方法，猜猜结果是什么。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Test { public static void main(final String[] args) { final String str = \u0026#34;老肥,老肥;是个,逗比\u0026#34;; final String seperator = \u0026#34;;,;\u0026#34;; //Apache工具类的split方法 final String[] result1 = StringUtils.split(str, seperator); for (final String string : result1) { System.out.println(string); } System.out.println(\u0026#34;############分割线###########\u0026#34;); //jdk的split方法 final String[] result2 = str.split(seperator); for (final String string : result2) { System.out.println(string); } } } 分割的结果如下：\n1 2 3 4 5 6 老肥 老肥 是个 逗比 ############分割线########### 老肥,老肥;是个,逗比 StringUtils.split()和string.split()的区别 StringUtils.split()是把分隔符拆成一个个单独的字符，再用这些字符去把字符串进行分割的。只要匹配到了分隔符中的任意一个字符，就会进行分割。而string.split()是把分隔符作为一个整体来对字符串进行分割。\n比如分隔符是;,;，那么在用StringUtils.split()时，只要被分割的字符串里遇到;或,，就会被分割。而在用string.split()时，必须被分割的字符串里遇到;,;时才会被分割。\n另外string.split()的分隔符参数其实是正则表达式，而StringUtils.split()的分隔符参数就只是个普通的字符串。此外，StringUtils.split()是null-safe的，已经帮你判空了，这也是公司规范要我们使用Apache工具类的原因。不过由于这里的业务要求，最终还是选择使用string.split()。\n最后附上StringUtils.split()的部分底层实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 //standard case while (i \u0026lt; len) { if (separatorChars.indexOf(str.charAt(i)) \u0026gt;= 0) { if (match || preserveAllTokens) { lastMatch = true; if (sizePlus1++ == max) { i = len; lastMatch = false; } list.add(str.substring(start, i)); match = false; } start = ++i; continue; } lastMatch = false; match = true; i++; } ","permalink":"https://lewky.cn/posts/44d23f55.html/","tags":["Java","split"],"title":"StringUtils.split()和string.split()的区别"},{"categories":["数据库"],"contents":"前言 今天在查看项目代码时发现有这样一个逻辑：在查询数据库时通过代码去拼接一个SQL，这个SQL的某个字段的别名是由多个变量名拼接而成的，于是在拼接该别名时特地限制了其长度为30，如果超过30就只截取前30个字符来作为列别名。\n一时间很好奇为什么要限制列别名的长度，查阅过资料才明白，原来数据库的名字、表名、表别名、列名、列别名和函数名等，这些都属于标识符，不同数据库对于标识符会限定各种的长度最大值。\n关键字和标识符 关键字：Key Words，就是那些在 SQL 语言里有固定含义的单词。比如很常用的select、update、delete等。\n标识符：Identifiers，就是一个用于标识的名字，比如数据库名、表名、表别名、列名、列别名和函数名等。 SQL 标识符和关键字必须以一个字母开头 （a-z 以及带可区别标记的字母以及非拉丁字母 ）或下划线开头 （_）开头。标识符和关键字里随后的字符可以是字母，数字（0-9）， 或者下划线，但 SQL 标准不会定义包含数字或者以下划线开头或结尾的关键字。\n不同数据库的标识符的最大长度 数据库类型 表名 字段名 PostgreSQL 63个字符 63个字符 SQL SERVER 128个字符，临时表116个字符 128个字符 Oracle 30个字符 30个字符 MySQL 64个字符 64个字符 Access 64个字符 64个字符 DB2 128个字符 128个字符 PostgreSQL中的标识符 PostgreSQL比较特殊，唯独它的标识符最大长度是63个字符，官方文档中是这样描述的：\nThe system uses no more than NAMEDATALEN-1 bytes of an identifier; longer names can be written in commands, but they will be truncated. By default, NAMEDATALEN is 64 so the maximum identifier length is 63 bytes. If this limit is problematic, it can be raised by changing the NAMEDATALEN constant in src/include/pg_config_manual.h.\nKey words and unquoted identifiers are case insensitive.\n简单来说，PostgreSQL使用NAMEDATALEN - 1的值来限定标识符的最大长度，NAMEDATALEN默认是64，可以在PosrgreSQL的安装目录下的include/pg_config_manual.h去修改其值，在该shell文件中其注释如下：\n1 2 3 4 5 6 7 8 /* * Maximum length for identifiers (e.g. table names, column names, * function names). Names actually are limited to one less byte than this, * because the length must include a trailing zero byte. * * Changing this requires an initdb. */ #define NAMEDATALEN 64 PostgreSQL关于标识符简单的例子 如果我们把标识符命名超过了最大长度，那么会被自动截取掉超出的部分，只留下最大长度的标识符。\n1 alter table tb_student add \u0026#34;哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈\u0026#34; varchar(400); 如上SQL，由于数据库使用的是UTF-8编码，一个中文对应3个字符，也就是说，标识符最多只能有21个中文。上述SQL执行成功后，tb_student多出来一个新的字段哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈，正好只有21个字符，多出来的字符被丢弃了。\n另外，标识符是不区分大小写的，但是如果用双引号把标识符包括起来，这时候就会区分大小写。\n参考链接 PostgreSQL官方文档 PostgreSQL中文文档 各个数据库表名和字段名长度限制 ","permalink":"https://lewky.cn/posts/d68d7e3a.html/","tags":["数据库"],"title":"数据库的标识符可以有多长"},{"categories":["PostgreSQL"],"contents":"前言 like、not like在SQL中用于模糊查询，%表示任意个字符，_表示单个任意字符，如果需要在模糊查询中查询这两个通配符，需要用ESCAPE进行转义，如下：\n1 select * from table where name like \u0026#39;张/_小%\u0026#39; escape \u0026#39;/\u0026#39;; 这里表明/作为转义符，所以就可以在模糊查询中将通配符作为普通字符来搜索。另外，因为左模糊查询效率低下，一般不推荐在应用中去使用。\n除了以上通用的like和not like，在PostgreSQL中还有特殊的操作符用于模糊查询。\nilike和not ilike ilike表示在模糊匹配字符串时不区分大小写，i即是ignore的意思。\nnot ilike表示不模糊匹配字符串且不区分大小写。\n~和~*，!~和!~* ~表示匹配正则表达式，且区分大小写。\n~*表示匹配正则表达式，且不区分大小写。\n可以通过这两个操作符来实现like和ilike一样的效果，如下：\n1 2 3 4 5 6 7 1.匹配以“张”开头的字符串 select * from table where name ~ \u0026#39;^张\u0026#39;; 2.匹配以“小”结尾的字符串 select * from table where name ~ \u0026#39;小$\u0026#39;; 其实这里的^和$就是正则表达式里的用法。 !~是~的否定用法，表示不匹配正则表达式，且区分大小写。\n!~*是~*的否定用法，表示不匹配正则表达式，且不区分大小写。\n~~和~~*，!~~和!~~* ~~等效于like，~~*等效于ilike。\n!~~等效于not like，!~~*等效于not ilike。\n参考链接 postgresql数据库中~和like和ilike的区别 postgreSQL sql语句中的~~符号是什么意思 ","permalink":"https://lewky.cn/posts/8fd6368.html/","tags":["PostgreSQL"],"title":"PostgreSQL - 模糊查询"},{"categories":["前端"],"contents":"前言 当安装了较多模块后，node_modules目录下的文件会很多，直接删除整个目录会很慢，下面介绍些快速删除node_modules目录的方法。\n方法一：使用rimraf模块的命令 在全局安装rimraf模块，然后通过其命令来快速删除node_modules目录：\n1 2 npm install rimraf -g rimraf node_modules 方法二：使用命令来删除目录 Windows下使用rmdir命令 首先在cmd窗口中进入到node_modules文件夹所在的路径，接着执行命令：\n1 rmdir /s/q node_modules Linux下使用rm命令 1 rm -f /node_modules 参考链接 删除node_modules文件夹 ","permalink":"https://lewky.cn/posts/e873a12.html/","tags":["前端","node_modules"],"title":"快速删除node_modules文件夹"},{"categories":["前端"],"contents":"前言 由于高版本的node.js导致gulp执行build命令失败，我需要在Windows下卸载掉已有的node.js并安装一个多版本管理工具nvm-windows，方便切换不同版本的node.js。\nnvm是Linux下常用的一个node.js多版本管理工具，但是nvm不能在Windows下使用，在GitHub上有个项目叫nvm-windows，可以让我们在Windows下对node.js进行多版本管理。\nnvm-windows的下载地址：https://github.com/coreybutler/nvm-windows/releases\n根据官方说明：\n1 2 3 It comes with an installer (and uninstaller), because getting it should be easy. Please note, you need to uninstall any existing versions of node.js before installing NVM for Windows. Also delete any existing nodejs installation directories (e.g., \u0026#34;C:\\Program Files\\nodejs\u0026#34;) that might remain. NVM\u0026#39;s generated symlink will not overwrite an existing (even empty) installation directory. You should also delete the existing npm install location (e.g. \u0026#34;C:\\Users\u0026lt;user\u0026gt;\\AppData\\Roaming\\npm\u0026#34;) so that the nvm install location will be correctly used instead. After install, reinstalling global utilities (e.g. gulp) will have to be done for each installed version of node: 在安装nvm-windows前，如果以前安装过node，需要先卸载，并且要把目录清理干净。\n在Windows下完全卸载已安装的node.js 从卸载程序卸载程序和功能，也可以直接右键node.js的安装包并选择卸载。 重新启动（或者重新启动任务管理器杀死所有与节点相关的进程）。 从下列的目录中找到相关的内容并删除掉： C:\\Program Files (x86)\\nodejs C:\\Program Files\\nodejs C:\\Users\\{User}\\AppData\\Roaming\\npm（或%appdata%\\npm） C:\\Users\\{User}\\AppData\\Roaming\\npm-cache（或%appdata%\\npm-cache） 检查%PATH%环境变量以确保没有引用Nodejs或npm存在。 重新启动电脑。 安装nvm-windows并使用 到GitHub的项目下载地址，选择下载nvm-setup.zip，解压后双击使用安装程序即可。\n注意不要改变安装时默认安装的系统软连接路径NVM_SYMLINK的值，否则会使用不了nodejs\n查看已安装的nodejs版本 1 nvm list 如果是第一次安装，使用该命令结果如下：\n1 2 3 C:\\Users\\Lewis\u0026gt;nvm list No installations recognized. 查看可安装的nodejs版本 1 nvm list available 输入该命令结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 C:\\Users\\Lewis\u0026gt;nvm list available | CURRENT | LTS | OLD STABLE | OLD UNSTABLE | |--------------|--------------|--------------|--------------| | 11.10.0 | 10.15.1 | 0.12.18 | 0.11.16 | | 11.9.0 | 10.15.0 | 0.12.17 | 0.11.15 | | 11.8.0 | 10.14.2 | 0.12.16 | 0.11.14 | | 11.7.0 | 10.14.1 | 0.12.15 | 0.11.13 | | 11.6.0 | 10.14.0 | 0.12.14 | 0.11.12 | | 11.5.0 | 10.13.0 | 0.12.13 | 0.11.11 | | 11.4.0 | 8.15.0 | 0.12.12 | 0.11.10 | | 11.3.0 | 8.14.1 | 0.12.11 | 0.11.9 | | 11.2.0 | 8.14.0 | 0.12.10 | 0.11.8 | | 11.1.0 | 8.13.0 | 0.12.9 | 0.11.7 | | 11.0.0 | 8.12.0 | 0.12.8 | 0.11.6 | | 10.12.0 | 8.11.4 | 0.12.7 | 0.11.5 | | 10.11.0 | 8.11.3 | 0.12.6 | 0.11.4 | | 10.10.0 | 8.11.2 | 0.12.5 | 0.11.3 | | 10.9.0 | 8.11.1 | 0.12.4 | 0.11.2 | | 10.8.0 | 8.11.0 | 0.12.3 | 0.11.1 | | 10.7.0 | 8.10.0 | 0.12.2 | 0.11.0 | | 10.6.0 | 8.9.4 | 0.12.1 | 0.9.12 | | 10.5.0 | 8.9.3 | 0.12.0 | 0.9.11 | | 10.4.1 | 8.9.2 | 0.10.48 | 0.9.10 | This is a partial list. For a complete list, visit https://nodejs.org/download/release 安装指定版本的nodejs 1 nvm install 8.11.2 64-bit 安装成功后可以查询看看已安装的nodejs版本：\n1 2 3 C:\\Users\\Lewis\u0026gt;nvm list 8.11.2 有需要的话，可以继续安装其他版本的nodejs。\n使用指定版本的nodejs 1 nvm use 8.11.2 安装成功后可以验证下版本：\n1 2 3 4 5 6 C:\\Users\\Lewis\u0026gt;nvm list * 8.11.2 (Currently using 64-bit executable) C:\\Users\\Lewis\u0026gt;node -v v8.11.2 删除指定版本的nodejs 1 nvm uninstall 8.11.2 配置淘宝镜像 nvm默认的下载地址是 http://nodejs.org/dist/ ，速度很慢，可以改用淘宝的镜像，打开nvm安装路径下的settings.txt，添加如下内容：\n1 2 node_mirror: https://npm.taobao.org/mirrors/node/ npm_mirror: https://npm.taobao.org/mirrors/npm/ 然后打开C盘你的用户目录下的.npmrc文件，如果没有该文件可以自己创建一个，然后添加或修改如下内容：\n1 2 3 registry=https://registry.npm.taobao.org/ cache=D:\\software\\nvm\\npm-cache prefix=D:\\software\\nvm\\npm 这里的cache和prefix请自己填写想要存放的路径。\n其他的npm镜像源 有些模块用淘宝镜像源不一定能下载下来，可以换成其他的镜像源：\n1 npm config set registry https://registry.npmjs.org 如果不想每次都重新设置镜像源，也可以使用nrm来管理镜像源。\n添加环境变量 做完上述步骤后已经可以直接在cmd中使用npm命令来安装模块，此时可以将%NVM_HOME%\\npm添加到系统的Path变量中，方便在cmd中使用nvm安装目录下的npm全局安装的模块命令。\n参考链接 Window下完全卸载删除Nodejs Windows上node.js的多版本管理工具 NVM的安装和NPM下载速度慢的问题 ","permalink":"https://lewky.cn/posts/1908545a.html/","tags":["前端","node.js"],"title":"Windows下完全卸载node.js并安装node.js的多版本管理工具nvm-windows"},{"categories":["前端"],"contents":"问题与分析 在执行gulp build报错如下：\n1 2 3 4 5 6 D:\\coding\\Resume\\Resumes\u0026gt;gulp build gulp build[5628]: src\\node_contextify.cc:628: Assertion `args[1]-\u0026gt;IsString()\u0026#39; failed. D:\\coding\\Resume\\Resumes\u0026gt;gulp -v [22:00:13] CLI version 2.0.1 [22:00:13] Local version 3.9.1 网上有很多人也遇到这个问题，到GitHub上的nodejs项目的issue里也可以找到该问题，地址在这。\n根据查阅的资料来看，这个问题是由于node升级到10.0.0后出现的，回退版本即可，按照GitHub上的答案选择使用8.11.2版本的node。\n解决方法 不要使用改成10.0.0及以上版本的node，可以选择使用8.11.2版本的node。\n如果确实有需要去使用高版本的node，可以选择nodejs的多版本管理工具，方便切换不同版本的node。这里推荐一个Windows下可以使用的node.js的多版本管理工具nvm-windows，可以参考下这篇文章。\n参考链接 gulp 报错 Github issue #20325 ","permalink":"https://lewky.cn/posts/9af9bb6b.html/","tags":["前端","gulp","node.js"],"title":"执行gulp build报错"},{"categories":["工作记录"],"contents":"常用的快捷键 ctrl + shift + r 查找工作空间内的文件，不包括Jar包内的文件\nctrl + shift + t 查找工作空间内的文件，包括Jar包内的文件\nctrl + o 查看当前类的所有方法\nctrl + e 快速切换编辑器，在打开了非常多的文件时会很便利\nctrl + / 单行注释或多行注释或取消注释\nctrl + t 查找一个类的继承关系树\nctrl + d 删除光标所在行\nctrl + space 代码提示，和输入法快捷键冲突时也可以用alt + /\nctrl + shift + f 格式化代码\nctrl + k 快速跳转到下一个相同的被选中字符，在查找相同的字符串时会很方便\nctrl + shift + k 快速跳转到上一个相同的被选中字符\nshift + enter 在光标所在行的下一行创建一行空白行\nctrl + shift + enter 在光标所在行的上一行创建一行空白行\nalt + ← 跳转到上一步操作\nalt + → 跳转到下一步操作\nalt + ↑ 将光标所在的那一行向上挪动一行\nalt + ↓ 将光标所在的那一行向下挪动一行\nAccess restriction: The type \u0026lsquo;JPEGCodec\u0026rsquo; is not API 导入项目时Eclipse报错如下：\n1 Access restriction: The type \u0026#39;JPEGCodec\u0026#39; is not API (restriction on required library \u0026#39;C:\\Program Files\\Java\\jdk1.8.0_191\\jre\\lib\\rt.jar\u0026#39;) 第一次遇到这种错误，百度了下，原来是因为Eclipse默认把访问受限的API设置成了Error级别，所以才会编译报错。\n解决方法一（推荐） 直接将项目的JRE给remove掉，然后再重新将JRE添加到项目中，操作如下：\n右键项目，选择Properties -\u0026gt; Java Build Path -\u0026gt; Libraries -\u0026gt; 选中JRE System Library [jdkxxxx] -\u0026gt; 选择Remove 接着选择Add Librariy...，重新加入JRE 解决方法二 修改Eclipse中关于访问受限的API的编译级别：\nWindow -\u0026gt; Preferences -\u0026gt; Java -\u0026gt; Compiler -\u0026gt; Errors/Warnings，选择Deprecated and restricted API，将其中的Forbidden reference(access rules)的级别选为Warning。\n缺少servlet-api.jar包 在Eclipse中缺省servlet-api.jar包，由于servlet-api.jar以及jsp-api.jar这两个jar包含在Apache Tomcat中，所以提示这两个包缺省而出现错误的情况下，执行Build Path -\u0026gt; Configure Build path -\u0026gt; Libraries -\u0026gt; Add Library -\u0026gt; server Runtime就可以了。\n怎么设置在启动时提示选择工作空间 Window -\u0026gt; Preferences -\u0026gt; General -\u0026gt; Startup and Shutdown -\u0026gt; Workspaces 勾选`Prompt for workspace on startup 如何在新的工作空间使用原来的配置(编码、视图、快捷键、插件设置等) Eclipse如果更换一个新的工作空间，需要重新设置视图、配置等一系列东西，算是想到麻烦的一件事情，其实我们完全可以将旧的工作空间里的配置拷贝到新的工作空间里，这样就可以省去重新配置的麻烦了~ 具体操作如下：\n在${workspace(你电脑里原本的工作空间目录)}/.metadata/.plugins里有这样两个文件夹：org.eclipse.core.runtime和org.eclipse.ui.workbench，将新的工作空间里的同名文件夹删了，再将这两个文件夹复制到新的工作空间就行了！\norg.eclipse.core.runtime：保存着Eclipse的用户配置，包括视图、编码、各种插件的配置(window下的preference里边的插件配置)等\norg.eclipse.ui.workbench：保持着ui上的配置，包括上方的快捷工具栏和下方的view窗口等\n如果不知道自己正在使用的工作空间在哪个目录下，请点击Eclipse左上角的File→switch workspace→other，显示的就是当前工作空间的目录。另外，在这里有个copy setting，可以选择转换到新的工作空间时拷贝原本的配置，但这里拷贝的其实只是org.eclipse.ui.workbench，缺少了org.eclipse.core.runtime，所以这种方法会丢失部分配置。\n另外不要没事就随便转换工作空间，Eclipse容易崩溃_(:3」∠)_\n接口实现类里使用@Override注解报错 @Override注解用来检测子类对父类或接口的方法的重写是否正确，但有一次我在Eclipse里对接口的实现类里使用@Override注解却报错，不过在父类的子类里使用该注解却是正常的。\n百度了下才知道原来这是jdk1.5时的一个bug，在1.6时已经被修复；那么问题来了，我使用的jdk是1.8，为什么会报这个错误？明明之前也在接口的实现类里用过该注解，却没问题。由于Eclipse经常抽风，我怀疑是Eclipse的问题，经过排查确实如此，该项目使用的jdk版本不知道为什么变成了jdk1.5，导致出现了注解报错的问题。\n解决方法 右键该项目，选择Properties，将Java Compiler和Java Facets里的jdk版本从1.5改为更高的版本，再刷新下项目重新编译就没问题了。`\n修改默认编码为utf-8 一共需要设置三个地方：\nWindow -\u0026gt; Preferences -\u0026gt; General -\u0026gt; Content Type -\u0026gt; Text -\u0026gt; JSP，在 最下面设置为UTF-8 Window -\u0026gt; Preferences -\u0026gt; General -\u0026gt; Workspace，将Text file encoding设置为UTF-8 Window -\u0026gt; Preferences -\u0026gt; Web -\u0026gt; JSP Files，设置为ISO 10646/Unicode(UTF-8) 修改properties文件的编码 Eclipse的properties文件是默认ISO-8859-1编码的，如果在properties里输入中文会导致乱码，此时需要修改其编码为utf-8，具体步骤如下：\nWindow -\u0026gt; Preferences -\u0026gt; General -\u0026gt; Content Types -\u0026gt; Text，然后单击Java Properties Files，选定下方的*.properties(locked)，接着将最下方的ISO-8859-1改为utf-8，然后点击旁边的 Update，最后点击OK。\n修改web项目的web module version 有时候我们想改变web项目的web module version，比如说原本是2.4版本，我们想改成3.0版本，通过右键项目名 -\u0026gt; Properties -\u0026gt; Project Facets，选中Dynamic Web Module后边的版本，将2.4改成3.0\n这时候会报错误：Cannot change version of project facet Dynamic Web Module to 3.0.\n而且这时候改动web.xml的文件头从2.4改成3.0版本的文件头也会报错。\n解决办法 这时候我们需要找到该项目的目录，进入.setting文件夹，打开org.eclipse.wst.common.project.facet.core.xml 我们可以发现在这个xml文件中，有这样一个标签： 1 \u0026lt;installed facet=\u0026#34;jst.web\u0026#34; version=\u0026#34;2.4\u0026#34;/\u0026gt; 将这里的version改成你想要的版本，比如改成3.0 保存该文件的改动，接着刷新Eclipse中的该项目(左键选中项目名，按F5刷新项目) 接着再去Properties -\u0026gt; Project Facets ， 将Dynamic Web Module改为3.0；然后将web.xml的文件头改为对应3.0版本的文件头；此时会发现可以修改成功而不会报错。 Update Project后jdk版本变成1.5 在Eclipse里对一个Maven项目进行Update Project（快捷键是 Alt+F5），原本jdk为1.8的项目忽然就变成了1.5，于是就报了一些错误。\n这跟Maven默认的jdk版本有关系，Maven项目如果不指定编译的jdk版本，就会默认为jdk1.5。查了下项目的pom文件，里边并没有指定编译的jdk版本，而Maven的配置文件settings.xml里也没有指明jdk版本，所以当Update Project后，这个Maven项目就会自动变成jdk1.5了。\n有两种解决方法，一种是针对某个Maven项目而言，直接在pom文件中指明jdk版本；一种是全局设置，为所有Maven项目指明jdk版本。\n方法一：在pom文件中指明jdk版本 在项目的pom.xml中的build节点里使用maven的编译插件来指定jdk版本，项目中通常使用这种方法来指定，因为比较灵活，可以随意指定版本，修改保存后即可生效。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-compiler-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1\u0026lt;/version\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;encoding\u0026gt;UTF-8\u0026lt;/encoding\u0026gt; \u0026lt;source\u0026gt;1.8\u0026lt;/source\u0026gt; \u0026lt;target\u0026gt;1.8\u0026lt;/target\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; 方法二：修改settings.xml文件 找到Maven的安装路径，打开conf\\settings.xml，找到profiles节点，在该节点下添加一个profile节点：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;profile\u0026gt; \u0026lt;id\u0026gt;jdk-1.8\u0026lt;/id\u0026gt; \u0026lt;activation\u0026gt; \u0026lt;jdk\u0026gt;1.8\u0026lt;/jdk\u0026gt; \u0026lt;activeByDefault\u0026gt;true\u0026lt;/activeByDefault\u0026gt; \u0026lt;/activation\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;maven.compiler.compilerVersion\u0026gt;1.8\u0026lt;/maven.compiler.compilerVersion\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;/profile\u0026gt; 使用这种方法的好处是所有Maven项目都会按照这里的jdk版本来编译，当然如果在pom文件里也指定了jdk版本，则以pom里的为准。这种全局修改的方法必须要重启Eclipse才有效果。\n个人建议就算是修改了全局配置，也要在每个Maven项目里指明jdk版本，这是种良好的规范，利于别人理解。\n安装了jd-eclipse插件后依然无法反编译类文件 Eclipse在安装了jd-eclipse插件后依然无法反编译类文件，这个问题是因为没有修改默认的类文件查看器。需要修改默认的类文件查看器为jd-eclipse：\nWindow -\u0026gt; Preference -\u0026gt; General -\u0026gt; Editors -\u0026gt; File Associations 选中*.class，将Class File Editor设置为默认(Default) 选中*.class without source，将Class File Editor设置为默认(Default)；如果这一步操作只有Class File Viewer，则需要点击Add把Class File Editor添加进来并设置为默认(Default) 新版本的jd-eclipse的类文件查看器名字可能叫做JD Class File Viewer(总之，Class File Viewer是Eclipse自带的类文件查看器，安装插件后会出现新的类文件查看器)\n接着重启Eclipse后就可以正常地反编译类文件了，如果缺少上述的第三步操作，会有比较大的可能依然无法反编译类文件。\n找不到MapStruct生成的mapper实现类 Eclipse本身不支持MapStruct，除了需要安装较新版本的m2e插件，还要另外安装插件m2e-apt，该插件可以在Eclipse的Market里搜到。\n接着在pom文件里添加：\n1 2 3 \u0026lt;properties\u0026gt; \u0026lt;m2e.apt.activation\u0026gt;jdt_apt\u0026lt;/m2e.apt.activation\u0026gt; \u0026lt;/properties\u0026gt; 然后maven update一下项目，重新编译后会在target目录下出现两个文件目录，里面存放的是MapStruct的生成类。\n如果这时候还没效果，要手动打开apt的功能。邮件项目，选择Properties -\u0026gt; Maven -\u0026gt; Annotation Processing -\u0026gt; 勾选Enable project specific settings -\u0026gt; 选择第一个选项Automatically config JDT APT -\u0026gt; Apply and Close\n弹窗提示code recommenders cannot download its model repository index 原因是该插件的model地址http://download.eclipse.org/recommenders/models/oxygen/已经被移除了，且很久没有更新了，最新版的Eclipse里已经把该地址移除了，旧版本的需要自行移除：\nWindow -\u0026gt; Preferences -\u0026gt; Code Recommenders -\u0026gt; Models -\u0026gt; 选中这里面的地址，然后点击Remove即可。\nEclipse无法搜索到本地仓库的jar包 某次忽然发现无法在Eclipse中搜索到刚刚install好的jar包，来回折腾了好久也无法解决。百度后才知道原因，其实每次打开Eclipse时都会自动更新index索引，可能是出了某种未知的问题，自动更新index失败了，由于index缺失导致无法定位到本地install的新jar包。所以我们需要在Eclipse里手动更新下maven的index索引。\n解决方法如下：\n打开Eclipse的Maven仓库视图：Window -\u0026gt; Show View -\u0026gt; Other... -\u0026gt; Maven Repositories 找到你的本地仓库并重建索引：Local Repositories -\u0026gt; Local Repository -\u0026gt; 右键，选择Rebuild Index 更新完索引后就可以搜索到本地库里最新的jar包了 如果想搜索远程库的最新依赖(jar包)，操作类似：\n在Maven仓库视图里：Global Repositories -\u0026gt; 选定某个远程库 -\u0026gt; 右键，选择Update Index 更新完索引后就可以搜索到远程库里最新的jar包了 Could not find or load main class 在Eclipse里对一个SpringBoot项目选择Run As -\u0026gt; Maven clean后，通过启动类启动该项目时报错如下：\n1 Error: Could not find or load main class 解决方法是clean该项目并重新编译，再次启动时选择Run As -\u0026gt; Java Application，启动成功。\n还有另一个会触发该错误的方式：\n在Eclipse里启动SpringBoot项目的时候，右键启动类，选择Run As，此时手误点成了Run on Server，之后就一直启动报错如下：\n1 Error: Could not find or load main class 解决方法同上。\n参考链接 Eclipse快捷键 10个最有用的快捷键 解决办法：Access restriction: The type JPEGImageEncoder is not accessible due to restriction 缺少servlet-api.jar包 怎样设置Eclipse在启动时提示选择工作空间 maven 修改默认的JDK版本 Maven管理项目的时候 Update Project后jre变成1.5 安装jadClipse插件后,还是不能反编译.class mapstruct在eclipse生成不了mapper的实现类的问题 eclipse 报错 code recommenders cannot download its model repository index-已解决 在eclipse的maven插件中搜寻本地仓库中的jar搜索不到的解决方案 ","permalink":"https://lewky.cn/posts/eclipse-issues/","tags":["Eclipse"],"title":"Eclipse问题汇总"},{"categories":["MySQL"],"contents":"下载 MySQL8.0.13-64位下载地址\n在下载页面的底部，有三种安装包，第一种是MySQL的安装程序，下载完点击安装即可。 第二种是普通的压缩版，体积较小。 第三种是自带debug和测试的压缩版，体积较大。这种压缩包在网上暂时没有找到对应的安装文档说明，所以建议下载第二种压缩包，也就是普通版本的MySQL压缩包。\n配置环境变量 新建环境变量如下：\n变量名：MYSQL_HOME 变量值：D:\\software\\mysql-8.0.13-winx64（这里填写MySQL的安装路径） 在path变量的变量值末尾加上：;%MYSQL_HOME%\\bin 如果是win10那种将一个变量的变量值分成一行行来填写的，则不需要加上英文分号。\n生成data文件 打开cmd窗口，切换到%MYSQL_HOME%/bin下，输入命令：\n1 mysqld --initialize-insecure --user=mysql 要注意，这里必须是在bin目录下执行安装命令才行，否则后续启动服务会报错找不动系统文件。如果报错缺少权限则需要以管理员身份运行。\n接着等待命令执行完毕。这里需要注意的是，如果不是下载的普通版本的压缩包(体积较小那个)，会提示你找不到mysqld命令。\n启动MySQL服务 输入命令：\n1 net start mysql 如果执行报错如下：\n1 2 3 4 D:\\software\\mysql-8.0.13-winx64\u0026gt;net start mysql 服务名无效。 请键入 NET HELPMSG 2185 以获得更多的帮助。 需要先执行以下命令：\n1 mysqld -install 此时得到执行结果如下：\n1 2 D:\\software\\mysql-8.0.13-winx64\u0026gt;mysqld -install Service successfully installed. 接着再次启动MySQL服务，得以成功：\n1 2 3 D:\\software\\mysql-8.0.13-winx64\u0026gt;net start mysql MySQL 服务正在启动 .... MySQL 服务已经启动成功。 登录MySQL 执行命令：\n1 mysql -u root -p 此时会提示输入密码，由于初次登录MySQL，无需输入密码，所以直接回车即可，登录成功结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 D:\\software\\mysql-8.0.13-winx64\u0026gt;mysql -u root -p Enter password: Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 8 Server version: 8.0.13 MySQL Community Server - GPL Copyright (c) 2000, 2018, Oracle and/or its affiliates. All rights reserved. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt; 查询用户密码 执行命令如下：\n1 select host,user,authentication_string from mysql.user; 结果如下：\n1 2 3 4 5 6 7 8 9 10 11 12 mysql\u0026gt; select host,user,authentication_string from mysql.user; +-----------+------------------+------------------------------------------------------------------------+ | host | user | authentication_string | +-----------+------------------+------------------------------------------------------------------------+ | localhost | mysql.infoschema | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED | | localhost | mysql.session | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED | | localhost | mysql.sys | $A$005$THISISACOMBINATIONOFINVALIDSALTANDPASSWORDTHATMUSTNEVERBRBEUSED | | localhost | root | | +-----------+------------------+------------------------------------------------------------------------+ 4 rows in set (0.00 sec) mysql\u0026gt; 可以看到，root用户的密码是空的。\n修改root用户的密码 执行命令：\n1 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;123456\u0026#39;; 这里的密码就随意填写，不建议使用过于简单的123456、root、admin之类的密码。 该命令执行完毕会得到结果：\n1 2 mysql\u0026gt; ALTER USER \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;123456\u0026#39;; Query OK, 0 rows affected (0.11 sec) 接着需要继续执行命令：\n1 flush privileges; 该命令作用是刷新MySQL的系统权限相关表，这样才能使刚刚的密码修改成功。\n每次MySQL新设置用户或更改密码后都需要用flush privileges;来刷新MySQL的系统权限相关表，否则会出现拒绝访问。 还有一种方法，就是重新启动MySQL服务，来使新设置生效。\n退出登录 输入命令：\n1 quit 结果如下：\n1 2 3 4 mysql\u0026gt; quit Bye D:\\software\\mysql-8.0.13-winx64\u0026gt; 参考链接 WINDOWS下安装MYSQL8.0.13解压版—图文详解 flush privileges 什么意思 ","permalink":"https://lewky.cn/posts/a28e251d.html/","tags":["MySQL","安装教程"],"title":"Windows下MySQL8.0.13解压版安装教程"},{"categories":["工作记录"],"contents":"前言 有时候需要对若干列进行一样的操作，比如在前一百行数据的最前边加上一样的字符，这时候可以通过列块编辑模式来快捷地实现这个效果。在列块编辑模式下，被选定的区域内的所有字符会被替换成你之后输入的字符。\nEclipse Alt + Shift + A启用列块编辑模式 按住鼠标左键选定区域 Alt + Shift + A关闭列块编辑模式 IntelliJ IDEA 按住Alt，接着按住鼠标左键不放，拖动鼠标选定要同时编辑的区域。\nNotepad++ 两种方法：\n按住Alt，接着按住鼠标左键不放，拖动鼠标选定要同时编辑的区域。 按住Alt + Shift，然后用键盘的上下左右箭头进行选定区域。 UltraEdit UltraEdit的列块编辑模式快捷键是Alt + C，也可以直接在Column菜单里选择Column Mode，或者直接在工具栏里点击其图标按钮。\n使用方法有两种：\n先选定要同时编辑的区域，再启动列块编辑模式。 先启动列块编辑模式，再选定要同时编辑的区域。 EditPlus 两种方法：\n菜单：编辑 -\u0026gt; 选择 -\u0026gt; 列选择 使用快捷键Alt + C，接着移动鼠标或键盘上下左右键选定区域。 注意：在自动换行的模式下是不行的，改为不自动换行就行了。可以参考设置自动换行的方法：EditPlus 3：设置自动换行 EmEditor 按住Alt + C不放，然后用鼠标选定区域。\nLiteEdit 按住Alt不放，然后用鼠标进行列块选择。 点击菜单上的“列块选择”后用鼠标进行列块选择。 参考链接 notepad++如何使用列块编辑模式？ eclipse、EditPlus等编辑器选中列(块)的方法 ","permalink":"https://lewky.cn/posts/f0ce18c5.html/","tags":["工作记录"],"title":"IDE工具、文本编辑器的列块编辑模式"},{"categories":["版本控制工具"],"contents":"初次配置用户名和邮箱 Git在push时需要使用到user.name和user.email，一般通过命令来进行配置或修改。\n1 2 3 4 5 6 7 8 9 10 11 //查看user.name git config user.name //查看user.email git config user.email //配置user.name git config --global user.name \u0026#34;your user name\u0026#34; //配置user.email git config --global user.email \u0026#34;your user email\u0026#34; 这里需要注意的是，配置命令只能用于初次配置user.name/email，如果不小心配置错误，或者重复配置，不可以通过重复执行以上命令来修改user.name/email，否则可能或报错说无法重复配置，或者导致一个key配置了多个value。\n修改user.name/user.email 如果想要修改已经配置过的user.name或email，有两种方式，一种是通过命令来修改；一种是直接修改.gitconfig文件。\n方式一：通过命令修改 //修改user.name\rgit config --global --replace-all user.name \u0026quot;your user name\u0026quot;\r//修改user.email\rgit config --global --replace-all user.email\u0026quot;your user email\u0026quot;\r方式二：修改.gitconfig文件 该文件是隐藏文件，位于C:\\Users\\{user}\\.gitconfig，直接修改里边的name或者email，如果有重复的name或email，可以将其删掉，只剩下一个就好。 修改完，通过git bash输入git config \u0026ndash;list可以查看是否修改成功了。 添加.gitignore文件 在Windows中无法直接创建该文件，因为文件名是.开头的，需要通过git bash来创建：\n1 touch .gitignore .gitignore文件的作用 .gitignore文件用来忽略被指定的文件或文件夹的改动，被记录在.gitignore文件里的文件或文件夹，是无法被git跟踪到的，换句话说，被忽略的文件是不会被放入到远程仓库里的。\n也就是说，如果文件已经存在于远程仓库中，是无法通过.gitignore文件来忽略的。\n.gitignore文件存放于git仓库的根目录下。\n.gitignore文件的语法 注释 #表示注释，如下：\n1 # Here is comment. 忽略文件/文件夹 直接写入文件或文件夹名即可，指定文件夹里的所有文件也会一起被忽略，如下：\n1 2 3 4 5 6 7 8 # ignore target folder target/ # ignore Eclipse files .settings/ build/ .classpath .project 不忽略文件/文件夹 !表示不忽略指定的文件，如下：\n1 2 # don\u0026#39;t ignore src folder !src/ 在指定文件夹里不忽略指定的文件 通过!可以实现更加有意思的用法，如下：\n1 2 3 # ignore scaffolds folder, but don\u0026#39;t ignore draft.md under scaffolds folder. scaffolds/* !scaffolds/draft.md **注意：这里必须在文件夹后面加上/*，否则是无法实现想要的效果的。并且被忽略的文件和想要不忽略的文件必须是同一路径，否则无法生效。**如下的写法就是不能生效的：\n1 2 3 # ignore scaffolds folder, but don\u0026#39;t ignore draft.md under scaffolds folder. scaffolds/* !scaffolds/test/draft.md 想要生效就要改成同一目录：\n1 2 3 # ignore scaffolds folder, but don\u0026#39;t ignore draft.md under scaffolds folder. scaffolds/test/* !scaffolds/test/draft.md 使用通配符及其他符号 可以使用通配符及其他符号来指定复杂条件的文件，如下：\n1 2 3 4 *.log day_1?.txt hello[0-9].txt hi[^0-9].txt *表示匹配任意字符； ?表示匹配一个字符； []表示匹配中括号内的单个字符： 可以使用-来表示连贯的字符，比如0-9，a-z，A-Z等，[0-9]表示匹配从0到9的单个字符。 可以使用^来表示除外，比如[^0-9]表示除0到9之外的单个字符。 .gitignore怎么忽略已经被版本控制的文件 如果某个文件已经存在于远程仓库了，也就是说某个文件已经被版本控制了，如果将该文件添加到.gitignore中，是无法生效的。因为.gitignore是用来控制尚未被纳入版本控制的文件，如果文件已经存在于远程库中，自然也就无法生效了。\n于是就此衍生了一个问题：.gitignore怎么忽略已经被版本控制的文件？\n方法一 直接在远程库里将想要忽略的文件删除掉，再将该文件写入.gitignore中即可。\n这种做法的前提是，你确定该文件是允许从远程库删除掉的，然而有些时候，这种做法是不可能的。要么没权限去远程库删掉该文件，要么该文件是必须的。\n方法二 使用命令git rm --cached filename，然后将该文件写入.gitignore中即可。\n该命令表示从git仓库中将文件移除，不再进行版本控制，但保留工作区的该文件。\n需要注意的是，该命令其实和方法一差不多。git rm表示移除某个文件，--cached表示从暂存区中移除，如果不加该参数就是直接从工作区移除了。\n工作区就是指的Working Tree，暂存区就是指的Stage。工作区就是我们的磁盘，被版本控制的文件都存放于工作区。如果改动了某个文件，首先要将该文件添加到暂存区(Stage)，然后再提交(commit)到本地仓库，最后才推送(push)到远程库。\ngit rm --cached filename并不会从物理上删除文件，只是从暂存区中将文件删除。由于该文件原本已经被版本控制了，使用了该命令后，虽然保留了工作区的该文件，但是却会在暂存区中生成一个删除了该文件的记录，如果此时进行commit，就会把版本库里的该文件给删掉了，如果push到远程库，也会被删掉。最终还是走的方法一的路子。\n关于git rm --cached filename的补充 看到有篇文章举例很详细，如下：\n新建文件1.txt，未被跟踪(Untracked files)，提交到暂存区(Changed to be committed)，未提交到版本库。 使用git rm —cached 1.txt： 把文件恢复到未被跟踪的状态，即删除暂存区中的1.txt； 文件1.txt，已经提交到版本库，工作区，暂存区都是干净的。使用git rm —cached 1.txt： 把工作区的文件1.txt置为了”未跟踪”状态，即Untracked files 暂存区生成一个deleted 1.txt的记录，如果提交了，就是把版本库中的1.txt删除。 不影响工作区中的文件。 文件1.txt, 已经提交到版本库，修改1.txt，并且提交到了暂存区。使用git rm —cached 1.txt： 把工作区的文件1.txt置为了”未跟踪”状态，即Untracked files。\u2028暂存区生成一个deleted 1.txt的记录，如果提交了，就是把版本库中的1.txt删除。\u2028不影响工作区中的文件。还是修改后的1.txt 文件1.txt, 已经提交到版本库，修改1.txt，提交到暂存区，继续修改1.txt。使用git rm —cached 1.txt 会报错，不能执行操作。 Git - Merge: refusing to merge unrelated histories 场景 我在本地有个代码仓库local-A，本地仓库local-A已经和一个远程仓库remote-A关联了。\n接着我又在GitHub上新建了一个仓库remote-B，我希望将本地仓库local-A的本地dev分支push到这个新建的远程库remote-B。我的想法是这样的：\n在本地仓库local-A里添加刚刚新建的远程库remote-B 检出(check out)并切换到remote-B的master分支 将本地dev分支merge到当前的master分支 解决可能发生的冲突后，将改动全部commit并push到远程库remote-B的master分支上 接着当我做到第三步的时候，发现报错如下：\n1 Merge: refusing to merge unrelated histories 看到报错，我又重新操作了一遍，依然是同样的错误。记得以前我也做过类似的操作，但是却没有现在的问题，百度了下，发现可能是git升级之后造成的。\n解决方案 因为两个仓库是不同的项目(本地仓库已经跟踪了另外一个远程库了)，git默认不允许不相干的项目进行push等操作。如果想要进行这些操作，就需要加入--allow-unrelated-histories参数才可以合并两个不同的项目：\n1 git merge --squash dev --allow-unrelated-histories 这句命令表示将dev分支合并到当前分支，这里的两个本地分支各自追踪不同的远程库，需要加入--allow-unrelated-histories参数才能够完成合并操作而不报错，至于--squash参数是为了压缩dev分支原本的commit历史，可以将原本所有的commit历史合成一个commit，以避免当前分支在合并之后掺入了其他项目的commit历史。\nwarning: LF will be replaced by CRLF 这个问题由不同平台的换行符不同所造成：\nCR是回车，CarriageReturn，即\\r（return）。LF是换行，LineFeed，即\\n（newline）。 Dos和Windows平台使用CRLF来结束一行。 Mac和Linux平台使用LF来结束一行。（最早Mac以CR来结束一行，后改为了LF） 影响：\nUnix/Mac系统下的文件在Windows里打开，所有文字会变成一行。 Windows的文件在Unix/Mac下打开，在每行的结尾可能会多出一个^M符号。 Linux保存的文件在windows上用记事本查看会出现黑点。 解决方法：\n为了避免git管理的项目中出现混合的换行符，通常会将项目的换行符设置为LF。\n对于Windows平台，git的客户端默认设置为core.autocrlf=true。在提交文件时，会自动将换行符转换为LF，在检出文件时则自动转为CRLF。\n1 git config --global core.autocrlf true 对于Mac和Linux平台，可以将配置设置为input。这样在提交文件时会转为LF，检出时则不转换。\n1 git config --global core.autocrlf input 如果只使用Windows平台进行开发并运行项目，可以设置为false，来取消git自动转换换行符的功能。\n1 git config --global core.autocrlf false 还可以配置core.safecrlf来改变git对于换行符的检查行为：\n1 2 3 4 5 6 7 8 #拒绝提交包含混合换行符的文件 git config --global core.safecrlf true #允许提交包含混合换行符的文件 git config --global core.safecrlf false #提交包含混合换行符的文件时给出警告 git config --global core.safecrlf warn 可以通过以下命令来查询Git的配置：\n1 2 3 4 5 // 查询配置 git config -l // 查询全局配置 git config -l --global 统计代码提交行数 可以在git bash里用git log命令来统计，部分参数说明如下：\n1 2 3 4 5 6 7 8 9 10 11 12 --author 指定作者 --stat 显示每次更新的文件修改统计信息，会列出具体文件列表 --shortstat 统计每个commit 的文件修改行数，包括增加，删除，但不列出文件列表 --numstat 统计每个commit 的文件修改行数，包括增加，删除，并列出文件列表 --pretty 使用其他格式显示历史提交信息 --pretty=tformat\t可以定制要显示的记录格式 --since, --after 仅显示指定时间之后的提交 --until, --before 仅显示指定时间之前的提交 -w 显示字数 -c 显示Bytes数 -l 显示行数 统计某段时间内的提交：\n1 git log --since ==2021-09-01 --until=2021-10-05 | wc -l 统计当前用户的代码提交量，包括增加、删除：\n1 git log --author=\u0026#34;$(git config --get user.name)\u0026#34; --pretty=tformat: --numstat | gawk \u0026#39;{ add += $1 ; subs += $2 ; loc += $1 - $2 } END { printf \u0026#34;added lines: %s removed lines : %s total lines: %s\\n\u0026#34;,add,subs,loc }\u0026#39; 统计仓库排名前五的提交：\n1 2 3 4 git log --pretty=\u0026#39;%aN\u0026#39; | sort | uniq -c | sort -k1 -n -r | head -n 5 --按照邮箱来统计排名前五的提交（邮箱名不同，但是用户名可以相同） git log --pretty=format:%ae | gawk -- \u0026#39;{ ++c[$0]; } END { for(cc in c) printf \u0026#34;%5d %s\\n\u0026#34;,c[cc],cc; }\u0026#39; | sort -u -n -r | head -n 5 贡献者统计：\n1 git log --pretty=\u0026#39;%aN\u0026#39; | sort -u | wc -l 提交数统计：\n1 git log --oneline | wc -l 添加或修改的代码行数：\n1 git log --stat|perl -ne \u0026#39;END { print $c } $c += $1 if /(\\d+) insertions/;\u0026#39; git reset \u0026ndash;hard HEAD^后显示more? 如果在cmd窗口中输入git reset --hard HEAD^会显示more?，原因是^在cmd窗口中代表换行符，因此这里会通过回显more?来询问你是否还需要输入更多命令。\n解决方法有如下几种：\n加引号：git reset --hard \u0026quot;HEAD^\u0026quot; 加一个^进行转义：git reset --hard HEAD^^ 换成~：git reset --hard HEAD~ 或者 git reset --hard HEAD~1 ~后面的数字表示回退几次提交，默认是一次。\n如果使用git bash或者powershell则不会出现该问题。\n参考链接 .gitignore 规则写法 - 在已忽略文件夹中不忽略指定文件、文件夹【注意项】 .gitignore无效，不能过滤某些文件 git rm - - cached filename git忽略已经被提交的文件 如何去解决fatal: refusing to merge unrelated histories git merge \u0026ndash;no-ff是什么意思 关于git提示“warning: LF will be replaced by CRLF”终极解答 用git统计代码提交行数 git reset \u0026ndash;hard HEAD^后显示more?的解决方案 ","permalink":"https://lewky.cn/posts/git-issues/","tags":["Git","版本控制工具","工作记录"],"title":"Git问题汇总"},{"categories":["日志框架"],"contents":"功能需求 项目里将User分成了各个区域(domain)，这些domain有个标志domainId，现在要求在打印日志的时候，不仅将所有User的日志都打印到日志文件logs/CNTCore.log中，还需要另外再打印到对应domain的日志文件logs/{domainId}/CNTCore.log。\n比如User A的domainId是RD2，那么除了logs/CNTCore.log外，还需要将该User A的日志额外打印到logs/RD2/CNTCore.log中。\n实现思路 将所有User的日志都打印到日志文件logs/CNTCore.log中，这个可以直接使用配置文件log4j2.xml来解决，一个简单的配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration monitorInterval=\u0026#34;30\u0026#34;\u0026gt; \u0026lt;Appenders\u0026gt; \u0026lt;Console name=\u0026#34;stdout\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;%-5p %m%n\u0026#34; /\u0026gt; \u0026lt;ThresholdFilter level=\u0026#34;debug\u0026#34; onMatch=\u0026#34;ACCEPT\u0026#34; onMismatch=\u0026#34;DENY\u0026#34; /\u0026gt; \u0026lt;/Console\u0026gt; \u0026lt;RollingFile name=\u0026#34;cntCorelog\u0026#34; immediateFlush=\u0026#34;true\u0026#34; fileName=\u0026#34;logs/CNTCore.log\u0026#34; filePattern=\u0026#34;logs/CNTCore.log.%d{yyyy-MM-dd-a}.gz\u0026#34; append=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;PatternLayout\u0026gt; \u0026lt;pattern\u0026gt;%d{yyyy-MM-dd HH:mm:ss.SSS}:%p %t %X{TracingMsg} %c - %m%n\u0026lt;/pattern\u0026gt; \u0026lt;/PatternLayout\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy modulate=\u0026#34;true\u0026#34; interval=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;/Appenders\u0026gt; \u0026lt;Loggers\u0026gt; \u0026lt;Logger name=\u0026#34;com.lewis\u0026#34; level=\u0026#34;debug\u0026#34; additivity=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;cntCorelog\u0026#34; /\u0026gt; \u0026lt;/Logger\u0026gt; \u0026lt;Root level=\u0026#34;error\u0026#34;\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;stdout\u0026#34; /\u0026gt; \u0026lt;/Root\u0026gt; \u0026lt;/Loggers\u0026gt; \u0026lt;/configuration\u0026gt; 在上边的配置中，配置了cntCorelog这个appender来生成对应的回滚日志文件，具体由com.lewis这个logger来使用该appender进行拼接日志信息。\n至于另外再打印到对应domain的日志文件logs/{domainId}/CNTCore.log，这个可以通过代码来动态生成各个domain的appender，并交由com.lewis这个logger来进行拼接日志。\n代码的具体实现 项目的Log4j2依赖 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.logging.log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.11.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 动态生成appender 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public static void createDomainAppender(final String domainId){ final LoggerContext ctx = (LoggerContext) LogManager.getContext(false); final org.apache.logging.log4j.core.config.Configuration config = ctx.getConfiguration(); if (config.getAppender(domainId + \u0026#34;DomainCntCoreLog\u0026#34;) != null) { return; } final PatternLayout layout = PatternLayout.newBuilder() .withCharset(Charset.forName(\u0026#34;UTF-8\u0026#34;)) .withConfiguration(config) .withPattern(\u0026#34;%d %t %p %X{TracingMsg} %c - %m%n\u0026#34;) .build(); final TriggeringPolicy policy = TimeBasedTriggeringPolicy.newBuilder() .withModulate(true) .withInterval(1) .build(); final Appender appender = RollingFileAppender.newBuilder() .withName(domainId + \u0026#34;DomainCntCoreLog\u0026#34;) .withImmediateFlush(true) .withFileName(\u0026#34;logs/\u0026#34; + domainId + \u0026#34;/CNTCore.log\u0026#34;) .withFilePattern(\u0026#34;logs/\u0026#34; + domainId + \u0026#34;/CNTCore.log.%d{yyyy-MM-dd-a}.gz\u0026#34;) .withLayout(layout) .withPolicy(policy) .build(); appender.start(); config.addAppender(appender); final KeyValuePair[] pairs = {KeyValuePair.newBuilder().setKey(\u0026#34;domainId\u0026#34;).setValue(domainId).build()}; final Filter filter = ThreadContextMapFilter.createFilter(pairs, null, Result.ACCEPT, Result.DENY); config.getLoggerConfig(\u0026#34;com.lewis\u0026#34;).addAppender(appender, Level.DEBUG, filter); ctx.updateLoggers(config); } 这段代码动态生成一个名为omainCntCoreLog的RollingFileAppender，该appender交由com.lewis这个logger来使用，并将日志信息输入到logs/{domainId}/CNTCore.log。\n该logger在使用domainCntCoreLog这个RollingFileAppender时还设置了一个过滤器ThreadContextMapFilter，这个Filter用来控制logger只能对指定了domainId的进行打印日志。\nThreadContext是Log4j2用来存放线程信息的，相当于Log4j 1.X中的MDC和NDC，MDC是map，NDC是stack。当每个User登录时，就将该User的domainId存放到ThreadContext中，当退出登录时就将该domainId从ThreadContext中移除。\n假如有10个User登录了，一个User对应一个线程，每个线程都存放了User对应的domainId。在用户登录时，调用上边的方法来动态生成domain appender；假如有10个domainId，就会生成10个domain appender。\n由于这10个domain appender都被add到同一个logger里了，如果不通过ThreadContextMapFilter来控制，就会造成每个User的日志信息都会被输入到所有domain appender里去。\n在加载配置文件后拼接domain appender 需要注意的是，必须在读取配置文件后才能去动态生成appender或者其他的日志对象，否则会被原本的配置文件覆盖掉。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(final String[] args) { ThreadContext.put(\u0026#34;domainId\u0026#34;, \u0026#34;RD2\u0026#34;); final String domainId = \u0026#34;RD2\u0026#34;; final LoggerContext context1 = (org.apache.logging.log4j.core.LoggerContext) LogManager.getContext(false); try { context1.setConfigLocation(Loader.getResource(\u0026#34;log4j2.xml\u0026#34;, null).toURI()); createDomainAppender(domainId); } catch (final Exception e) { LogManager.getRootLogger().error(\u0026#34;load log4j2 configuration error\u0026#34;, e); ThreadContext.remove(\u0026#34;domainId\u0026#34;); } } 上边的代码简单地动态生成了RD2 domain的appender，需要注意的是，如果启用了Log4j2的动态加载配置文件功能，那么当配置文件被改动后并被重新加载时，会导致原本动态生成的domain appender无效。\n因为重新加载配置文件会生成新的LoggerContext对象，这时候可能会丢失一部分日志信息到对应的domain日志文件里。对于这个暂时没找到很好的解决方法，目前只能是在每个User登录时去创建domain appender对象，如果已存在就不创建。\n对ThreadContextMapFilter的补充 上边通过代码动态生成了RollingFileAppender和ThreadContextMapFilter，下边记录下配置文件里的写法：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;RollingFile name=\u0026#34;domainCntCoreLog\u0026#34; immediateFlush=\u0026#34;true\u0026#34; fileName=\u0026#34;logs/RD2/CNTCore.log\u0026#34; filePattern=\u0026#34;logs/RD2/CNTCore.log.%d{yyyy-MM-dd-a}.gz\u0026#34; append=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;ThreadContextMapFilter onMatch=\u0026#34;ACCEPT\u0026#34; onMismatch=\u0026#34;DENY\u0026#34;\u0026gt; \u0026lt;KeyValuePair key=\u0026#34;domainId\u0026#34; value=\u0026#34;RD2\u0026#34; /\u0026gt; \u0026lt;/ThreadContextMapFilter\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;%d %t %p %X{TracingMsg} %c - %m%n\u0026#34; /\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy modulate=\u0026#34;true\u0026#34; interval=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; 从上边的配置就可以看出来短板了，只能配置死某个domainId的RollingFileAppender以及ThreadContextMapFilter，假如有10个domainId，就要手动配置十个对应的appender和Filter，很是繁琐。\n就算通过占位符${ctx:domainId}的写法来避免写死，也只能生成某个domainId的appender：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;RollingFile name=\u0026#34;domainCntCoreLog\u0026#34; immediateFlush=\u0026#34;true\u0026#34; fileName=\u0026#34;logs/${ctx:domainId}/CNTCore.log\u0026#34; filePattern=\u0026#34;logs/${ctx:domainId}/CNTCore.log.%d{yyyy-MM-dd-a}.gz\u0026#34; append=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;ThreadContextMapFilter onMatch=\u0026#34;ACCEPT\u0026#34; onMismatch=\u0026#34;DENY\u0026#34;\u0026gt; \u0026lt;KeyValuePair key=\u0026#34;domainId\u0026#34; value=\u0026#34;${ctx:domainId}\u0026#34; /\u0026gt; \u0026lt;/ThreadContextMapFilter\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;%d %t %p %X{TracingMsg} %c - %m%n\u0026#34; /\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;TimeBasedTriggeringPolicy modulate=\u0026#34;true\u0026#34; interval=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;/RollingFile\u0026gt; 这种方法只能生成一个domain appender，此外如果启用了动态加载配置文件的功能，在扫描配置文件是否改动时，还会报错，原因是在RollingFileAppender的FileName和filePattern里使用了占位符。在另起线程扫描配置文件时，该占位符时取不到值的，于是就会报错。\n参考链接 运行时添加log4j2的appender log4j2如何动态的创建logger和appender log4j2 不使用配置文件，动态生成logger对象 log4j2的MDC应用配置 ","permalink":"https://lewky.cn/posts/8dc44b45.html/","tags":["Log4j","Log4j2"],"title":"Log4j2 - 动态生成Appender"},{"categories":["工作记录"],"contents":"问题与分析 今天把项目的log4j的依赖改成了log4j2的依赖后，发现使用Maven打包时报错如下：\n1 2 3 [ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project cbx-core: Compilation failure [ERROR] cannot access org.apache.http.annotation.NotThreadSafe [ERROR] class file for org.apache.http.annotation.NotThreadSafe not found 意思很清楚，找不到类NotThreadSafe。当我把log4j2改回来log4j后重新打包就不再报错，很明显，和log4j2有关。\n纳闷的是，我先前独自写了个测试类是没问题的，怎么一到项目里使用就报错了呢？Eclipse里也没有报错，看了下pom的依赖层级，也没发现有什么jar包冲突。百度了下，发现了问题原因。\n该问题是因为httpclient和httpcore两个jar包版本不匹配造成的。由于项目里使用了ElasticSearch，需要httpclient等相关的依赖，其中有两个依赖如下：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.5.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpcore\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.4.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 原本在使用log4j的时候，项目可以正常打包，但当改成log4j2的时候，需要使用到httpcore包中的某个注解，但由于在4.4.5版本的httpcore中舍弃了一些注解，于是就报错说找不到NotThreadSafe。\n根据Apache的jira issue：HDFS-12527来看，里边的comment提到了：\n1 The problem is that the httpclient and httpcore versions are incompatible. 根据comment来看，httpcore是httpclient的依赖，比较合适的版本应该是4.5.2的httpclient和4.4.4的httpcore。\n而从pom的依赖层次看，4.5.2的httpclient本身就是依赖了4.4.4版本的httpcore；但由于项目里偏偏引入更高版本的httpcore，平时固然没问题，但一旦导入某些jar包譬如log4j2，就会编译报错。\n解决方法 将httpcore的版本改成4.4.4(低于4.4.5即可)，重新进行Maven打包操作，结果编译成功，顺利打包。\n参考链接 Error:java: 无法访问org.apache.http.annotation.ThreadSafe 找不到org.apache.http.annotation.ThreadSafe的类文件 javadoc: error - class file for org.apache.http.annotation.ThreadSafe not found ","permalink":"https://lewky.cn/posts/55fa957a.html/","tags":["工作记录","Log4j2"],"title":"升级Log4j到Log4j2报错：cannot access org.apache.http.annotation.NotThreadSafe"},{"categories":["日志框架"],"contents":"应用场景与问题 当项目在运行时，我们如果需要修改log4j 1.X或者log4j2的配置文件，一般来说我们是不能直接将项目停止运行再来修改文件重新部署的。于是就有这样一个问题：如何在不停止当前项目的运行的情况下，让系统能够自动地监控配置文件的修改状况，从而实现动态加载配置文件的功能？而log4j 1.X和log4j2的差别略大，各自应该怎么实现这个功能？\nlog4j 1.X动态加载配置文件 log4j 1.X提供了动态加载配置文件的方法：\n1 2 DOMConfigurator.configureAndWatch() PropertyConfigurator.onfigureAndWatch() DOMConfigurator对应的是xml配置文件，PropertyConfigurator对应的是properties配置文件。这两个类都有configureAndWatch这个方法，该方法有个重载方法，如下：\n1 2 configureAndWatch(String configFilename) configureAndWatch(String configFilename, long delay) configureAndWatch方法用来监控配置文件是否被改动，监控的时间间隔是delay参数来决定，如果不传入该参数则使用默认的时间间隔1分钟(60000L)。configureAndWatch(String configFilename)实际上还是调用的configureAndWatch(String configFilename, long delay)。\nlog4j2动态加载配置文件 和log4j 1.X比起来，log4j2的动态加载配置很简单就能实现，不需要另外在代码中调用api，方法如下：\n1 2 3 \u0026lt;configuration monitorInterval=\u0026#34;30\u0026#34;\u0026gt; ... \u0026lt;/configuration\u0026gt; 在log4j2.xml配置文件中的configuration节点添加monitorInterval的值，单位是秒，如果配置的值大于0，则会按照时间间隔来自动扫描配置文件是否被修改，并在修改后重新加载最新的配置文件。如果不配置该值，默认为0，即不扫描配置文件是否被修改。\nLog4j 1.X动态加载配置文件的底层实现原理 DOMConfigurator#configureAndWatch源码解析 org.apache.log4j.xml.DOMConfigurator#configureAndWatch源码如下：\n1 2 3 4 5 static public void configureAndWatch(String configFilename, long delay) { XMLWatchdog xdog = new XMLWatchdog(configFilename); xdog.setDelay(delay); xdog.start(); } 这里new了一个XMLWatchdog对象，接着设置了delay参数，最后调用了start()方法。 watchdog是看门狗、检查者的意思，XMLWatchdog继承了FileWatchdog这个类，在XMLWatchdog中仅仅重写了doOnChange方法：\n1 2 3 public void doOnChange() { new DOMConfigurator().doConfigure(filename, LogManager.getLoggerRepository()); } 从方法名就可以看出来，如果XMLWatchdog监控到配置文件被改动了，就会调用这个doOnChange方法，用来重新加载配置文件。那么它又是怎么知道配置文件被改动过了呢？接着看其父类FileWatchdog的源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 public abstract class FileWatchdog extends Thread { /** The default delay between every file modification check, set to 60 seconds. */ static final public long DEFAULT_DELAY = 60000; /** The name of the file to observe for changes. */ protected String filename; /** The delay to observe between every check. By default set {@link #DEFAULT_DELAY}. */ protected long delay = DEFAULT_DELAY; File file; long lastModif = 0; boolean warnedAlready = false; boolean interrupted = false; protected FileWatchdog(String filename) { super(\u0026#34;FileWatchdog\u0026#34;); this.filename = filename; file = new File(filename); setDaemon(true); checkAndConfigure(); } /** Set the delay to observe between each check of the file changes. */ public void setDelay(long delay) { this.delay = delay; } abstract protected void doOnChange(); protected void checkAndConfigure() { boolean fileExists; try { fileExists = file.exists(); } catch(SecurityException e) { LogLog.warn(\u0026#34;Was not allowed to read check file existance, file:[\u0026#34;+ filename+\u0026#34;].\u0026#34;); interrupted = true; // there is no point in continuing return; } if(fileExists) { long l = file.lastModified(); // this can also throw a SecurityException if(l \u0026gt; lastModif) { // however, if we reached this point this lastModif = l; // is very unlikely. doOnChange(); warnedAlready = false; } } else { if(!warnedAlready) { LogLog.debug(\u0026#34;[\u0026#34;+filename+\u0026#34;] does not exist.\u0026#34;); warnedAlready = true; } } } public void run() { while(!interrupted) { try { Thread.sleep(delay); } catch(InterruptedException e) { // no interruption expected } checkAndConfigure(); } } } 可以看到，FileWatchdog继承了Thread类，类里定义了几个成员变量，比如默认的监控时间间隔等。而在该类的构造方法中可以看到，首先该线程类将名字设定成FileWatchdog，接着根据传入的配置文件的路径new了一个File对象，然后该线程类又设置成了守护线程(daemon thread)，最后调用了checkAndConfigure()。\n在checkAndConfigure()中，则是对new出来的配置文件File对象进行检查是否存在该文件，若不存在该文件则会设置成员变量的值，这样就不会去监控不存在的配置文件了。如果该配置文件存在，则通过lastModified()来获取文件的最后更新时间，和上次的更新时间作对比，如果比上次更新时间大则会调用doOnChange()来重新加载配置文件。\n而在FileWatchdog的run方法中，则是在无限循环中先让线程睡眠设置好的监控时间间隔，然后调用checkAndConfigure()。\n总结 可以看出，在log4j 1.X的DOMConfigurator中，是通过创建一个守护线程来不停地扫描配置文件的最后更新时间，并和上次的更新时间进行对比，如果最后更新时间大于上次更新时间则会重新加载配置文件。\nPropertyConfigurator#configureAndWatch源码解析 PropertyConfigurator的configureAndWatch()其实和DOMConfigurator差不多，区别是PropertyConfigurator在方法里new了一个PropertyWatchdog对象，PropertyWatchdog和XMLWatchdog一样继承了FileWatchdog，一样重写了doOnChange()方法。只是PropertyWatchdog是通过new PropertyConfigurator().doConfigure()来加载配置文件的。\n从源码实现来看，无论是使用xml配置文件，还是使用properties配置文件，其动态加载配置文件的底层实现是基本一样的。可以通过解析配置文件的文件后缀来判断是xml还是properties文件，然后调用对应的方法即可，大概的思路如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 boolean flag = true; boolean isXml = StringUtils.equalsIgnoreCase(\u0026#34;xml\u0026#34;, StringUtils.substringAfterLast(filepath, \u0026#34;.\u0026#34;)); ling delay = 30000; if (isXml) { if (flag) { DOMConfigurator.configureAndWatch(filepath, delay); } else { DOMConfigurator.configure(filepath); } } else { if (flag) { PropertyConfigurator.configureAndWatch(filepath, delay); } else { PropertyConfigurator.configure(filepath); } } log4j2底层实现动态加载配置文件的简单解析 虽然log4j2的动态加载配置很简单，但其底层实现比起log4j 1.X却要复杂很多，使用到了很多并发包下的类，具体也不是很了解，这里简单解释下流程。\n对于log4j2.xml文件，对应的是org.apache.logging.log4j.core.config.xml.XmlConfiguration这个类。如果在log4j2.xml里配置了monitorInterval，在构建XmlConfiguration时会根据该值来走一段特定的逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 for (final Map.Entry\u0026lt;String, String\u0026gt; entry : attrs.entrySet()) { final String key = entry.getKey(); final String value = getStrSubstitutor().replace(entry.getValue()); if (\u0026#34;status\u0026#34;.equalsIgnoreCase(key)) { statusConfig.withStatus(value); } else if (\u0026#34;dest\u0026#34;.equalsIgnoreCase(key)) { statusConfig.withDestination(value); } else if (\u0026#34;shutdownHook\u0026#34;.equalsIgnoreCase(key)) { isShutdownHookEnabled = !\u0026#34;disable\u0026#34;.equalsIgnoreCase(value); } else if (\u0026#34;shutdownTimeout\u0026#34;.equalsIgnoreCase(key)) { shutdownTimeoutMillis = Long.parseLong(value); } else if (\u0026#34;verbose\u0026#34;.equalsIgnoreCase(key)) { statusConfig.withVerbosity(value); } else if (\u0026#34;packages\u0026#34;.equalsIgnoreCase(key)) { pluginPackages.addAll(Arrays.asList(value.split(Patterns.COMMA_SEPARATOR))); } else if (\u0026#34;name\u0026#34;.equalsIgnoreCase(key)) { setName(value); } else if (\u0026#34;strict\u0026#34;.equalsIgnoreCase(key)) { strict = Boolean.parseBoolean(value); } else if (\u0026#34;schema\u0026#34;.equalsIgnoreCase(key)) { schemaResource = value; } else if (\u0026#34;monitorInterval\u0026#34;.equalsIgnoreCase(key)) { final int intervalSeconds = Integer.parseInt(value); if (intervalSeconds \u0026gt; 0) { getWatchManager().setIntervalSeconds(intervalSeconds); if (configFile != null) { final FileWatcher watcher = new ConfiguratonFileWatcher(this, listeners); getWatchManager().watchFile(configFile, watcher); } } } else if (\u0026#34;advertiser\u0026#34;.equalsIgnoreCase(key)) { createAdvertiser(value, configSource, buffer, \u0026#34;text/xml\u0026#34;); } } 可以看到，如果monitorInterval的值大于0，则会拿到WatchManager并设置扫描配置文件的时间间隔，如果配置文件存在，则会new一个ConfiguratonFileWatcher对象，并将配置文件和该对象一起传递给WatchManager的watchFile方法。这两个方法的底层实现很绕，比起log4j 1.X要复杂得多，不容易看懂。不过最终实现的效果还是一样的，依然会开启一个守护线程来监控配置文件是否被改动。\n区别在于，log4j2使用线程池来启动线程，在WatchManager#start()里实现的：\n1 2 3 4 5 6 7 8 @Override public void start() { super.start(); if (intervalSeconds \u0026gt; 0) { future = scheduler.scheduleWithFixedDelay(new WatchRunnable(), intervalSeconds, intervalSeconds, TimeUnit.SECONDS); } } 而该方法则是在启动配置文件时被调用的，AbstractConfiguration#start()：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /** * Start the configuration. */ @Override public void start() { // Preserve the prior behavior of initializing during start if not initialized. if (getState().equals(State.INITIALIZING)) { initialize(); } LOGGER.debug(\u0026#34;Starting configuration {}\u0026#34;, this); this.setStarting(); if (watchManager.getIntervalSeconds() \u0026gt; 0) { watchManager.start(); } ... } 这里只是简单解析了下主要的流程，具体的实现细节目前还看不太懂，有兴趣的可以自己去看看log4j2的源码。另外我在官方文档里看到说monitorInterval的最小值是5，但是在源码里也没看到这个，我觉得只要配置值大于0应该就是可以的。有不对之处，欢迎指出。\n这是官方原文：\n###Automatic Reconfiguration When configured from a File, Log4j has the ability to automatically detect changes to the configuration file and reconfigure itself. If the monitorInterval attribute is specified on the configuration element and is set to a non-zero value then the file will be checked the next time a log event is evaluated and/or logged and the monitorInterval has elapsed since the last check. The example below shows how to configure the attribute so that the configuration file will be checked for changes only after at least 30 seconds have elapsed. The minimum interval is 5 seconds.\n参考链接 Log4j 2.0 的新特性 Log4j – Configuring Log4j 2 - Apache Log4j 2 ","permalink":"https://lewky.cn/posts/2c65baa3.html/","tags":["Log4j","Log4j2"],"title":"Log4j和Log4j2怎么动态加载配置文件"},{"categories":["日志框架"],"contents":"LevelRangeFilter的注意点 在log4j2中，LevelRangeFilter的minLevel，maxLevel的配置是和log4j 1.x相反的；minLevel需要配置的是高级别，maxLevel配置的是低级别，如下：\n1 \u0026lt;LevelRangeFilter minLevel=\u0026#34;fatal\u0026#34; maxLevel=\u0026#34;info\u0026#34; onMatch=\u0026#34;ACCEPT\u0026#34; onMismatch=\u0026#34;DENY\u0026#34;/\u0026gt; 如上边的配置，是打印info到fatal级别的log，如果配置反过来，则不会输出任何log。\n如果不配置minLevel、maxLevel、onMatch和onMismatch的值，则会为其设置默认值，在LevelRangeFilter中的源码实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @PluginFactory public static LevelRangeFilter createFilter( // @formatter:off @PluginAttribute(\u0026#34;minLevel\u0026#34;) final Level minLevel, @PluginAttribute(\u0026#34;maxLevel\u0026#34;) final Level maxLevel, @PluginAttribute(\u0026#34;onMatch\u0026#34;) final Result match, @PluginAttribute(\u0026#34;onMismatch\u0026#34;) final Result mismatch) { // @formatter:on final Level actualMinLevel = minLevel == null ? Level.ERROR : minLevel; final Level actualMaxLevel = maxLevel == null ? Level.ERROR : maxLevel; final Result onMatch = match == null ? Result.NEUTRAL : match; final Result onMismatch = mismatch == null ? Result.DENY : mismatch; return new LevelRangeFilter(actualMinLevel, actualMaxLevel, onMatch, onMismatch); } 至于为什么把最大最小level的值配置反了就会无法输出，是因为在LevelRangeFilter中的源码实现如下：\n1 2 3 private Result filter(final Level level) { return level.isInRange(this.minLevel, this.maxLevel) ? onMatch : onMismatch; } 可以看到，在调用filter方法进行过滤时，是调用了level#isInRange()来判断是否匹配该filter的。而在该方法中，实现如下：\n1 2 3 public boolean isInRange(final Level minLevel, final Level maxLevel) { return this.intLevel \u0026gt;= minLevel.intLevel \u0026amp;\u0026amp; this.intLevel \u0026lt;= maxLevel.intLevel; } 这里通过对比Level对象的intLevel值(int)来判断是否匹配，而这些Level对象也在Level这个类里进行里实例化：\n1 2 3 4 5 6 7 8 9 10 static { OFF = new Level(\u0026#34;OFF\u0026#34;, StandardLevel.OFF.intLevel()); FATAL = new Level(\u0026#34;FATAL\u0026#34;, StandardLevel.FATAL.intLevel()); ERROR = new Level(\u0026#34;ERROR\u0026#34;, StandardLevel.ERROR.intLevel()); WARN = new Level(\u0026#34;WARN\u0026#34;, StandardLevel.WARN.intLevel()); INFO = new Level(\u0026#34;INFO\u0026#34;, StandardLevel.INFO.intLevel()); DEBUG = new Level(\u0026#34;DEBUG\u0026#34;, StandardLevel.DEBUG.intLevel()); TRACE = new Level(\u0026#34;TRACE\u0026#34;, StandardLevel.TRACE.intLevel()); ALL = new Level(\u0026#34;ALL\u0026#34;, StandardLevel.ALL.intLevel()); } 可以看到，这些Level对象的intLevel值是由另一个枚举类StandardLevel来提供的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * No events will be logged. */ OFF(0), /** * A severe error that will prevent the application from continuing. */ FATAL(100), /** * An error in the application, possibly recoverable. */ ERROR(200), /** * An event that might possible lead to an error. */ WARN(300), /** * An event for informational purposes. */ INFO(400), /** * A general debugging event. */ DEBUG(500), /** * A fine-grained debug message, typically capturing the flow through the application. */ TRACE(600), /** * All events should be logged. */ ALL(Integer.MAX_VALUE); 可以看到，Level级别越高，其对应的intLevel值越小，可以这样理解：级别越高，能打印出来的日志信息就越少，所以其intLevel值就越小。\n如果我们把LevelRangeFilter的minLevel、maxLevel配置反了，会导致level#isInRange()返回false，最终也就没有任何日志得以输出了。\n","permalink":"https://lewky.cn/posts/f53d27da.html/","tags":["Log4j2"],"title":"Log4j2中LevelRangeFilter的注意点"},{"categories":["日志框架"],"contents":"前言 log4j中常用的Filter分为四种：DenyAllFilter、LevelMatchFilter、LevelRangeFilter、StringMatchFilter。\n当appender匹配了某个Filter的时候，就不会继续匹配下一个filter，所以当需要配置多个filter时需要注意先后顺序，这样才能实现需要的效果。\n这些filter有个共同的属性AcceptOnMatch，用来控制匹配到的appender是否打印日志。\n只打印指定level的日志 假如现在只希望打印INFO和ERROR级别的日志，可以这样配置：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;appender name=\u0026#34;cntCorelog\u0026#34; class=\u0026#34;org.apache.log4j.rolling.RollingFileAppender\u0026#34;\u0026gt; ...... \u0026lt;filter class=\u0026#34;org.apache.log4j.varia.LevelMatchFilter\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;LevelToMatch\u0026#34; value=\u0026#34;INFO\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;AcceptOnMatch\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter class=\u0026#34;org.apache.log4j.varia.LevelMatchFilter\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;LevelToMatch\u0026#34; value=\u0026#34;ERROR\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;AcceptOnMatch\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter class=\u0026#34;org.apache.log4j.varia.DenyAllFilter\u0026#34; /\u0026gt; \u0026lt;/appender\u0026gt; 这里如果不配置最后一个filter，则会放行所有日志输出。\n不打印指定level的日志 假如不希望打印DEBUG级别的日志，可以这样配置：\n1 2 3 4 \u0026lt;filter class=\u0026#34;org.apache.log4j.varia.LevelMatchFilter\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;LevelToMatch\u0026#34; value=\u0026#34;ERROR\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;AcceptOnMatch\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/filter\u0026gt; AcceptOnMatch表示是否输出日志，这里需要注意的是，一旦匹配了某个filter，就无法再匹配后续的filter了，如下：\n1 2 3 4 5 6 7 8 \u0026lt;filter class=\u0026#34;org.apache.log4j.varia.LevelMatchFilter\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;LevelToMatch\u0026#34; value=\u0026#34;ERROR\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;AcceptOnMatch\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter class=\u0026#34;org.apache.log4j.varia.LevelMatchFilter\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;LevelToMatch\u0026#34; value=\u0026#34;ERROR\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;AcceptOnMatch\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/filter\u0026gt; 对于上面的配置，ERROR级别的日志匹配了第一个filter后，结果是被过滤掉不被输出，于是第二个filter就不生效了。\n如果将上边的配置颠倒过来，如下：\n1 2 3 4 5 6 7 8 \u0026lt;filter class=\u0026#34;org.apache.log4j.varia.LevelMatchFilter\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;LevelToMatch\u0026#34; value=\u0026#34;ERROR\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;AcceptOnMatch\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/filter\u0026gt; \u0026lt;filter class=\u0026#34;org.apache.log4j.varia.LevelMatchFilter\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;LevelToMatch\u0026#34; value=\u0026#34;ERROR\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;AcceptOnMatch\u0026#34; value=\u0026#34;false\u0026#34; /\u0026gt; \u0026lt;/filter\u0026gt; 这时候ERROR级别的日志就依然能正常被打印出来。\n只打印从level A到B之间的所有日志 假如现在只想要打印INFO到ERROR级别之间的日志，可以这样配置：\n1 2 3 4 5 \u0026lt;filter class=\u0026#34;org.apache.log4j.varia.LevelRangeFilter\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;LevelMin\u0026#34; value=\u0026#34;INFO\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;LevelMax\u0026#34; value=\u0026#34;ERROR\u0026#34;/\u0026gt; \u0026lt;param name=\u0026#34;AcceptOnMatch\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/filter\u0026gt; 需要注意的是，对于LevelRangeFilter，会匹配所有的appender，如果将该filter置于其他filter的前面，则会导致后续的filter无效。\n只打印包含某些字符串的日志 假如只希望打印某些字符串的日志，可以这样配置：\n1 2 3 4 \u0026lt;filter class=\u0026#34;org.apache.log4j.varia.StringMatchFilter\u0026#34;\u0026gt; \u0026lt;param name=\u0026#34;StringToMatch\u0026#34; value=\u0026#34;test\u0026#34; /\u0026gt; \u0026lt;param name=\u0026#34;AcceptOnMatch\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/filter\u0026gt; 如上配置，如果日志里包含了test这个字符串就会被输出到日志了，如果是包含某些字符串就不打印出来，直接将AcceptOnMatch设成false就行。\n如果不配置StringToMatch的value，该filter无效；如果将其value配置为\u0026quot;\u0026quot;空字符串，该filter则会匹配所有日志。在StringMatchFilter的源码实现里，是通过indexOf()来判断是否包含指定字符串的。\n","permalink":"https://lewky.cn/posts/ec168d9b.html/","tags":["Log4j"],"title":"Log4j.xml中Filter的用法"},{"categories":["前端"],"contents":"问题 由于我在页面中使用了\u0026lt;audio\u0026gt;标签来播放一首背景音乐，该音频是一首大小为2.7MB的MP3文件。在第一次加载该页面时，需要花费相当长的一段时间去加载音频。\n解决方法 百度了下才知道，原来超过2MB的背景音乐其实是一个很巨大的文件了，如果网速稍微慢一些用户体验就会很差了。大概有几种解决的办法：\n把音乐加到FLASH里 使用rm或wma格式的背景音乐 降低MP3文件的音质 第一个就不说了，FLASH已经声名狼藉，注定凉凉了。 第二个出于不同浏览器的兼容性以及\u0026lt;audio\u0026gt;标签的兼容性，还是决定使用MP3文件。 最后就只能使用第三种方法了，通过MP3压缩软件，最后将该MP3音频压缩到了400KB左右，总算是马马虎虎实现了想要的效果。 这里说一下，我用的mp3压缩软件是RazorLame\n参考链接 网页中背景音乐加在太慢 【工具分享】wav转mp3的强力软件RazorLame（强烈推荐） RazorLame 完全攻略 ","permalink":"https://lewky.cn/posts/eee6409f.html/","tags":["前端","audio标签"],"title":"页面的背景音乐加载很慢"},{"categories":["PostgreSQL"],"contents":"比较两个日期之间的时间差超过N个小时 在PostgreSQL中，两个时间戳相减会得到一个interval类型的结果，如下：\n1 2 select now() - \u0026#39;2021-03-28 15:47:07\u0026#39;; --0 years 0 mons 2 days 0 hours 1 mins 15.081206 secs select \u0026#39;2021-03-28 15:47:07\u0026#39; - now(); --0 years 0 mons -2 days 0 hours -3 mins -17.692835 secs 通过对比两个interval类型即可得到我们想要的结果，PostgreSQL会自行对interval类型进行处理，如下：\n1 2 3 select interval \u0026#39;0 years 100 mons 2 days 0 hours\u0026#39; \u0026gt; interval \u0026#39;4years\u0026#39;; --true select now() - \u0026#39;2021-03-28 15:47:07\u0026#39; \u0026gt; interval \u0026#39;4days\u0026#39;; --false 比较日期时隐藏的坑 PostgreSQl在比较两个timestamp时，隐藏了一个坑：在用DBeaver查看数据时，这个timestamp的值是看不到毫秒值的，在比较的时候可能不小心就被毫秒值坑了，如下：\n1 select * from cnt_item where updated_on \u0026gt; \u0026#39;2019-05-13 15:49:26\u0026#39;; 上述的条件是可能查出来更新日期为2019-05-13 15:49:26的数据的，原因是上诉条件等价于updated_on \u0026gt; '2019-05-13 15:49:26 000'，有部分数据的毫秒值虽然看不到，但却大于条件中的毫秒值，因此会造成查询出问题的错觉。\n在查询日期时，应该尽量根据实际情况将秒值增大一秒或变小一秒。\nEXTRACT函数对日期进行处理 语法如下：\n1 EXTRACT(type FROM date) data是日期，也可以是时间间距类型interval。这里的type需要指定为以下的值之一：\ntype value day 返回日期值 month 返回月份值 year 返回年份值 doy（day of year） 返回年中的第几天 dow（day of week） 返回星期几 quarter 返回季度 epoch 将当前日期转化为秒值 1 2 3 4 5 6 7 8 9 10 11 select now(); --2021-03-30 17:21:50 select extract(day from(now())); --30 select extract(month from(now())); --3 select extract(year from(now())); --2021 select extract(doy from(now())); --89 select extract(dow from(now())); --2 select extract(quarter from(now())); --1 select extract(epoch from \u0026#39;01:00:06.678\u0026#39;::time); --3606.678 select extract(epoch from(interval \u0026#39;0 years 0 mons 0 days 0 hours 10 mins 10.00 secs\u0026#39;)); --610 如果需要把时间转化成毫秒值，直接把结果乘以1000就行。\n去掉日期的毫秒值 向下取整函数floor()\n1 select floor(extract(epoch from \u0026#39;03:21:06.678\u0026#39;::time)); 向上取整函数ceil()或ceiling()，这两个一样的\n1 2 select ceil(extract(epoch from \u0026#39;03:21:06.678\u0026#39;::time)); select ceiling(extract(epoch from \u0026#39;03:21:06.678\u0026#39;::time)); 四舍五入函数round()\n1 select round(extract(epoch from \u0026#39;03:21:06.678\u0026#39;::time)); 补充：epoch新纪元时间 新纪元时间 Epoch 是以1970-01-01 00:00:00 UTC为标准的时间，将目标时间与1970-01-01 00:00:00时间的差值以秒来计算 ，单位是秒，可以是负值; 有些应用会将时间存储成epoch 时间形式，以提高读取效率。\n参考链接 postgresql获取系统当前时间毫秒数的sql，以及秒级时间戳 PostgreSQL: epoch 新纪元时间的使用 postgresql 比较两个时间差大于 N个小时 PostgreSQL中的函数之日期时间函数（使用EXTRACT函数获取日期中的指定值） ","permalink":"https://lewky.cn/posts/postgresql-date/","tags":["工作记录"],"title":"PostgreSQL - 日期函数汇总"},{"categories":["PostgreSQL"],"contents":"前言 对于select 233;这个sql，得到的结果是int4类型，如果我们希望将结果转换成其他的数据类型，有以下方法(下边的{数据类型}表示占位符，要替换成数据库中的某一种数据类型)：\n方法一：使用::{数据类型} 1 select 233::text; 上边的sql通过::text将结果转换成了text类型。\n方法二：使用{数据类型}'' 1 2 select text \u0026#39;233\u0026#39;; select text\u0026#39;233\u0026#39;; 上边的sql通过text''将结果转换成了text类型。这里的两种写法是一样的，加不加空格没有影响。\nN\u0026rsquo;\u0026lsquo;和::bpchar的区别 N\u0026rsquo;\u0026lsquo;的效果和::bpchar效果类似，都表示定长字符串。比如下边的sql：\n1 2 3 select N\u0026#39;233\u0026#39; as num; select \u0026#39;233\u0026#39;::bpchar as num; select \u0026#39;233\u0026#39; as num; 以上sql都会得到'233\u0026rsquo;的结果集，但是对于前两条sql拿到的字符串是bpchar类型，相当于MySQL的char类型；而第三条sql拿到的字符串是text类型。\nVARCHAR(n)指定了最大长度，变长字符串，不足定义长度的部分不补齐。 CHAR(n)和bpchar是定长字符串，实际数据不足定义长度时，以空格补齐。 TEXT没有特别的上限限制（仅受行的最大长度限制）。 select N'233';中的N''，实际上就是方法二的用法，会将结果转换成bpchar类型。\n方法三：使用cast()函数 这个函数不是PostgreSQL独有的，其他数据库也有类似的用法，在PostgreSQL中用法如下：\n1 select cast(233 as numeric); cast其实就是转型的意思，该sql将233转换成numeric类型并输出到结果集。\n","permalink":"https://lewky.cn/posts/f20deee6.html/","tags":["工作记录"],"title":"PostgreSQL - 怎么转换数据类型"},{"categories":["工作记录"],"contents":"前言 看到网上有的文章说JIRA是使用Textile这门标记语言，有些语法和Wikitext和Markdown相像。JIRA在2017年进行了一次大更新，某些语法可能和以前不大一样，这里纪录一下常用的一些语法。\n标题 h1.一级标题 h2.二级标题 h3.三级标题 h4.四级标题 h5.五级标题\n用法示例：\n1 h1.ddd 一共有h1到h5这五种大小的标题，但是h6也是有效果的，不过h6起到的作用是将小写字母变成大写字母，示例如下：\n1 h6.ddd 以上会得到DDD的输出。\n字体 用法 效果 *黑体* 黑体 _斜体_ 黑体 -删除线- 删除线 +下划线+ 下划线 ~下标~ 下标 ^上标^ 上标 注意在使用上边这些字体效果的时候，~等字符需要和其他文本相隔一个空格，否则没有效果，如下：\n1 H ~2~ O 换行 1 2 3 第一行 \\\\ 第二行 通过\\\\来进行换行。\n引用 1 bq. 这是引用，可以使用字体效果并进行换行。 通过bq. 来引用一段文字或图片等，可以在引用段里使用字体效果并进行换行。\n不过这个bq. 用来比较麻烦，用另一种引用的语法{quote}更好，而且还可以使用其他更多的效果，如下：\n1 2 3 4 5 6 7 {quote} Perhaps the simplest way to convert to using Log4j 2 is to replace the log4j 1.x jar file with Log4j 2\u0026#39;s log4j-1.2-api.jar. However, to use this successfully applications must meet the following requirements: # They must not access methods and classes internal to the Log4j 1.x implementation such as Appenders, LoggerRepository or Category\u0026#39;s callAppenders method. # They must not programmatically configure Log4j. # They must not configure by calling the classes DOMConfigurator or PropertyConfigurator. {quote} 附件 附件有两种方式：\n1 2 3 [^xxxx.mp4] 或者 !xxxx.mp4! [^xxxx.mp4]这种形式类似于超链，!xxxx.mp4!这种形式则可以将图片显示出来，或者将视频播放出来。\n如果附件是图片，还可以使用以下写法：\n1 2 3 4 5 显示图片的缩略图 !xxxx.jpg|thumbnail! 指定图片的大小 !xxxx.jpg|width=300,height=400! 如果附件是视频 ，还可以使用以下写法：\n1 2 指定视频播放器的大小 !xxxx.mp4|width=300,height=400! 列表 第一种无序列表，会在每行最前边显示一个圆点\n1 2 3 4 * 1 * 2 ** 2.1 * 3 第二种无序列表，会在每行最前边显示一个方块\n1 2 3 4 - 1 - 2 -- 2.1 - 3 有序列表\n1 2 3 4 # 1 # 2 ## 2.1 # 3 有序列表和无序列表可以混合使用，如下：\n1 2 3 4 # 1 # 2 #* 2.1 # 3 表格 1 2 3 4 5 6 7 8 9 表头加粗写法： ||heading 1||heading 2||heading 3|| |col A1|col A2|col A3| |col B1|col B2|col B3| 表头不加粗写法： |heading 1|heading 2|heading 3|| |col A1|col A2|col A3| |col B1|col B2|col B3| 超链 1 2 3 4 5 直接贴上一个超链： [https://lewky.cn] 给超链起一个别名： [233|https://lewky.cn] 此外，可以直接输入JIRA的issue id，会自动转换成特定的超链。\n转义字符 有些特殊字符在JIRA中具有特殊效果，如果需要输入这些字符，需要进行转义。JIRA使用的转义字符是\\，用法如下：\n1 \\{ 表情符号 JIRA支持通过输入一些特定的组合字符来显示成对应的表情符号，比如：\n1 2 3 :) :( :P :D ;) (y) (n) (i) (/) (x) (!) (+) (-) (?) (on) (off) (*) (*r) (*g) (*b) (*y) (flag) (flagoff) 高级文本格式 可以通过{panel}来显示一个模板块，如下：\n1 2 3 {panel} Some text {panel} 可以给这个panel起标题：\n1 2 3 {panel:title=My Title} Some text with a title {panel} 还可以给这个panel设置css属性：\n1 2 3 4 {panel:title=My Title|borderStyle=dashed|borderColor=#ccc|titleBGColor=#F7D6C1|bgColor=#FFFFCE} a block of text surrounded with a *panel* yet _another_ line {panel} 代码块 代码块通过{code}来使用：\n1 2 3 4 5 {code:xml} \u0026lt;test\u0026gt; \u0026lt;another tag=\u0026#34;attribute\u0026#34;/\u0026gt; \u0026lt;/test\u0026gt; {code} 建议给代码块设置对应的语言，譬如上边的xml，这样写的好处是代码块可以自动使用对应语言的代码高亮，并且当代码过长时会自动生成滚动条，不至于让代码块占据页面的一大块地方。\n同样可以给代码块设置标题和css属性：\n1 2 3 4 5 6 7 {code:title=Bar.java|borderStyle=solid} // Some comments here public String getFoo() { return foo; } {code} 参考链接 JIRA issue 中的标记语言（Textile） Text Formatting Notation Help ","permalink":"https://lewky.cn/posts/3c228edd.html/","tags":["工作记录","JIRA"],"title":"JIRA中的标记语言的语法参考"},{"categories":["Java"],"contents":"什么是反编译 高级语言源程序经过编译变成可执行文件，反编译就是逆过程。但是通常不能把可执行文件变成高级语言源代码，只能转换成汇编程序。\n反编译是一个复杂的过程,所以越是高级语言,就越难于反编译,但目前还是有许许多多的反编译软件:通过对他人软件的目标程序（可执行程序）进行“逆向分析、研究”工作，以推导出他人的软件产品所使用的思路、原理、结构、算法、处理过程、运行方法等设计要素，作为自己开发软件时的参考，或者直接用于自己的软件产品中。所以现在大家写的东西就想办法保护，不被侵权！\n总之，有时候我们想要阅读代码，但是只有jar包却没有源码，就需要用到反编译工具了。\nJava反编译工具JD-GUI Github上的官方下载地址：https://github.com/java-decompiler/jd-gui/releases\n有多种平台的安装版本，可以自己选择下载安装，也可以直接下载JAR包，然后用java -jar进行运行，如下：\n1 java -jar jd-gui-1.4.0.jar 安装Eclipse的反编译插件 jd-eclipse jd-gui在Eclipse上也有对应的反编译插件jd-eclipse，安装方式如下：\n打开Eclipse -\u0026gt; Help -\u0026gt; Install New Software\u0026hellip; -\u0026gt; Add\u0026hellip; 在弹出的窗口中输入Name和Location，Name可以随意取，Location要填写反编译插件的下载地址：http://jd.benow.ca/jd-eclipse/update （该地址可能已经过期，需要去官网下载jd-eclipse，地址：http://java-decompiler.github.io/ ） 填写完毕后会加载该插件的相关信息，勾选该插件，一路Next安装下去即可。 重启Eclipse该插件即可生效。 不过安装插件后Eclipse可能继续使用着默认的class查看器，我们可以把它改成我们新安装的jd查看器：\nWindow -\u0026gt; Preference -\u0026gt; General -\u0026gt; Editors -\u0026gt; File Associations 选中*.class文件 -\u0026gt; 将Class File Editor设置为默认(Default) 最后确定修改，无需重启Eclipse即可生效。 新版本的jd-eclipse的类文件查看器名字可能叫做JD Class File Viewer(总之，Class File Viewer是Eclipse自带的类文件查看器，安装插件后会出现新的类文件查看器)\nEnhanced Class Decompiler 3.0.0 上边的反编译插件jd-eclipse可能在安装并修改了class查看器后依然无效，可能是由于Eclipse版本不兼容或者其他的原因，这时候可以安装另一个反编译插件，安装步骤如下：\n打开Eclipse -\u0026gt; Help -\u0026gt; Eclipse Marketplace\u0026hellip; 在弹窗的搜索框中输入Decompiler，选择安装Enhanced Class Decompiler 3.0.0 安装工程中有Next选Next，中间需要选择接受安装协议，最后点击Finish 安装结束后重启Eclipse生效 参考链接 反编译是什么意思 Java反编译工具-JD-GUI jd-eclipse反编译插件的在线安装和使用 关于Eclipse安装了反编译插件,无法查看源码问题 ","permalink":"https://lewky.cn/posts/add9b646.html/","tags":["Java","反编译","Eclipse"],"title":"Java反编译工具JD-GUI以及Eclipse的反编译插件"},{"categories":["工作记录"],"contents":"问题 由于业务上的需求，重新改写了校验email的正则表达式，同时DB里又迁移了其他数据库的数据，现在需要重新对DB里的所有email再校验一次，以排除掉不合法的email。\nDB里的数据很多，手动去一个个校验的做法显然是不靠谱的，这种机械的重复性操作，自然是要用程序来解决才是最简易的。\n做法 拼接字符串 首先是将DB里所有的email都拼接成一个字符串，由于用的是PostgreSQL，所以直接使用现有的字符串拼接函数string_agg()。 具体用法如下：\n1 select string_agg(email, \u0026#39;;\u0026#39;) from cnt_user where is_latest; 大意就是拿到所有的最新版本的用户的email，以\u0026rsquo;;\u0026lsquo;作为间隔符，将这些email拼接起来，得到的结果就是：test1@qq.com;test2@qq.com...\n在程序中进行校验 自己写一个测试类，把刚刚db查询到的字符串复制进来，通过String类的split()将其进行切割成一个String数组，然后遍历该数组，通过正则表达式去一个个校验，将那些校验不通过的email给打印出来。\n注意：这种方法不适用于email数量特别多的情况，如果String数组的大小超过3亿多，会报内存溢出OutOfMemoryError的错误。\n大概的思路如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /** Regex for single EmailValidator */ public static final String SINGLE_EMAIL_REGEX = \u0026#34;(?:(?:[A-Za-z0-9\\\\-_@!#$%\u0026amp;\u0026#39;*+/=?^`{|}~]|(?:\\\\\\\\[\\\\x00-\\\\xFF]?)|\u0026#34; + \u0026#34;(?:\\\u0026#34;[\\\\x00-\\\\xFF]*\\\u0026#34;))+(?:\\\\.(?:(?:[A-Za-z0-9\\\\-_@!#$%\u0026amp;\u0026#39;*+/=?^`{|}~])|(?:\\\\\\\\[\\\\x00-\\\\xFF]?)|\u0026#34; + \u0026#34;(?:\\\u0026#34;[\\\\x00-\\\\xFF]*\\\u0026#34;))+)*)@(?:(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\\\.)+\u0026#34; + \u0026#34;(?:(?:[A-Za-z0-9]*[A-Za-z][A-Za-z0-9]*)(?:[A-Za-z0-9-]*[A-Za-z0-9])?))\u0026#34;; public static final Pattern SINGLE_EMAIL_REGEX_PATTERN = Pattern.compile(SINGLE_EMAIL_REGEX); ... final String emailString = \u0026#34;******\u0026#34;; //DB里通过函数拼接起来的email字符串 final String[] emails = emailString.split(\u0026#34;;\u0026#34;); for (final String email : emails) { final Matcher matcher = SINGLE_EMAIL_REGEX_PATTERN.matcher(email); if (!matcher.matches()) { System.out.println(\u0026#34;The email is invalid: \u0026#34; + email); } } 如果不合法的email有很多的话，还可以通过poi将这些email输出到一个文档中。\n","permalink":"https://lewky.cn/posts/4a555132.html/","tags":["工作记录","PostgreSQL","java","正则表达式"],"title":"怎么快速对DB里的所有email进行校验"},{"categories":["cmd"],"contents":"命令解读 ping是Windows、Unix和Linux系统下的一个命令。ping也属于一个通信协议，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式是ping空格ip地址，可以附带参数，可以直接在cmd中输入ping然后回车来得到具体的帮助信息。\n127.1是127.0.0.1，通常被称为本地回环地址(Loop back address)，不属于任何一个有类别地址类。它代表设备的本地虚拟接口，所以默认被看作是永远不会宕掉的接口。在windows操作系统中也有相似的定义，所以通常在安装网卡前就可以ping通这个本地回环地址。一般都会用来检查本地网络协议、基本数据接口等是否正常的。\n-n 4表示ping几次，ping一次大概一秒钟，如果不加这个参数去使用ping命令，默认会ping4次。\n\u0026gt;nul表示不显示ping的结果，但是不能隐藏错误信息。2\u0026gt;null表示隐藏错误信息。\n于是最后这句命令就变成了延迟命令，表示等待4秒钟，你会看到光标闪烁了四下，一般用来延迟后面的代码的执行，或者说，用来让程序等待N秒钟(取决于-n后面的数值)。\n补充 这里的\u0026gt;是重定向符，表示将输出重定向到指定的文件。如果该指定文件原本已存在，也会被覆盖掉。如果不希望覆盖掉原本的文件，可以用\u0026gt;\u0026gt;重定向符。\n我们输入的命令默认会重定向到控制台，也就是cmd窗口。比如你在命令提示符窗口键入dir会在控制台打印出目录文件，这时候其实运行的是dir \u0026gt;con，con就是指的console控制台。\u0026gt;nul表示将输出重定向到空设备nul，也就是不显示输出。\n至于2\u0026gt;nul的2，指的是stderr标准错误输出流，是用来输出错误信息的，这里就表示不输出错误信息。对应的，还有0\u0026gt;nul,1\u0026gt;nul。0表示stdin标准输入流，就是在控制台键入的信息。1表示stdout标准输出流，也就是正常输出的信息。1\u0026gt;nul其实就是\u0026gt;nul。\n参考链接 ping （网络诊断工具） 本地回环地址 ping -n 10 127.1\u0026gt;nul是什么意思 批处理 ping命令 ping -n 4 127.1 \u0026gt;nul 2\u0026gt;nul exit 什么意思啊？谢谢 批处理：其中的\u0026gt;NUL作用是什么？ bat语句中“1\u0026gt;\u0026amp;2”是什么意思？ ","permalink":"https://lewky.cn/posts/cf676a21.html/","tags":["cmd"],"title":"解读ping -n 4 127.1 \u003enul 2\u003enul"},{"categories":["cmd"],"contents":"区别 dos是磁盘操作系统(Disk Operating System)，是个人计算机上的一类操作系统。\nbat是DOS命令，在任何dos环境下都可以使用。\nbat文件是dos下的批处理文件，批处理文件是无格式的文本文件，它包含一条或多条命令，后缀为.cmd或.bat，在Windows NT系统中，两者没有任何区别。\ncmd是cmd.exe，是Win32命令，只能在32位系统中的命令行窗口中使用，仅仅是基于windows环境下的假DOS。\ncmd文件的描述是“windows nt命令脚本”，bat文件的描述是“ms dos批处理文件”；两者所使用的命令行代码是共用的，只是cmd文件中允许使用的命令要比bat文件多。cmd文件只有在windows2000以上的系统中才能运行，而bat文件则没有这个限制。在Windows NT系统中，这两种批处理文件由cmd.exe解释执行。在cmd命令提示符窗口键入批处理文件名，或者直接双击批处理文件，即可执行，系统会去调用cmd.exe按照该文件中各个命令出现的顺序来逐个运行。\n参考链接 cmd文件和bat文件有什么区别 bat和cmd文件是什么，dos又是什么东西 关于CMD和BAT ","permalink":"https://lewky.cn/posts/97f9f429.html/","tags":["cmd","计算机"],"title":"cmd,bat和dos的区别"},{"categories":["杂谈"],"contents":"GitHub仓库怎么添加协议 如果一开始在GitHub上创建仓库时没有添加协议，可以用以下方式来重新添加相关的协议：\n打开GitHub上的某个仓库，点击Create new file； 在新建文件的页面上，输入文件名LICENSE，这时候你会发现在标题的右边多出来一个按钮Choose a license template，点击该按钮； 在新页面上选择一个你想要的协议，接着在最右边输入Year和Full name，你会发现中间板块的年份和名称会发生变化，这是协议的预览界面，确认无误后点击最右边的Review and submit； 最后填写commit信息，点击Commit changes即可。 使用GitHub上的开源项目来引入各种图表和图标 GitHub上有一些有意思的开源项目，通过借助GitHub的api来获取数据并生成对应的图表或者小图标，这里推荐几个有意思的项目。\ngithubchart-api 这个是项目地址：https://github.com/2016rshah/githubchart-api\n该项目可以生成一个最近一年内的GitHub贡献图表，也就是GitHub首页上那个贡献日历表。用法很简单：\n1 \u0026lt;img src=\u0026#34;https://ghchart.rshah.org/lewky\u0026#34; /\u0026gt; https://ghchart.rshah.org是该项目的api地址，在后面加上GitHub的userId就能得到这个user当前一年的贡献图表。\n此外该api还支持修改配色，在userId前加上十六进制颜色代码即可，如下：\n1 \u0026lt;img src=\u0026#34;https://ghchart.rshah.org/FFA500/lewky\u0026#34; /\u0026gt; 效果如下：\ngithubchart.jpg\rshields 这个是项目地址：https://github.com/badges/shields 这个是项目官网的使用说明：https://shields.io/ 该项目可以生成各种小图标，不仅仅是GitHub相关的图标，还有其他平台的图标。官网里有很详细的分类，还有很友好的一键生成，包括Html、Markdown等格式。用法其实都是类似的，只需要修改url里的用户名或者仓库名字就行：\n1 2 3 4 5 /* GitHub的follow人数 */ \u0026lt;img alt=\u0026#34;GitHub followers\u0026#34; src=\u0026#34;https://img.shields.io/github/followers/lewky?style=social\u0026#34;\u0026gt; /* 项目的star人数 */ \u0026lt;img src=\u0026#34;https://img.shields.io/github/stars/lewky/lewky.github.io\u0026#34;\u0026gt; 这些图标可以通过?style=参数来修改风格，flat是默认风格，不指定style参数会使用默认风格，一共支持如下几种风格：\nplastic flat flat-square for-the-badge social 此外，还支持通过color、label、logo、logoColor这4个参数来更详细的定制，如下：\n1 2 3 4 5 6 7 8 9 10 11 \u0026lt;img alt=\u0026#34;GitHub followers\u0026#34; src=\u0026#34;https://img.shields.io/github/followers/lewky?style=plastic\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;GitHub followers\u0026#34; src=\u0026#34;https://img.shields.io/github/followers/lewky\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;GitHub followers\u0026#34; src=\u0026#34;https://img.shields.io/github/followers/lewky?style=flat-square\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;GitHub followers\u0026#34; src=\u0026#34;https://img.shields.io/github/followers/lewky?style=for-the-badge\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;GitHub followers\u0026#34; src=\u0026#34;https://img.shields.io/github/followers/lewky?style=social\u0026#34;\u0026gt; \u0026lt;img alt=\u0026#34;GitHub followers\u0026#34; src=\u0026#34;https://img.shields.io/github/followers/lewky?color=FFA500\u0026amp;label=Test\u0026amp;logo=skype\u0026amp;logoColor=FFA500\u0026amp;style=social\u0026#34;\u0026gt; 具体效果如下：\nimgShields.jpg\rgithub-readme-stats 这个是项目地址：https://github.com/anuraghazra/github-readme-stats\n这个项目支持展示4种类型的数据图表和多种风格的主题，有兴趣的可以去项目原地址看，里面提供了非常详细的Demo。关于图表卡片里的排行分数的官方说明如下：\nAvailable ranks are S+ (top 1%), S (top 25%), A++ (top 45%), A+ (top 60%), and B+ (everyone). The values are calculated by using the cumulative distribution function using commits, contributions, issues, stars, pull requests, followers, and owned repositories.\nStats Card 这个卡片用来展示GitHub用户的统计信息，官方称为Stats Card：\n1 ![Lewky\u0026#39;s github stats](https://github-readme-stats.vercel.app/api?username=lewky\u0026amp;show_icons=true) 效果如下：\nStats-Card\r可以通过hide=参数来选择隐藏统计项目，可选项有：stars,commits,prs,issues,contribs，如下：\n1 ![Lewky\u0026#39;s github stats](https://github-readme-stats.vercel.app/api?username=lewky\u0026amp;hide=contribs,prs) 在统计提交总数时，可以通过count_private=true参数来将私有仓库也纳入统计范围：\n1 ![Lewky\u0026#39;s github stats](https://github-readme-stats.vercel.app/api?username=lewky\u0026amp;count_private=true) show_icons=true参数用来控制是否显示图标，theme参数控制图标的风格主题，目前支持的内建主题有：dark, radical, merko, gruvbox, tokyonight, onedark, cobalt, synthwave, highcontrast, dracula。用法如下：\n1 ![Lewky\u0026#39;s github stats](https://github-readme-stats.vercel.app/api?username=lewky\u0026amp;show_icons=true\u0026amp;theme=radical) Repo Card GitHub首页只支持展示最多6个项目仓库卡片，但是通过该项目提供的Repo Card，可以轻松突破这个展示上限。用法如下：\n1 [![ReadMe Card](https://github-readme-stats.vercel.app/api/pin/?username=lewky\u0026amp;repo=lewky.github.io)](https://github.com/lewky/lewky.github.io) 效果如下：\nRepo-Card\r可以通过show_owner参数来决定是否在仓库名字前加上用户名。\nTop Languages Card 这个卡片可以展示使用最多的语言，用法如下：\n1 [![Top Langs](https://github-readme-stats.vercel.app/api/top-langs/?username=lewky)](https://github.com/lewky) 效果如下：\nTop-Languages-Card\rexclude_repo=repo1,repo2参数可以排除指定的仓库 hide=language1,language2参数可以隐藏指定的语言 langs_count=参数指定统计多少门语言 layout=compact参数可以改变卡片布局为紧密布局 Wakatime Week Stats 这个卡片用来展示每周花在不同语言上的时间记录，用法如下：\n1 [![willianrod\u0026#39;s wakatime stats](https://github-readme-stats.vercel.app/api/wakatime?username=lewky)](https://github.com/lewky) 这个卡片和GitHub没啥关系，需要另外去注册wakatime的账号，注册后会发给用户一个key，具体用法请自行百度。\n定制化 对于Stats Card和Repo Card，还可以在URL里使用以下参数来自定义图表样式。\ntitle_color - Card\u0026rsquo;s title color (hex color) text_color - Body text color (hex color) icon_color - Icons color if available (hex color) bg_color - Card\u0026rsquo;s background color (hex color) or a gradient in the form of angle,start,end hide_border - Hides the card\u0026rsquo;s border (boolean) theme - name of the theme, choose from all available themes cache_seconds - set the cache header manually (min: 1800, max: 86400) locale - set the language in the card (e.g. cn, de, es, etc.) 对于bg_color参数，甚至还支持颜色渐变：\n1 \u0026amp;bg_color=DEG,COLOR1,COLOR2,COLOR3...COLOR10 github-profile-trophy 这个是项目地址：https://github.com/ryo-ma/github-profile-trophy\n这个项目可以展示GitHub用户统计信息，并表现为一系列奖杯。用法如下：\n1 [![trophy](https://github-profile-trophy.vercel.app/?username=lewky)](https://github.com/lewky) 效果如下：\ngithub-profile-trophy\rtheme=参数可以改变主题风格：flat、onedark、gruvbox、dracula、monokai、chalk、nord、alduin、darkhub title=参数可以只显示对应名称的奖杯，比如Stars Followers Commit Repositories Issues PullRequest等，可以用英文逗号来多重指定值，如title=Stars,Followers rank=参数可以只显示对应排名的奖杯，比如SECRET SSS SS S AAA AA A B C等，可以用英文逗号来多重指定值，如rank=S,AAA column=参数可以指定一行展示多少个奖杯，默认值是6（即一行全部展示所有奖杯) row=参数可以指定最多可以用多少行展示奖杯，默认值是3（超出最大行数的奖杯会被隐藏) margin-w=参数可以改变外间距的宽度，默认值是0 margin-h=参数可以改变外间距的高度，默认值是0 有兴趣的可以去项目原地址看看更具体的说明。\n使用CDN加速GitHub的站点文件 jsdelivr为GitHub上的仓库文件做了CDN缓存，这是官方文档地址。可以通过下面的cdn地址格式来获取GitHub上的仓库文件：\n1 2 3 4 5 6 // load any GitHub release, commit, or branch https://cdn.jsdelivr.net/gh/user/repo@version/file https://cdn.jsdelivr.net/gh/user/repo@branch/file // add / at the end to get a directory listing https://cdn.jsdelivr.net/gh/jquery/jquery/ cdn缓存的更新需要等一段时间，但是可以通过下面的url来清除缓存，达到更新cdn的目的。将cdn地址中的\n1 https://cdn.jsdelivr.net/ 替换成如下的\n1 https://purge.jsdelivr.net/ 添加GitHub Profile首页展示 在GitHub上创建一个和自己id同名的项目，新建一个README.md文档，该文档将作为你的GitHub首页来展示。可以利用上文提及的各种图表、图标等开源项目来渲染GitHub首页。\n这里给个参考的例子：https://github.com/lewky/lewky\nGitHub项目趋势排行 有个项目的git pages可以看一段时间内的项目趋势排行：\nhttps://wangchujiang.com/github-rank/trending.html\n参考链接 如何为github已有仓库添加协议。 怎么在博客网站等地方引用 Github 贡献图表 刷新 Jsdelivr 缓存 ","permalink":"https://lewky.cn/posts/github-skills/","tags":["GitHub"],"title":"GitHub使用技巧"},{"categories":["计算机"],"contents":"前言 最近使用了win10系统，结果发现无法对c盘的文件进行写入删改，在网上到处搜集资料，终于找到了解决方法，这里总结一下。\n首先，本文针对的是win10家庭版，家庭版默认是不提供组策略功能，而我们需要给家庭版添加组策略功能来获取修改c盘文件的权限。\n在win10家庭版添加组策略功能 在win10家庭版通过win+R打开运行，输入gpedit.msc，回车确定，会提示说windows找不到文件'gpedit.msc'。\n我们可以自己添加组策略功能：首先新建一个txt文本，填入以下内容：\n1 2 3 4 5 6 @echo off pushd \u0026#34;%~dp0\u0026#34; dir /b %systemroot%\\Windows\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientExtensions-Package~3*.mum \u0026gt;gp.txt dir /b %systemroot%\\servicing\\Packages\\Microsoft-Windows-GroupPolicy-ClientTools-Package~3*.mum \u0026gt;\u0026gt;gp.txt for /f %%i in (\u0026#39;findstr /i . gp.txt 2^\u0026gt;nul\u0026#39;) do dism /online /norestart /add-package:\u0026#34;%systemroot%\\servicing\\Packages\\%%i\u0026#34; pause 将该txt文件保存后，修改文件后缀为.bat或者.cmd都行；或者直接将txt文件另存为所有文件类型，文件名随意，然后扩展名为.bat或者.cmd都可以。\n这里为了方便日后查找，可以将文件命名为gpedit.bat。\n接着右键以管理员身份运行这个文件，等待程序安装完毕，你会发现在该文件的目录下多出来一个gp.txt文件。这时候你再一次在cmd窗口中输入gpedit.msc，回车确定，你会发现亲爱的组策略编辑器又回来了。\n这时候你可以将gpedit.bat和gp.txt文件都删了，或者保留起来也行，它们已经完成使命，可以功成身退了。\n在组策略中禁用管理员批准模式 在cmd窗口中输入gpedit.msc，接着回车，进入组策略编辑器界面。\n在计算机配置 -\u0026gt; Windows设置 -\u0026gt; 安全设置 -\u0026gt; 本地策略 -\u0026gt; 安全选项的目录中，找到用户帐户控制: 以管理员批准模式运行所有管理员这个策略，将安全设置更改为已禁用，重启电脑后便可以随意写入删改c盘文件。\n下面附上大佬对于该选项的解释：\n用户帐户控制: 启用管理审批模式。 此策略设置控制计算机的所有用户帐户控制(UAC)策略设置行为。如果更改此策略设置，则必须重新启动计算机。 选项为:\n启用: (默认设置)启用管理审批模式。必须启用该策略并且相关的 UAC 策略设置还必须设置正确以允许内置管理员帐户以及是管理员组成员的所有其他用户在管理审批模式下运行。 禁用: 禁用管理审批模式以及所有相关 UAC 策略设置。注意: 如果禁用此策略设置，则安全中心将通知你操作系统的总体安全性已降低。 说白了就是uac关闭了，没有内置管理审批（管理），就可以随意操作电脑\n参考链接 封印解除：如何在Win10家庭版中启用组策略 Win10家庭版找不到组策略gpedit.msc怎么办 【平凡666】win 10 C盘无法写入或者删除没有权限解决办法 ","permalink":"https://lewky.cn/posts/1d8592b7.html/","tags":["计算机"],"title":"win10无法写入删改c盘文件的解决方法"},{"categories":["工作记录"],"contents":"使用公式将秒转换为分+秒 现在有个需求：将Excel里的时间转换为分+秒的格式，如下：\ntime(second) time(min+second) 482.712 XXmin,XXs 480.737 XXmin,XXs 对于这种场景，可以通过Excel的公式来实现。\n假设现在的time(second)是单元格的A1位置，我们需要对A2、A3等等这一列转换到B这一列。先在B1单元格输入以下公式：\n1 =INT(A2/60)\u0026amp;\u0026#34;min,\u0026#34;\u0026amp;ROUND(MOD(A2,60),0)\u0026amp;\u0026#34;s\u0026#34; 输入之后，你会发现该单元格的内容就变成了8min,3s。\n这里的INT(a)表示将数值a向下取整为最接近的整数，ROUND(a, b)表示按照b的位数来将a四舍五入，MOD(a, b)表示a除以b的余数，\u0026amp;表示拼接字符串。\n现在可以对一个单元格进行公式求值了，接着按住该单元格的右下角，鼠标会变成一个+号，按住不放向其它方向拖动，可以将对应的单元格自动填充该公式。\n如果希望在单元格内进行换行，在需要换行的地方按下Alt + Enter组合键即可。\n","permalink":"https://lewky.cn/posts/excel-issues/","tags":["Excel"],"title":"Excel问题汇总"},{"categories":["计算机"],"contents":"Windows类标识符 百度百科这样解释：\nWindows的类标识符class identifier也称为CLASSID或CLSID，是与某一个类对象相联系的唯一标记(UUID)。一个准备创建多个对象的类对象应将其CLSID注册到系统注册数据库的任务表中，以使客户能够定位并装载与该对象有关的可执行代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 回收站.{645ff040-5081-101b-9f08-00aa002f954e} 回收站(满).{5ef4af3a-f726-11d0-b8a2-00c04fc309a4} 拨号网络.{992CFFA0-F557-101A-88EC-00DD010CCC48} 打印机.{2227a280-3aea-1069-a2de-08002b30309d} 控制面板.{21ec2020-3aea-1069-a2dd-08002b30309d} 网上邻居.{208D2C60-3AEA-1069-A2D7-08002B30309D} 图标clsid=windowsmedia 文件名.{00020c01-0000-0000-c000-000000000046} 无关联文件 文件名.{00021401-0000-0000-c000-000000000046} BMP文件 文件名.{d3e34b21-9d75-101a-8c3d-00aa001a1652} HTML文件 文件名.{25336920-03f9-11cf-8fd0-00aa00686f13} 媒体剪辑文件 文件名.{00022601-0000-0000-c000-000000000046} 计划任务 文件名.{D6277990-4c6a-11cf-8d87-00aa0060f5bf} Web文件夹 文件名.{Bdeadf00-C265-11d0-Bced-00a0c90ab50f} 历史记录 文件名.{Ff393560-C2a7-11cf-Bff4-444553540000} 收藏夹 文件名.{1a9ba3a0-143a-11cf-8350-444553540000} 预订文件夹 文件名.{F5175861-2688-11d0-9c5e-00aa00a45957} ActiveX高速缓存文件夹文件名.{88c6c381-2e85-11d0-94de-444553540000} excel.{00020810-0000-0000-C000-000000000046} word.{00020900-0000-0000-C000-000000000046} media.{00022603-0000-0000-C000-000000000046} CAB.{0CD7A5C0-9F37-11CE-AE65-08002B2E1262} 搜索-计算机.{1f4de370-d627-11d1-ba4f-00a0c91eedba} mht.{3050F3D9-98B5-11CF-BB82-00AA00BDCE0B} mshta.{3050f4d8-98B5-11CF-BB82-00AA00BDCE0B} 我的文档.{450D8FBA-AD25-11D0-98A8-0800361B1103} XML.{48123bc4-99d9-11d1-a6b3-00c04fd91555} ftp_folder.{63da6ec0-2e98-11cf-8d82-444553540000} 网络和拨号连接.{7007ACC7-3202-11D1-AAD2-00805FC1270E} 写字板文档.{73FDDC80-AEA9-101A-98A7-00AA00374959} Temporary Offline Files Cleaner.{750fdf0f-2a26-11d1-a3ea-080036587f03} 用户和密码.{7A9D77BD-5403-11d2-8785-2E0420524153} Internet 临时文件.{7BD29E00-76C1-11CF-9DD0-00A0C9034933} 已下载的程序文件的清除程序.{8369AB20-56C9-11D0-94E8-00AA0059CE02} 公文包.{85BBD920-42A0-1069-A2E4-08002B30309D} mail.{9E56BE60-C50F-11CF-9A2C-00A0C90A90CE} 目录.{fe1290f0-cfbd-11cf-a330-00aa00c16e65} Internet Explorer.{FBF23B42-E3F0-101B-8488-00AA003E56F8} Snapshot File.{FACB5ED2-7F99-11D0-ADE2-00A0C90DC8D9} MyDocs Drop Target.{ECF03A32-103D-11d2-854D-006008059367} Policy Package.{ecabaebd-7f19-11d2-978E-0000f8757e2a} 搜索结果.{e17d4fc0-5564-11d1-83f2-00a0c90dc849} 添加网上邻居.{D4480A50-BA28-11d1-8E75-00C04FA31A86} Paint.{D3E34B21-9D75-101A-8C3D-00AA001A1652} 管理工具.{D20EA4E1-3957-11d2-A40B-0C5020524153} 字体.{D20EA4E1-3957-11d2-A40B-0C5020524152} Web Folders.{BDEADF00-C265-11d0-BCED-00A0C90AB50F} DocFind Command.{B005E690-678D-11d1-B758-00A0C90564FE} 脱机文件夹.{AFDB1F70-2A4C-11d2-9039-00C04F8EEB3E} Internet Explorer.{871C5380-42A0-1069-A2EA-08002B30309D} 上帝模式/完全控制面板.{ED7BA470-8E54-465E-825C-99712043E01C} 使用用法 虽然上边的说明和内容会让人一脸懵逼，但还是有几种很简单的使用方法。\nRM皮肤Rainmeter Skin 在RM的皮肤中有些插件会使用到这些类标识符来打开对应的应用，比如经典的蜂窝桌面，就可以通过使用上边的类标识符，就和快捷方式差不多。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 [Button.10] Meter=BUTTON X=352 Y=#DockY# W=70 H=30 ButtonImage=Dock.png ButtonCommand=!execute [\u0026#34; ::{20D04FE0-3AEA-1069-A2D8-08002B30309D} \u0026#34;] [10.p] Meter=STRING X=35r Y=5r W=70 H=22 StringStyle=BOLD FontColor=#FontColor.W# FontSize=#FontHeight# FontFace=#FontName# AntiAlias=#AntiAlias# stringAlign=#dAligen# Text=\u0026#34;我的电脑\u0026#34; 需要注意的是，在Rainmeter中使用这些类标识符的时候，需要在前边加上两个英文的冒号。\n上帝模式/完全控制面板 电脑的“上帝模式”即“God Mode”，从Windows Vista开始，微软在Windows系统中隐藏了一个集成了系统所有设置项的“上帝模式(God Mode)”。到了Win10系统，这个神秘而强大的“上帝模式(God Mode)”仍然保留着。\n上帝模式就是全部功能展示模式，因为功能太强大，所以被戏称为“上帝模式”。它还有一个通俗的名称叫“完全控制面板”，因为它包含了几乎所有Windows系统的设置。\n有两种打开方式，一种是Win+R组合建打开运行框，输入shell:::{ED7BA470-8E54-465E-825C-99712043E01C}，回车确定后就会打开完全控制面板。除了可以用运行框来打开上帝模式，也可以自己修改成其他的类标识符来打开对应的系统应用。\n另一种方式和下边说的伪装文件夹的使用方法一样。\n改头换面，伪装文件夹 新建一个文件夹，将文件夹命名为xxx.{645ff040-5081-101b-9f08-00aa002f954e}这种格式的名字。这样前边的xxx会变成文件夹的名字，后边的.{xxxx}则会被自动隐藏。此时该文件夹会变成类标识符对应的Windows系统应用图标，双击打开该文件夹也会打开对应的系统应用。这样就起到了伪装并隐藏原本文件夹的作用，效果类似于以前的图种(就是利用一张图片来隐藏实际的文件，比如神秘链接什么的)。\n以前的一些恶意广告插件就是通过这种方法进行IE劫持，在桌面新建一个Internet Explorer.{871C5380-42A0-1069-A2EA-08002B30309D}名字的文件夹，这样该文件夹就会变成IE浏览器的应用。\n怎么破解伪装的文件夹 不同电脑在使用上边的方法去伪装文件夹的时候，有的类标识符可能没有效果，不过一般使用垃圾桶、网上邻居之类的类标识符是没问题的。那么对于这种伪装了的文件夹，要怎么破解呢？\n有两种方法，这两种方法都需要安装WinRAR之类的的解压缩软件才可以使用。\n方法一 直接右键点击伪装的文件夹，选择打开，这样就可以直接看到被隐藏起来的文件夹内的文件。这实际上是解压缩软件把该文件夹当成压缩文件来打开了。但是并不是所有被伪装的文件夹都可以使用这种方法，比如伪装成了网上邻居的文件夹，就无法用这种方法。\n方法二 打开任意一个压缩包，在当前的压缩包查看界面将地址栏的目录改成被伪装的文件夹的父目录，这样你就会发现伪装的文件夹的名字变成了包含类标识符的全名。选定该被伪装的文件夹，按F2改名字，将类标识符去掉，改成普通的文件夹名字。\n这时候再重新查看这个被伪装的文件夹，已经变回了正常的文件夹。\n参考链接 Windows类标识符 百度百科 妙用Windows神秘的类标识符 【技术交流】妙用Windows神秘的类标识符 厉害了，win 10居然有上帝模式？ ","permalink":"https://lewky.cn/posts/a7d10acb.html/","tags":["计算机","类标识符"],"title":"Windows类标识符及其妙用"},{"categories":["杂谈"],"contents":"问题 在win10平台安装了MarkdownPad 2之后，发现在渲染md文件时报错，在预览页面无法正常渲染HTML： markdownpad_error.jpg\r安装报错提示前往官网，可以看到如下的解决方法：\nLivePreview is not working - it displays an error message stating This view has crashed! This issue has been specifically observed in Windows 8. You may see an error message as shown here, and no HTML will be rendered when you type in the Markdown Editor pane.\nTo fix this issue, please try installing the Awesomium 1.6.6 SDK.\nIf you continue to experience issues, please install Microsoft\u0026rsquo;s DirectX End-User Runtimes (June 2010).\n解决方法 请尝试安装Awesomium 1.6.6 SDK，下载链接：awesomium_v1.6.6_sdk_win.zip 在安装之后依然有这个问题，请安装Microsoft\u0026rsquo;s DirectX End-User Runtimes (June 2010) 参考链接 Frequently Asked Questions 升级win10后 MarkdownPad 2 无法实时渲染HTML页面问题 ","permalink":"https://lewky.cn/posts/511045a6.html/","tags":["MarkdownPad2"],"title":"MarkdownPad - win10环境下无法渲染HTML问题"},{"categories":["Java"],"contents":"问题与分析 我在本地安装了1.7和1.8两个版本的jdk，此时我的JAVA_HOME环境变量配置的是jdk1.8，在cmd窗口输入java -version发现报错如下：\n1 2 3 4 5 C:\\Users\\Lewis\u0026gt;java -version Error: Registry key \u0026#39;Software\\JavaSoft\\Java Runtime Environment\u0026#39;\\CurrentVersion\u0026#39; has value \u0026#39;1.8\u0026#39;, but \u0026#39;1.7\u0026#39; is required. Error: could not find java.dll Error: Could not find Java SE Runtime Environment. 接着输入javac -version则是正常：\n1 2 C:\\Users\\Lewis\u0026gt;javac -version javac 1.8.0_191 javac命令能正常执行， 说明我配置的CLASSPATH变量和JAVA_HOME变量正确。而java命令报错，则说明PATH变量有问题。cmd窗口在执行命令时会去PATH变量的值里寻找路径，当找到对应的路径后就不会再继续查找下去。\n所以我们应该把java相关的路径放到PATH变量值的最前面，需要注意的是，如果你安装了Oracle，你会发现Oracle的环境变量会直接排到最前面，也就是说，这时候会优先去Oracle指定的目录下寻找java的命令。\n但只是将java路径放置到最前面还是不够的，因为WINDOW本身系统SYSTEM32里面的环境变量加载等级要优先于用户设置的环境变量，所以我们还需要将C:\\Windows\\System32目录下的java.exe、javaw.exe、javaws.exe三个程序删掉或者重命名才行。\n解决方案 将PATH环境变量的变量值里的java路径放置到最前面； 将C:\\Windows\\System32目录下的java.exe、javaw.exe、javaws.exe三个程序删掉或者重命名。 接下来进行测试，会发现java -version得到了正确的结果：\n1 2 3 4 C:\\Users\\Lewis\u0026gt;java -version java version \u0026#34;1.8.0_191\u0026#34; Java(TM) SE Runtime Environment (build 1.8.0_191-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.191-b12, mixed mode) 接着将JAVA_HOME改为jdk1.7的目录，再一次测试java和javac命令，都能得到正确的结果。\n参考链接 切换JDK版本时修改JAVA_HOME环境变量不生效 ","permalink":"https://lewky.cn/posts/java-%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%9D%A5%E5%88%87%E6%8D%A2jdk%E7%89%88%E6%9C%AC.html/","tags":["Java"],"title":"Java - 怎么通过环境变量来切换jdk版本"},{"categories":["Java"],"contents":"前言 双十一买了台新的笔记本，需要重新安装下Java，这里记录下安装的过程，毕竟万事开头难，就算是老手也不一定能一次就把Java安装成功。\n安装jdk 作为一名Java开发，当然是要安装jdk了，如果只是需要Java的运行环境，那么安装jre就足够了。另外说下，jdk里以及包含了jre了。\n首先去官网下载Java，由于Sun被Oracle收购了，现在去官网下载Java需要先注册一个Oracle账号，虽然麻烦了点，但是没办法，谁叫Oracle牛逼呢。\n由于页面是全英文的，部分同学可能会懵逼，其实没什么，随便找一个版本下载就行。唯一需要注意的是，下载文件之前要先点击一下文件上方的同意协议，否则会提示你还没有同意协议。\n接着把下载好的文件启动，一路按照默认配置安装即可。当安装好jdk后，接下来的步骤就是配置环境变量了。不夸张的说，99%的同学都曾经倒在了环境变量的配置上，甚至直接就放弃安装Java了。\n配置环境变量 环境变量其实就是定义给系统使用的变量，当使用到这些变量时，会自动替换成对应的路径名，以便找到程序或者命令。而环境变量分为用户变量和系统变量，顾名思义，用户变量是给当前的电脑用户使用的，系统变量是所有用户公用的。我们只要配置成用户变量就行，如果你想定义成系统变量也没问题。\n配置Java的环境变量其实很简单，一共就三个环境变量：\nJAVA_HOME PATH CLASSPATH 注意，所有环境变量的变量值都是使用的英文符号！！别写成中文的分号、冒号等符号了！！\nJAVA_HOME 这个变量名指的是Java的安装路径，其实很多程序在安装的时候，都会自动给你新建一个对应的环境变量XXX_HOME。不过Java并没有自动给我们新建该变量，所以需要我们自己来创建。另外很多程序，比如Eclipse、Maven、Tomcat等等，都会使用到这个变量。\n新建一个环境变量JAVA_HOME，然后在变量值里输入你的jdk安装路径，比如我的是C:\\Program Files\\Java\\jdk1.7.0_80。\nPATH 这个变量是系统本身就有的，当你在cmd窗口里执行命令的时候就会去这个PATH变量里找到对应的路径，如果找不到就会报错。这一步我们需要在PATH的变量值里加上%JAVA_HOME%\\bin;%JAVA_HOME%\\jre\\bin，最好是将这段变量值加在最前面，如果是加在最前面，还需要在末尾加上英文的分号。\nCLASSPATH 这个变量需要我们新建，变量名是CLASSPATH，变量值是.;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar，请别在变量值的末尾画蛇添足加上分号。\n该变量的作用是用来寻找类文件的路径，如果该变量值不对，就会导致javac命令找不到的错误。\n测试jdk和环境变量 java -version win+R打开运行程序，输入cmd接着回车，在cmd窗口里输入java -version，正常的情况是能得到类似如下的信息：\n1 2 3 4 C:\\Users\\Lewis\u0026gt;java -version java version \u0026#34;1.7.0_80\u0026#34; Java(TM) SE Runtime Environment (build 1.7.0_80-b15) Java HotSpot(TM) 64-Bit Server VM (build 24.80-b11, mixed mode) javac -version 在cmd窗口里输入javac -version，正常的情况是能得到类似如下的信息：\n1 2 C:\\Users\\Lewis\u0026gt;javac -version javac 1.7.0_80 这两个命令的区别是，前者是用来执行java程序或者命令的，后者是用来编译java文件的。javac就是指的java compiler。\nwin10下的环境变量问题 如果是win10，在配置环境变量时，一般是弹出表格，然后一行一行地输入变量值，而不是像上边那样需要使用英文分号来分隔开。有可能会发生配置好环境变量后，在输入java -version能得到正常的结果，而在输入javac -version后却是显示的：\n1 2 3 C:\\Users\\Lewis\u0026gt;javac -version \u0026#39;javac\u0026#39; 不是内部或外部命令，也不是可运行的程序 或批处理文件。 解决办法很简单，先检查你的JAVA_HOME是否路径正确，是否使用了错误的中文符号等；接着检查另外两个变量是否书写正确。因为win10第一次配置环境变量时是一行一行地在表格里输入的，后面重新打开的时候就变回了win7/8那种格式，你会发现CLASSPATH变量的变量值莫名被加上了双引号(我本人就是属于这种情况)，把双引号去掉后重新保存环境变量；接着关闭原本的cmd窗口，重新打开cmd窗口进行测试，测试成功。\n如果依然是一行一行输入变量值的表格形式，需要把分号去掉，然后分成多行各自输入，且末尾不能有英文分号，另外最好把变量值上移到顶端。\n注意，如果改变了环境变量，必须要把原本的cmd窗口关掉才行，因为原本的cmd窗口依然使用的是你修改之前的环境变量。\n参考链接 java 安装教程 window10下java环境变量的配置 javac不是内部或外部命令的问题 ","permalink":"https://lewky.cn/posts/4c4c677.html/","tags":["Java","安装教程"],"title":"Java - 安装jdk并设置环境变量"},{"categories":["cmd"],"contents":"前言 最近在cmd中使用curl命令来测试rest api，发现有不少问题，这里记录一下。\n在cmd中使用curl命令的注意事项 json不能由单引号包括起来 json数据里的双引号要用反斜杠\\转义 json数据里不能带有空格 如果想要在json数据里使用空格则必须用双引号将整个json数据包括起来 Content-type要由双引号包括起来 比如下边的例子就是正确的格式：\n1 curl -X POST localhost:8080/employees -H \u0026#34;Content-type:application/json\u0026#34; -d \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;Samwise Gamgee\\\u0026#34;, \\\u0026#34;role\\\u0026#34;: \\\u0026#34;gardener\\\u0026#34;}\u0026#34; 总的来说，还是用postman来测试rest api方便快捷。\n参考链接 使用curl post json到webApi ","permalink":"https://lewky.cn/posts/2ed0604f.html/","tags":["cmd","工作记录"],"title":"cmd - 使用curl命令的注意点"},{"categories":["Java"],"contents":"问题分析 Java是向下兼容的，每一个jdk版本都有对应的class版本号(major + minor version numbers)；如果用低版本的jvm去加载高版本jdk编译的类，就会报错：java.lang.UnsupportedClassVersionError\n源码中关于这个UnsupportedClassVersionError的注释如下：\n1 2 3 4 5 6 7 /** * Thrown when the Java Virtual Machine attempts to read a class * file and determines that the major and minor version numbers * in the file are not supported. * * @since 1.2 */ Java版本对应的Class版本号 Java版本 Class版本 JDK1.0.2 45.0~45.3 JDK1.1 45.0~46.0以下 J2SE1.2 46.0 J2SE1.3 47.0 J2SE1.4 48.0 JavaSE5 49.0 JavaSE6 50.0 JavaSE7 51.0 JavaSE8 52.0 解决方法 把类重新用当前的jdk版本去编译，只要确保jvm的版本比类版本号相同或更高就可以了。\n参考链接 Class版本号和Java版本对应关系 ","permalink":"https://lewky.cn/posts/fd82a4a.html/","tags":["Java"],"title":"Java - Class版本号和UnsupportedClassVersionError"},{"categories":["Java"],"contents":"前言 最近老大让我修改项目里所有和log有关的代码，之前我也用过log4j、slf4j或者Logback等日志框架/接口，一直以为打印异常信息就是简单地一句log.info()或者log.error()而已，没想到原来一直都使用错了，以至于有些错误信息没能在log文件中打印出堆栈信息，最终难以定位bug，排查困难。\n如何正确地打印异常的堆栈信息？ 一般在catch到异常的时候，不要使用e.printStackTrace()来打印异常信息。我们使用日志框架来打印信息，一般来说，日志框架的log级别从低到高是：debug, info, warn, error, fatal。\n对于异常，一般使用log.error()来打印堆栈信息。下边的三个log语句都打印了异常，但是写法却不一样，打印出来的效果也是不同的：\n1 2 3 log.error(\u0026#34;ERROR\u0026#34;, \u0026#34;Error found: \u0026#34;, e); log.error(\u0026#34;ERROR\u0026#34;, \u0026#34;Error found: \u0026#34; + e.getMessage()); log.error(\u0026#34;ERROR\u0026#34;, \u0026#34;Error found: \u0026#34; + e); 以下边的代码为例：\n1 2 3 4 5 6 7 try { System.out.println(1/0); } catch (final Exception e) { log.error(\u0026#34;ERROR\u0026#34;, \u0026#34;Error found: \u0026#34;, e); log.error(\u0026#34;ERROR\u0026#34;, \u0026#34;Error found: \u0026#34; + e.getMessage()); log.error(\u0026#34;ERROR\u0026#34;, \u0026#34;Error found: \u0026#34; + e); } 在log文件中可以发现输出是这样的：\n1 2 3 4 5 2018-11-09 11:46:34,834 main ERROR com.lewis.test.TestLewis - Message: ERROR; Description: Error found: java.lang.ArithmeticException: / by zero at com.lewis.test.TestLewis.main(TestLewis.java:46) 2018-11-09 11:46:34,837 main ERROR com.lewis.test.TestLewis - Message: ERROR; Description: Error found: / by zero 2018-11-09 11:46:34,838 main ERROR com.lewis.test.TestLewis - Message: ERROR; Description: Error found: java.lang.ArithmeticException: / by zero 对于第一个log语句，可以看到堆栈信息被打印了出来。 对于第二个log语句，只是打印出了异常的具体信息，既没有异常类名，也没有堆栈信息。 对于第三个log语句，打印出了异常的类名和具体信息，但是没有打印出来堆栈信息。\n总结一下，就是我们应该使用第一种log语句的形式来将堆栈信息打印出来，方便日后定位bug，排除错误。\n","permalink":"https://lewky.cn/posts/ea188909.html/","tags":["Java"],"title":"如何正确地打印异常堆栈信息"},{"categories":["Redis"],"contents":"Redis 本身支持16个数据库(0~15)，通过数据库id设置，默认为0。在Windows平台下可以通过启动redis-cli.exe来进入客户端，客户端默认连接数据库0，在客户端里可以输入各种命令。\n增加db数量 可以通过修改配置来增加Redis的db数量。在Windows平台下，打开redis.windows.conf，找到databases 16并修改即可。\n切换db 通过命令来切换当前的db：select 0，该命令表示切换到第一个数据库。数据库id是从0到15，可以自由切换db，每个db的存储空间是不一样的。\n当切换db成功时，可以看到当前是使用的哪一个db：\n1 2 3 127.0.0.1:6379\u0026gt; SELECT 2 OK 127.0.0.1:6379[2]\u0026gt; 清理当前db数据 1 flushdb 该命令只会清理当前db的数据，不会影响到其他db。\n清理所有db数据 1 flushall 该命令会将当前的Redis实例的所有数据都清理掉，慎用！\n参考链接 redis 中如何切换db ","permalink":"https://lewky.cn/posts/b6751edd.html/","tags":["Redis"],"title":"Redis - Windows平台下怎么切换db并且清理数据"},{"categories":["中间件"],"contents":"Tomcat日志文件的输出在Linux和Windows下的差异 最近发现Tomcat的日志文件catalina.out里存在着大量和公司项目相关的日志信息，因为一般都是会使用日志框架将日志信息输出到另外的文件里，catalina.out文件里是不需要这些多余的日志信息的。\n不过我在测试的时候发现，Linux和Windows下catalina.out文件的输出是有区别的。\n在Windows平台下，所有System.out(), System.err()以及printStackTrace()输出的日志信息都会在Tomcat的控制台console（即通过startup.bat启动的命令行窗口）里输出，但是并不会被输出到catalina.out里。\n而在Linux平台，上述的api会把信息输出到catalina.out里。而企业项目一般都是部署在Linux平台上的，日积月累之下catalina.log文件将会变得异常庞大，拖累系统性能，也不利于定位bug，可以通过修改日志配置文件改变存储策略。\n如何使用Tomcat自带的日志实现tomcat-juli.jar 配置文件logging.properties Tomcat自带的日志实现是tomcat-juli.jar，它是对默认的JDK日志java.util.logging进行一定的封装，和标准JDK日志支持相同的配置，但是和log4j等常用的日志框架比起来功能要较为简陋。不过tomcat-juli可以针对不同的classloader来使用不同的配置文件，使得tomcat下不同的Web应用程序可以使用各自独立的日志文件。\n如果我们想在代码中使用Tomcat自带的日志实现，也很简单，首先拿到tomcat-juli.jar。该jar包存在于Tomcat安装目录下的lib下，或者你可以直接在Maven仓库里选择你想要的版本去下载。\n接着新建一个java项目，导入该jar包，然后在根目录下新建一个配置文件logging.properties。\n这个是tomcat-juli使用的配置文件，一个简单的配置如下：\n1 2 3 4 5 6 handlers= java.util.logging.ConsoleHandler .level= INFO java.util.logging.ConsoleHandler.level = INFO java.util.logging.ConsoleHandler.formatter = java.util.logging.SimpleFormatter com.lewis.test.TestLewis.level = SEVERE 这里简单解释下，第一行表示使用ConsoleHandler来处理打印日志，用来将信息打印到控制台。\n第二行表示输出的日志级别是INFO，可以在level前加上任意类名或者完整的包名，用于精准控制类/包的日志级别，譬如第三行。\n第四行表示输出的日志信息日期格式。\n更多具体的配置可以去看看Tomcat的conf目录下的logging.properties，里边有很多配置和注释。\n另外提一下，tomcat-juli的日志级别和log4j等是不一样的，其级别如下：\n1 SEVERE (highest value) \u0026gt; WARNING \u0026gt; INFO \u0026gt; CONFIG \u0026gt; FINE \u0026gt; FINER \u0026gt; FINEST (lowest value) 此外：\n如果希望不打印日志信息，可以将level设置为OFF。 如果希望打印全部的日志信息，可以将level设置为ALL。 测试类 测试类的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package com.lewis.test; import java.io.NotSerializableException; import java.util.logging.Level; import java.util.logging.Logger; public class TestLewis { private static Logger LOGGER; static { System.setProperty(\u0026#34;java.util.logging.config.file\u0026#34;, \u0026#34;D:\\\\lewis\\\\workspace\\\\test\\\\src\\\\main\\\\resources\\\\logging.properties\u0026#34;); //must initialize loggers after setting above property LOGGER = Logger.getLogger(TestLewis.class.getName()); } public static void main(final String[] args) { System.out.println(\u0026#34;----System.out----\u0026#34;); System.err.println(\u0026#34;----System.err----\u0026#34;); LOGGER.info(\u0026#34;an info msg\u0026#34;); LOGGER.warning(\u0026#34;a warning msg\u0026#34;); LOGGER.severe(\u0026#34;a severe msg\u0026#34;); LOGGER.log(Level.INFO, \u0026#34;test1: a info msg\u0026#34;, new NotSerializableException()); LOGGER.log(Level.WARNING, \u0026#34;test1: a warning msg\u0026#34;, new NotSerializableException()); LOGGER.log(Level.SEVERE, \u0026#34;test1: a severe msg\u0026#34;, new NotSerializableException()); } 这里需要注意的是，tomcat-juli的打印语句也是不太一样的，如果需要打印出具体的堆栈信息就必须自己指定日志级别，如果使用自带的日志级别打印语句诸如.info()等，只能打印出字符串，不能打印出堆栈信息。\n还有就是必须在代码的一开始就指定加载配置文件，通过System.setProperty(\u0026quot;java.util.logging.config.file\u0026quot;,\r\u0026quot;配置文件的路径\u0026quot;);。如果没有这一步，你会发现你的配置文件根本没有效果。如果你去Tomcat的bin目录下的catalina.bat可以发现，里边也是配置了这个参数：\n1 set LOGGING_CONFIG=-Djava.util.logging.config.file=\u0026#34;%CATALINA_BASE%\\conf\\logging.properties\u0026#34; 测试类输出结果如下：\n1 2 3 4 5 6 7 8 ----System.out---- ----System.err---- Dec 07, 2018 5:56:04 PM com.lewis.test.TestLewis main SEVERE: a severe msg Dec 07, 2018 5:56:05 PM com.lewis.test.TestLewis main SEVERE: test1: a severe msg java.io.NotSerializableException at com.lewis.test.TestLewis.main(TestLewis.java:75) ClassFormatException 在使用Tomcat7运行web项目时报错如下：\n1 2 3 严重: Compilation error org.eclipse.jdt.internal.compiler.classfmt.ClassFormatException at .... 原因是Tomcat7和jdk8存在着不兼容的情况，Tomcat通过ecj.jar来编译jsp，这个ecj是Eclipse自己开发和使用的针对Java的编译器。\necj即the Eclipse Compiler for Java，Eclipse并没有使用JDK自带的编译器，而是使用自己开发的ecj编译器，而ecj也通过了java的验证。除了Eclipse之外，Tomcat也用到了ecj，用于动态编译jsp文件，可以在Tomcat的lib目录下找到该jar包。\n而这个ClassFormatException，就是因为Tomcat7使用的ecj.jar版本比较低，里边使用的是较低版本的jdk，导致无法在jdk8的环境下去编译jsp文件。\n解决方案一 既然是Tomcat7和jdk8不兼容导致的，那么我们只要使用Tomcat8或者jdk7自然就没这个问题了。如果希望还是使用Tomcat7和jdk8来运行项目，就需要使用方案二了。\n解决方案二 将Tomcat7的lib目录下的ecj.jar换成Tomcat8里边的ecj.jar，比如说将ecj3.7.2换成ecj.4.4.2，这样就可以让Tomcat7和jdk8兼容了。如果你懒得去下载Tomcat8然后获取里边的高版本ecj.jar，可以去Maven中央仓库获取对应版本的ecj.jar：https://mvnrepository.com/artifact/org.eclipse.jdt.core.compiler/ecj\njvisualvm远程监控Tomcat应用 首先需要给Tomcat的启动文件/bin/startup.sh添加远程监控的启动参数，可以在CATALINA_OPTS里添加：\n1 2 3 4 5 6 7 8 export CATALINA_OPTS=\u0026#34;$CATALINA_OPTS -Dcom.sun.management.jmxremote -Djava.rmi.server.hostname=192.168.1.130 -Dcom.sun.management.jmxremote.port=7003 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password -Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access\u0026#34; 各参数解释如下：\n1 2 3 4 5 6 7 -Dcom.sun.management.jmxremote // 启用JMX远程监控 -Djava.rmi.server.hostname=192.168.1.130 // 这是连接你的Tomcat服务器地址 -Dcom.sun.management.jmxremote.port=7003 // jmx连接端口 -Dcom.sun.management.jmxremote.ssl=false // 是否ssl加密 -Dcom.sun.management.jmxremote.authenticate=true // 远程连接需要密码认证，如果配置成false则不需要配置下面的访问和密码两个参数 -Dcom.sun.management.jmxremote.password.file=../conf/jmxremote.password // 指定连接的用户名和密码配置文件 -Dcom.sun.management.jmxremote.access.file=../conf/jmxremote.access // 指定连接的用户所拥有权限的配置文件 然后添加对应的配置文件/conf/jmxremote.access，配置上需要远程连接的用户名和权限：\n1 2 monitorRole readonly controlRole readwrite 在/conf/jmxremote.password里配置对应的用户名和密码：\n1 2 monitorRole test controlRole dev 然后修改这两个配置文件的权限：\n1 sudo chmod 600 jmx* 最后重启Tomcat即可生效，本地环境只需要打开$JAVA_HOME/bin/jvisualvm.exe即可远程监控：在远程选项上添加Tomcat所在的主机，输入刚刚配置的用户和密码即可。\n参考链接 Tomcat日志输出在linux和windows差异 Tomcat日志系统详解 jdk1.8+Tomcat7.0小版本无法兼容问题解决 jvisualvm远程监控tomcat ","permalink":"https://lewky.cn/posts/tomcat-issues/","tags":["Tomcat","工作记录"],"title":"Tomcat问题汇总"},{"categories":["前端"],"contents":"AngularJS四大特效 MVC模式、模块化设计、自动化双向数据绑定、依赖注入\n如果了解了后端开发知识，想必对这些词汇不会陌生，AngularJS融合了后端开发的一些思想，虽然身为前端框架，但与jQuery框架却是完全不相同的东西。\nAngularJS分为几个模块，需要使用哪个模块的功能，就直接引入对应的模块，这种模块化设计具备高内聚、低耦合的特点。 官方提供的模块有：ng、ngRoute、ngAnimate 用户也可以自定义模块：angular.module(\u0026lsquo;模块名\u0026rsquo;, []) 这里的ng是引擎engine的缩写，类似于Nginx的Ngin也是engine的缩写(谐音？)\nDemo1 - 表达式 在当前目录下新建一个demo-1.html文件，并将angular.min.js文件放置在同一目录下。\n1 2 3 4 5 6 7 8 9 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;AngularJS入门小Demo-1 表达式\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;angular.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body ng-app\u0026gt; {{100+100}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 通过在html中引入angular.min.js，并在body标签中加入ng-app指令，则会对{% raw %}{{}}{% endraw %}里的表达式进行计算。双击打开这个html文件，会发现页面显示的是200，如果不加载ng-app指令，页面显示的则是{% raw %}{{100+100}}{% endraw %}。\nDemo2 - 双向绑定 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;AngularJS入门小Demo-2 双向绑定\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;angular.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body ng-app\u0026gt; 请输入姓名：\u0026lt;input ng-model=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 请输入姓名：\u0026lt;input ng-model=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br\u0026gt; {{name}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 通过ng-model来绑定变量，双击上边的页面文件，在任意一个输入框中输入字符，都会影响到绑定同一变量的标签元素。比起用js或者jQuery来实现这个功能，AngularJS的写法要简单快捷很多。\nDemo3 - 初始化指令 1 2 3 4 5 6 7 8 9 10 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;AngularJS入门小Demo-3 初始化指令\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;angular.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body ng-app ng-init=\u0026#34;name=\u0026#39;JOJO\u0026#39;\u0026#34;\u0026gt; 请输入姓名：\u0026lt;input ng-model=\u0026#34;name\u0026#34;\u0026gt;\u0026lt;br\u0026gt; {{name}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 通过ng-init指令来对变量进行初始化，比如上边的html页面，在打开或刷新后，name变量的值会被初始化为JOJO。\nDemo4 - 控制器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;AngularJS入门小Demo-4 控制器\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;angular.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; //建立模块 //第一个参数是自定义的模块名，第二个参数是引用的模块名 var app = angular.module(\u0026#34;myApp\u0026#34;, []); //创建控制器 app.controller(\u0026#34;myController\u0026#34;, function($scope){ $scope.add = function() { return parseInt($scope.x) + parseInt($scope.y); } }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body ng-app=\u0026#34;myApp\u0026#34; ng-controller=\u0026#34;myController\u0026#34;\u0026gt; 第一个数：\u0026lt;input ng-model=\u0026#34;x\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 第二个数：\u0026lt;input ng-model=\u0026#34;y\u0026#34;\u0026gt; 结果：{{add()}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 自定义一个模块，为模块创建一个控制器，控制器里可以定义一些逻辑来处理绑定的变量。这里的控制器也有个参数$scope，这个参数表示作用域，可以通过该作用域来获取操作变量，它就是视图层和控制层交互数据的桥梁。\n更多和$scope相关的，可以了解下这篇文章关于AngularJS学习整理\u0026mdash;浅谈$scope(作用域) 新手必备！。\nDemo5 - 事件指令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;AngularJS入门小Demo-5 事件指令\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;angular.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; //建立模块 //第一个参数是自定义的模块名，第二个参数是引用的模块名 var app = angular.module(\u0026#34;myApp\u0026#34;, []); //创建控制器 app.controller(\u0026#34;myController\u0026#34;, function($scope){ $scope.add = function() { return $scope.z = parseInt($scope.x) + parseInt($scope.y); } }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body ng-app=\u0026#34;myApp\u0026#34; ng-controller=\u0026#34;myController\u0026#34;\u0026gt; 第一个数：\u0026lt;input ng-model=\u0026#34;x\u0026#34;\u0026gt;\u0026lt;br\u0026gt; 第二个数：\u0026lt;input ng-model=\u0026#34;y\u0026#34;\u0026gt; \u0026lt;button ng-click=\u0026#34;add()\u0026#34;\u0026gt;运算\u0026lt;/button\u0026gt;\u0026lt;br\u0026gt; 结果：{{z}} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ng-click表示事件指令，类似于js里的绑定事件的用法。\nDemo6 - 循环数组 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;AngularJS入门小Demo-6 循环数组\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;angular.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; //建立模块 //第一个参数是自定义的模块名，第二个参数是引用的模块名 var app = angular.module(\u0026#34;myApp\u0026#34;, []); //创建控制器 app.controller(\u0026#34;myController\u0026#34;, function($scope){ $scope.list = [101, 252, 345, 836]; }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body ng-app=\u0026#34;myApp\u0026#34; ng-controller=\u0026#34;myController\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr ng-repeat=\u0026#34;x in list\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{x}}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用ng-repeat来循环数组，类似于foreach的遍历操作。\nDemo7 - 循环对象数组(JSON) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;AngularJS入门小Demo-7 循环对象数组\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;angular.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; //建立模块 //第一个参数是自定义的模块名，第二个参数是引用的模块名 var app = angular.module(\u0026#34;myApp\u0026#34;, []); //创建控制器 app.controller(\u0026#34;myController\u0026#34;, function($scope){ $scope.list = [ {name:\u0026#39;张三\u0026#39;, math:99, chinese:88}, {name:\u0026#39;李四\u0026#39;, math:17, chinese:46}, {name:\u0026#39;赵五\u0026#39;, math:60, chinese:60} ]; }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body ng-app=\u0026#34;myApp\u0026#34; ng-controller=\u0026#34;myController\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;姓名\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;学科\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;分数\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr ng-repeat=\u0026#34;entity in list\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{entity.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{entity.math}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{entity.chinese}}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 实际应用中前后端一般通过JSON对象来交互，和上边的demo类似。\nDemo8 - 内置服务$http 前端数据一般从后端获得，我们一般使用AngularJS的内置服务$http来获取后端数据，下边的demo需要在容器中运行(比如Tomcat)。\n首先建立一个demo-8.html文件，将页面和angular.min.js一起放置到web项目的webapp目录下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;AngularJS入门小Demo-8 内置服务$http\u0026lt;/title\u0026gt; \u0026lt;script src=\u0026#34;angular.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; //建立模块 //第一个参数是自定义的模块名，第二个参数是引用的模块名 var app = angular.module(\u0026#34;myApp\u0026#34;, []); //创建控制器 app.controller(\u0026#34;myController\u0026#34;, function($scope, $http){ $scope.findList = function() { $http.get(\u0026#34;data.json\u0026#34;).success( function(response) { $scope.list = response; } ); } }); \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body ng-app=\u0026#34;myApp\u0026#34; ng-controller=\u0026#34;myController\u0026#34; ng-init=\u0026#34;findList()\u0026#34;\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;td\u0026gt;姓名\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;学科\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;分数\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;tr ng-repeat=\u0026#34;entity in list\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{entity.name}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{entity.math}}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{entity.chinese}}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 接着在同一目录下，新建一个data.json文件，内容如下：\n1 2 3 4 5 [ {\u0026#34;name\u0026#34;:\u0026#34;张三\u0026#34;, \u0026#34;math\u0026#34;:99, \u0026#34;chinese\u0026#34;:88}, {\u0026#34;name\u0026#34;:\u0026#34;李四\u0026#34;, \u0026#34;math\u0026#34;:17, \u0026#34;chinese\u0026#34;:46}, {\u0026#34;name\u0026#34;:\u0026#34;赵五\u0026#34;, \u0026#34;math\u0026#34;:60, \u0026#34;chinese\u0026#34;:60} ] 需要注意的是，在.json文件中的数据必须严格遵守JSON的规范，所有key必须使用双引号，value除了数值型以外的类型也必须使用双引号。在Demo7中由于是在js中书写的，所以可以不必遵守严格的JSON格式。另外可以看到，这个$http的用法和AJAX很相似，其实其内部就是封装的AJAX。\n本文最后附上所有demo源码，demo-8在里边的web项目里。可以通过mvn tomcat7:run来启动该web项目(或者双击源码里的start.bat来启动项目)，接着在浏览器地址栏输入localhost:8080/demo-8.html，即可得到该JSON数据。\n项目相关 GitHub地址 下载地址 ","permalink":"https://lewky.cn/posts/69c71fa6.html/","tags":["AngularJS","简单入门"],"title":"AngularJS - 入门小Demo"},{"categories":["Java"],"contents":"前言 最近debug时忽然发现，如果一个集合赋值为null，那么对该集合进行foreach循环(也叫增强for循环)时，会报NPE(即空指针异常NullPointerException)。\n代码如下：\n1 2 3 4 5 final List\u0026lt;String\u0026gt; list = null; // final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (final String string : list) { System.out.println(string); } 运行时报错如下：\n1 2 Exception in thread \u0026#34;main\u0026#34; java.lang.NullPointerException at com.lewis.test.TestLewis.main(TestLewis.java:42) 一时间很惊奇，因为在我印象中，foreach循环在遇到null的集合时，应该是会自动跳过去不进行遍历的才对。于是修改代码如下：\n1 2 3 4 5 //final List\u0026lt;String\u0026gt; list = null; final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for (final String string : list) { System.out.println(string); } 运行后发现没有报错，看来是以前记错了。foreach循环只会自动跳过遍历空的集合，如果对于null值的集合，就会直接报NPE。\n解决方法 在写业务逻辑时难免会遇到遍历集合的情况，这时候应该先判断集合是否为null再进行遍历，可以使用Apache的工具类CollectionUtils。\n另外补充下，foreach循环内部是使用的迭代器来遍历，也就是说，这种遍历方式和使用迭代器来遍历是一样的。\n","permalink":"https://lewky.cn/posts/fba3f254.html/","tags":["Java"],"title":"Java - foreach循环报NPE空指针异常"},{"categories":["工作记录"],"contents":"需求背景 今天拿到这样一个需求：有Map A和Map B，这两个Map都持有着一个同样的key——id，其对应的value可能相同，也可能不相同。现在需要对两个Map中该key对应的value相同的键值对做些特殊的操作。\n这是个很简单的需求，代码很简单，我直接一个循环里嵌套另一个循环去实现这个功能需求：\n1 2 3 4 5 6 for(Map.Entry\u0026lt;String, String\u0026gt; entry : mapA.entrySet()) { //do something，需要循环10次 for(Map.Entry\u0026lt;String, String\u0026gt; entry : mapB.entrySet()){ //do something，需要循环1000次 } } 写的时候也没有考虑太多，提交代码给组长review的时候，组长表示这里的循环嵌套这样写不好，因为在实际业务中，集合B会比较大，假设mapA的size是10，mapB的size是1000，这样写就需要循环10*1000次，毕竟循环的时候需要进行一系列操作，假如有很多人同时通过ui来触发这段逻辑，就可能存在性能上的问题，对于用户来说，如果点击ui上的一个按钮需要等待个十来秒才有结果，那简直是毁灭性的用户体验。\n所以遇到这种需要嵌套循环的时候，应该尽量减少循环的次数；此外，一般情况下将大循环放到内部，将小循环放在外部，也会提高性能。\n一种优化思路 根据组长的建议，我可以将内部的大循环的循环次数尽量降低，原本是n*m的总循环次数，可以根据业务需求尽量拆分成n+m的总循环次数。当然，不太可能真的拆分成n+m，只是尽量往这个方向靠拢。\n想要实现这个优化，就只能对内部的大循环进行分组。具体怎么分组呢？可以new一个新的map，然后按照id分组(这里是因为我的业务需求中id会重复，所以将id作为分组依据)。将id相同的数据分成一组，然后存放到一个ArrayList中；然后这个id作为key存入map里，而这个ArrayList则作为value存入map里。\n假设原本内部大循环的集合size是1000，我们将其分成了10组，而外部小循环的集合size是10，那么原本的101000总循环次数就可以变形成1000+1010次。如下：\n1 2 3 4 5 6 7 8 9 for(Map.Entry\u0026lt;String, String\u0026gt; entry : mapB.entrySet()){ //先对大集合Map B进行分组，并存入一个Map C中，需要循环1000次 } for(Map.Entry\u0026lt;String, String\u0026gt; entry : mapA.entrySet()) { //do something，需要循环10次 for(Map.Entry\u0026lt;String, String\u0026gt; entry : mapC.entrySet()){ //do something，需要循环10次 } } 当然了，这种优化思路是在特定的功能需求下才能实现的，具体问题具体分析，因为组长的提醒，我才知道原来嵌套循环还可以这样来优化，代码之道果然是要日积月累才行。\n另外关于大循环在内小循环在外的写法的具体分析，可以看看这篇文章：for循环嵌套的效率\n可惜暂时我还看不懂。。\n","permalink":"https://lewky.cn/posts/fe753197.html/","tags":["工作记录","Java"],"title":"嵌套循环的优化"},{"categories":["cmd"],"contents":"问题 在cmd窗口中输入curl www.baidu.com可以看到有中文乱码的现象，这是因为默认使用的是GBK编码。另外，curl是利用URL语法在命令行方式下工作的开源文件传输工具。它被广泛应用在Unix、多种Linux发行版中，并且有DOS和Win32、Win64下的移植版本，在win10的cmd中有内嵌curl。\n1 2 3 4 C:\\Users\\lewis.liu\u0026gt;curl www.baidu.com \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;!--STATUS OK--\u0026gt;\u0026lt;html\u0026gt; \u0026lt;head\u0026gt;\u0026lt;meta http-equiv=content-type content=text/html;charset=utf-8\u0026gt;\u0026lt;meta http-equiv=X-UA-Compatible content=IE=Edge\u0026gt;\u0026lt;meta content=always name=referrer\u0026gt;\u0026lt;link rel=stylesheet type=text/css href=http://s1.bdstatic.com/r/www/cache/bdorz/baidu.min.css\u0026gt;\u0026lt;title\u0026gt;鐧惧害涓€涓嬶紝浣犲氨鐭ラ亾\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt; ... 解决方法 在cmd窗口中输入：\n1 CHCP 65001 回车后重新输入上边的curl命令，会发现不再中文乱码。不过这种方法只对当前的cmd窗口有效果，如果退出当前窗口重新打开一次cmd，你会发现依然中文乱码。如果想要一次性解决这个问题，需要去修改注册表。这个方法这里就不说了，有兴趣的可以查看下边的参考链接。\nCHCP是一个计算机指令，能够显示或设置活动代码页编号。 代码页 描述 65001 UTF-8代码页 950 繁体中文 936 简体中文默认的GBK 437 MS-DOS 美国英语\n可以通过右键cmd窗口，点击属性查看当前的活动代码页编码(Current Code Page)。\n参考链接 windows下使用curl命令 \u0026amp;\u0026amp; 常用curl命令 windows 控制台cmd乱码的解决办法 ","permalink":"https://lewky.cn/posts/761efa7.html/","tags":["cmd","工作记录"],"title":"cmd - 命令行窗口中文乱码"},{"categories":["前端"],"contents":"如何让input文本框和图片对齐 在默认情况下，input文本框和图片无法自然对齐，总会有所偏差，文本框往往会比图片要往下边一点，只要给元素添加vertical-align:bottom即可令两者底部水平对齐，代码如下：\n1 2 \u0026lt;input type=\u0026#34;text\u0026#34; style=\u0026#34;vertical-align:bottom\u0026#34;\u0026gt; \u0026lt;img src = \u0026#34;images/露琪亚.jpg\u0026#34; width = \u0026#34;50%\u0026#34; height = \u0026#34;50%\u0026#34; alt = \u0026#34;露琪亚\u0026#34; title = \u0026#34;死神里的露琪亚\u0026#34; style=\u0026#34;vertical-align:bottom\u0026#34;\u0026gt; 另外还可通过vertical-align的其他属性进行垂直布局。\n如何设置透明度属性 1 2 3 4 5 6 7 8 \u0026lt;!-- IE8 以及更早的版本 --\u0026gt; filter:alpha(opacity=50); \u0026lt;!-- 火狐浏览器 --\u0026gt; -moz-opacity:0.5; \u0026lt;!-- Konqueror浏览器 --\u0026gt; -khtml-opacity: 0.5; \u0026lt;!-- 所有浏览器都支持的一个css属性 --\u0026gt; opacity: 0.5; 如何通过选中文字来勾选/取消复选框 想要在选中文字的时候就自动勾选或取消复选框，有两种实现的方式：\n方式一：在复选框的外边包上label标签 1 \u0026lt;label\u0026gt;\u0026lt;input type=\u0026#34;checkbox\u0026#34;\u0026gt;233333333\u0026lt;/label\u0026gt; 方式二：通过label标签的for属性来联动某一个复选框 1 2 \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;check1\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;check1\u0026#34;\u0026gt;55555555555\u0026lt;/label\u0026gt; 另外，当复选框和文字无法对齐的时候，可以在复选框里添加style=\u0026quot;vertical-align: sub;\u0026quot;来实现对齐。\n如何屏蔽双击选中文本 IE浏览器可以通过在某个标签里添加onselectstart=\u0026quot;return false\u0026quot;来屏蔽双击选中文本，该属性在火狐中无效，火狐需要用style=\u0026quot;-moz-user-select:none;\u0026quot;。此外还可以在body里添加该属性来实现整个网页都无法选中文字。\n类似的属性属性还有：\n禁止鼠标右键：oncontextmenu=\u0026quot;return false\u0026quot; 禁止拖放：ondragstart=\u0026quot;return false\u0026quot; 禁止拷贝：oncopy=document.selection.empty() 禁止复制：oncopy = \u0026quot;return false\u0026quot; 禁止保存：\u0026lt;noscript\u0026gt;\u0026lt;iframe src=\u0026quot;*.htm\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/noscript\u0026gt;，放在head里面。 禁止粘贴：\u0026lt;input type=text onpaste=\u0026quot;return false\u0026quot;\u0026gt; 禁止剪贴：oncut = \u0026quot;return false\u0026quot; 关闭输入法：\u0026lt;input style=\u0026quot;ime-mode:disabled\u0026quot;\u0026gt; 文本自动换行问题 当行内出现很长的英文单词或者url的时候，会出现自动换行的问题，为了美化页面，往往会希望这些很长的英文单词或者url能够断开来，超出的部分换行到下一行。\n可以通过使用两个属性来实现该需求：\n1 2 word-wrap:break-word; word-break:break-all; word-wrap word-wrap用来控制换行，有两种取值：\nnormal break-word（此值用来强制换行，内容将在边界内换行，中文没有任何问题，英文语句也没问题。但是对于长串的英文，就不起作用。） word-break word-break用来控制断词，有三种取值：\nnormal break-all（是断开单词。在单词到边界时，下个字母自动到下一行。主要解决了长串英文的问题。） keep-all（是指Chinese, Japanese, and Korean不断词，一句话一行，可以用来排列古诗哟~） 文本溢出控制 单行溢出 text-overflow是CSS3中的属性，规定了文本溢出后的显示样式，但它不会强制文本溢出，所以有时候会不生效。该属性支持的值如下：\nclip：默认值，将溢出的文本裁减掉 ellipsis：将溢出的文本用省略号(\u0026hellip;)来表示 \u0026lt;string\u0026gt;：设置一个字符串用来表示溢出的文本 兼容性上，除了\u0026lt;string\u0026gt;外，其余两个属性兼容到了IE6+，所以大可放心使用。\n为了让该属性生效，解决方法如下：\n1 2 3 4 width: 100%; /*也可以是固定值、min-width这些*/ white-space: nowrap; /*强制文本不能换行*/ overflow: hidden; /*隐藏溢出内容*/ text-overflow: ellipsis; 多行溢出 通过display: -webkit-box;可以实现多行溢出：\n1 2 3 4 5 6 7 width: 100%; overflow: hidden; word-break: break-all; /*允许在单词内换行，更美观*/ text-overflow: ellipsis; display: -webkit-box; /*元素作为box伸缩盒子*/ -webkit-line-clamp: 3; /*设置文本行数限制*/ -webkit-box-orient: vertical; /*设置文本排列方式*/ JS文件中的中文在网页上显示为乱码 如果页面已经设置了\u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt;，JS文件里的中文在网页上仍然显示为乱码，可能是由于JS文件的编码问题导致的。\nJS文件本身的编码默认为ANSI编码，而引入该JS文件的页面则使用了utf-8编码，所以导致了中文乱码。解决方法是将该JS文件自身的编码改为utf-8编码，可以借助常用的编辑器比如Nodepad++或者Editplus等来修改JS文件自身的编码。\n参考链接 解决文档中有url链接时被强制换行的问题 JS文件中的中文在网页上显示为乱码 谈谈text-overflow的那些坑和应对方法 ","permalink":"https://lewky.cn/posts/4d6b513d.html/","tags":["CSS","工作记录"],"title":"前端问题汇总"},{"categories":["工作记录"],"contents":"Notepad++怎么设置tab替换为4个空格 设置 -\u0026gt; 首选项... -\u0026gt; 语言菜单 -\u0026gt; 制表符设置 -\u0026gt; 勾选上转换为空格\nNotepad++自动备份文件目录 Notepad++在非正常关闭时会自动将打开的文件保存到备份文件目录下，可以从该目录下找回丢失的文件：\nC:\\Users\\{当前用户名}\\AppData\\Roaming\\Notepad++\\backup\nUltraEdit显示文件标签栏 view -\u0026gt; views/lists -\u0026gt; open Files Tabs\nUltraEdit显示侧边栏 view -\u0026gt; views/lists -\u0026gt; File Tree View\n参考链接 ultraEdit打开多个页面时 怎样显示页面标签 notepad++的tab设置为4个空格 Notepad++ - 缓存目录 ","permalink":"https://lewky.cn/posts/a39d8a42.html/","tags":["文本编辑器"],"title":"文本编辑器问题汇总"},{"categories":["工作记录"],"contents":"场景 线上出了问题，我需要去查找log来定位问题，但是由于线上数据量庞大，这些log文件每过一个小时就会自动回滚一次，尽管如此，有的log文件依然达到了五六g以上的大小。\n对于这种巨大的log文件，常用的一些文本编辑器诸如EditPlus、Notepad++就不用说了，打开几百m的文件都会很卡，上g的直接程序崩溃。虽然UltraEdit对于大文件的读取会友好一些，但打开这种五六g的文件时也会陷入长时间的无响应状态。\n后来我又得知了一个看log神器——glogg，打开五六g的大文件速度很快，但是有个问题，就是只能读取文件，不能编辑文件。毕竟我不只是要查看log，有时候还要对这些有用的log信息进行编辑。最后还是决定先把大文件分割成数个小文件，再用UltraEdit来查看这些文件。\n使用split命令分割大文件 在Linux下，切割和合并文件可以使用split和cat命令来实现。 在Windows下，安装Git Bash也可以使用split和cat命令。\n分割文件的命令是split，通过输入split --help可以查询帮助信息。假设现在有个6GB大小的文件test.log，这里简单介绍下几种分割的方式：\n按大小分割文件 1 split -b 1000000000 test.log -b参数表示按字节大小进行分割，在数字后边要指定被分割的文件名。这里在输入文件名时有个小技巧，可以直接把该文件拖动到cmd窗口中，会自动输入该文件的具体目录。这里的文件还可以使用通配符，比如split -b 1000000000 *。\n这个命令表示按1000000000byte的大小进行分割，近似于1GB，大概是953MB的大小。对于这个6GB大小的文件test.log，会被分割成6个小文件。这些小文件的命名是有规律的：xaa、xab、xac、xad、xae、xaf。如果你分割了非常多的小文件，当文件名到了xyz之后，会变成xzaaa、xzaab、xzaac、xzaad……所以不用担心小文件过多而导致文件重名什么的。\n当然，上边的这种写法不够人性化，我们可以使用其他的单位来指定分割的大小：k、m。k表示KB，m表示MB。\nsplit -b 100k test.log表示将test.log按照100KB的大小进行分割。 split -b 100m test.log表示将test.log按照100MB的大小进行分割。\n按照所有行数加起来的最大字节数进行分割 1 split -C 100k test.log -C参数表示按照所有行数加起来的最大字节数进行分割，同样可以使用k或者m作为单位，其实效果和上边的-b差不多，只是在切割时将尽量维持每行的完整性。\n按照行数进行分割 1 2 split -l 1000 test.log split -1000 test.log -l参数表示按照行数进行分割，即一个小文件中最多有多少行，-l number可以缩写成-number，上边的命令表示按照1000行一个小文件进行分割。\n注意点 这三种分割的方式不能混合使用，如下：\n1 split -l 3000 -C 100k * 会报错split: cannot split in more than one way。\n","permalink":"https://lewky.cn/posts/54434588.html/","tags":["split","分割大文件","工作记录"],"title":"通过split命令分割大文件"},{"categories":["工作记录"],"contents":"Avoid autogenerated methods to access private fields and methods of inner / outer classes 样例如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class Test { public static void main(final String[] args) { //code } public void test(){ Executors.newSingleThreadExecutor().execute(new Thread() { @Override public void run() { final int a = getNum(); System.out.println(a); } }); } private int getNum() { return 0; } } 报错原因 在匿名内部类的方法里去调用外部类的私有方法或变量就会报这个PMD错误。\n解决方法 可以将匿名内部类的方法里调用到的外部类的私有方法/变量改成protected。以样例来举例，即将getNum()的权限改为protected：\n1 2 3 protected int getNum() { return 0; } ","permalink":"https://lewky.cn/posts/1ad7b6fb.html/","tags":["代码规范","工作记录","PMD"],"title":"PMD问题汇总"},{"categories":["工作记录"],"contents":"问题与分析 今天在公司进行Sanity Test(可用性测试)时发现服务器启动失败，查找log后发现在启动时发生了异常导致了服务器启动失败。\n由于公司的服务器和数据库分别部署在不同的主机，所以会在启动时进行时间上的校验，如果两台主机的时间差超过600s就会抛出异常、启动失败。这个设定的时间差被存储在数据库中，以方便日后修改。\n而在代码中，通过mybatis来读取到这个存储在db中的时间差，sql语句如下：\n1 SELECT TO_CHAR(CURRENT_TIMESTAMP,\u0026#39;YYYY-MM-DD HH24:MI:SS\u0026#39;) AS \u0026#34;DBTIME\u0026#34;; 而服务器的本地时间以及时间的校验则是由下边的代码来实现：\n1 2 3 4 5 6 7 8 final DateTime dbTime = systemMapper.getDBTime(); final long dbTimeMs = dbTime.getMilliseconds(TimeZone.getDefault()); final DateTime webAppTime = DateTime.now(); final long webAppTimeMs = webAppTime.getMilliseconds(TimeZone.getDefault()); // Calculate difference between WebApp time and DB time final long timeDifferent = Math.abs(dbTimeMs - webAppTimeMs); 从代码可以看到，将服务器和数据库所在的主机的本地时间转换成默认的时区后，再进行相减取绝对值，如果这个结果值超过db中设定的时间差(也就是600s)就会抛出异常，令服务器启动失败。\n分析到这里，便开始进行验证：分别连接到两台主机并通过date命令来查询各自的时间，发现双方的时间差大概有15分钟左右，确实超过了600s。\n于是问题来了，为什么会忽然出现这么大的时间差？明明昨天还可以正常启动，今天却因为时间差变大而导致失败了？可以确定的是，db中设定的时间差一直就是600s，并没有人去改动它。\n在工作群里说了下服务器启动失败的原因，有同事说可能是机器断电造成的？百度了下，也有人遇到这种类似的情况，Linux的系统时间忽然变慢了几分钟到十几分钟，也有的是时间变快了。暂时没找到具体的原因，解决办法基本都是直接修改系统时间。\n目前看来，这个问题的答案是无法得知了，对于这方面我确实不了解。如果哪位朋友知道的，欢迎评论告诉我一下O(∩_∩)O哈哈~\n今天写篇文章记录下这个问题，以前我还真没想到需要对不同主机的服务器和数据库进行时间校验，百度了下，倒是发现很多安卓app关于客户端和服务端进行时间校验的文章，挺有意思的。\n","permalink":"https://lewky.cn/posts/663a514f.html/","tags":["工作记录","JavaWeb"],"title":"服务器时间和数据库时间的校验"},{"categories":["计算机"],"contents":"网络适配器（网卡） 网络适配器其实就是计算机内部的网络连接设备，也就是俗称的网卡。网卡分为有线网卡和无线网卡，有线网卡能够支持宽带有线网络的连接和网络访问，而无线网卡则支持无线wifi局域网的网络连接和访问。\n台式电脑一般默认都不带无线卡，所以是无法接收wifi进行上网的。\n如果想要台式机接收无线网使用wifi，电脑必须安装一块无线网卡，可以选择USB接口无线网卡。\n网卡驱动 网卡是硬件设备，网卡驱动是配套的软件。\n驱动程序（Device Driver）全称为“设备驱动程序”，是一种可以使计算机中央处理器——CPU控制和使用设备的特殊程序，相当于硬件的接口，操作系统通过这个接口，控制硬件设备的工作。所有的硬件都要安装驱动程序，没有驱动程序的硬件是运行不了的，就像一辆有轮胎但是没有传动轴的汽车一样跑不起来，控制不了。假如某设备的驱动程序未能正确安装，便不能正常工作。\n网卡驱动程序就是CPU控制和使用网卡的程序。\n参考链接 网络适配器无法启动怎么办 台式电脑如何连接wifi 网卡驱动_百度百科 ","permalink":"https://lewky.cn/posts/b66922.html/","tags":["计算机"],"title":"网络适配器、网卡和网卡驱动"},{"categories":["计算机"],"contents":"什么是Hosts 百度百科：\nHosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”，当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从Hosts文件中寻找对应的IP地址，一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交DNS域名解析服务器进行IP地址的解析。\n需要注意的是，Hosts文件配置的映射是静态的，如果网络上的计算机更改了请及时更新IP地址，否则将不能访问。\nHosts所在文件夹 Windows系统hosts位于 C:\\Windows\\System32\\drivers\\etc\\hosts Android（安卓）、Mac（苹果电脑）iPhone（iOS）、Linux 、绝大多数Unix等系统hosts都是位于 /etc/hosts Android（安卓）iPhone（iOS）修改hosts 需要Root或越狱。 Hosts的作用 加快域名解析 方便局域网用户 屏蔽网站（域名重定向） 顺利连接系统 虚拟域名 更加具体的说明请参考百度百科。\n使用步骤 获取最新的hosts文件 可以自己百度Google hosts寻找最新的hosts文件，获取前往GitHub上由大佬们维护的项目获取：https://github.com/googlehosts/hosts\n在上述的项目地址中找到hosts文件(无后缀名)，也可以直接在线浏览该文件的内容，下边附上链接：https://raw.githubusercontent.com/googlehosts/hosts/master/hosts-files/hosts\n这是国内对应的CDN地址：https://cdn.jsdelivr.net/gh/googlehosts/hosts@master/hosts-files/\n也可以通过访问 https://cdn.jsdelivr.net/gh/googlehosts/hosts@master/hosts-files/hosts 来直接下载到本地。\n修改本地hosts文件 从上边的项目地址将hosts文件下载到本地，直接替换掉本地的hosts文件，建议替换之前先备份原本的hosts文件。\n或者直接在线浏览文件内容，将内容拷贝到本地的hosts文件的末尾。\n这里说明一下，文件里的#开头表示注释，也就是说那一行没有效果，只是起到说明作用。\n刷新本地dns 修改了hosts文件后不需要重启电脑，直接在本地刷新dns的缓存即可生效：\nWindows win+R组合键启动运行，输入cmd 在cmd界面输入ipconfig /flushdns，然后回车 接下来你会看到已成功刷新 DNS 解析缓存。 Linux 终端输入sudo rcnscd restart 对于systemd发行版，输入sudo systemctl restart NetworkManager 如果不懂请都尝试下。 Mac OS X 终端输入sudo killall -HUP mDNSResponder\nAndroid 开启飞行模式 -\u0026gt; 关闭飞行模式\n通用方法 拔网线(断网) -\u0026gt; 插网线(重新连接网络) 如不行请清空浏览器缓存 再不行请重启电脑 相关事项说明 注意事项\r本文提供的hosts链接仅限于方便学习使用 hosts里不会添加屏蔽广告条目，也不会劫持任何网站 您现在的hosts能使用，就没必要经常更新！ 版权声明\rGithub项目的所有代码除另有说明外,均按照 MIT License 发布。\nGithub项目的hosts，README.MD， wiki等资源基于 CC BY-NC-SA 4.0 这意味着你可以拷贝、并再发行本项目的内容， 但是你将必须同样提供原作者信息以及协议声明。同时你也不能将本项目用于商业用途，按照我们狭义的理解 (增加附属条款)，凡是任何盈利的活动皆属于商业用途。\n感谢大佬们的无私奉献","permalink":"https://lewky.cn/posts/9cdb4f66.html/","tags":["计算机","Google hosts"],"title":"Google hosts - 简单介绍与使用方法"},{"categories":["PostgreSQL"],"contents":"修改默认端口号 PostgreSQL默认使用5432端口号，如果要连接其他端口号，必须通过-p参数来指定端口号。\n如果不想指定端口号就能连接数据库，则需要修改默认端口号。首先将PostgreSQL的server服务关闭，这个要在系统的服务管理器中将其关闭：\nwin + R快捷键打开运行； 输入services.msc打开服务管理器； 找到运行中的PostgreSQL的server服务将其关闭。 在PostgreSQL的安装路径下，找到对应版本的postgresql.conf文件（在data文件夹内）：\n修改port = 5432； 保存修改，重启该版本的server服务，即可生效。 pgAdmin4远程连接数据库 PostgreSQL在安装的时候自带的pgAdmin这个可视化工具，自从将PostgreSQL9升级到了10版本后，自带的pgAdmin也从3升级到了4版本。pgAdmin4的变化非常巨大，这里记录下怎么用pgAdmin4进行远程连接数据库并执行SQL语句。\n操作步骤 选中Browser窗口里的Servers -\u0026gt; 点击上方工具栏里的Object -\u0026gt; Create -\u0026gt; Server\u0026hellip; 在弹窗的General tab里填写Name，可以随意命名 接着选择第二个tab：Connection，填写Host的ip地址、端口号、数据库名、用户名、密码，点击save保存 执行SQL语句 在配置好上边的server后，连接该server，接着连接server下的某个Database，连接成功后可以通过以下方式来执行SQL：\n点击上方工具栏里的Tools -\u0026gt; Query Tool 输入SQL 选定某条SQL语句，点击Query Tool里的闪电标志的按钮，就可以执行改SQL语句 虽然pgAdmin4比起3的ui好看了很多，在restore db的时候也变成了后台异步restore，不至于在restore比较大的db时阻塞住进程。但个人还是更喜欢另一款可视化工具DBeaver，不仅支持市面上各大常见的数据库，还有很多好用的功能和快捷键，真的非常好用！！强烈推荐！！\n设置远程访问数据库 安装PostgreSQL数据库之后，默认是只接受本地访问连接。如果想在其他主机上访问PostgreSQL数据库服务器，就需要进行相应的配置，需要修改data目录下的pg_hba.conf和postgresql.conf。\npg_hba.conf配置对数据库的访问权限，postgresql.conf配置PostgreSQL数据库服务器的相应的参数。\n修改pg_hba.conf文件 配置用户的访问权限（#开头的行是注释内容）\n1 2 3 4 5 6 7 8 9 # TYPE DATABASE USER CIDR-ADDRESS METHOD # \u0026#34;local\u0026#34; is for Unix domain socket connections only local all all trust # IPv4 local connections: host all all 127.0.0.1/32 trust host all all 192.168.1.0/24 md5 # IPv6 local connections: host all all ::1/128 trust 上边的第7行是新添加的内容，表示允许网段192.168.1.0上的所有主机使用所有合法的数据库用户名访问数据库，并提供加密的密码验证。\n其中，数字24是子网掩码，表示允许192.168.1.0 ~ 192.168.1.255的计算机访问。\n修改postgresql.conf文件 将数据库服务器的监听模式修改为监听所有主机发出的连接请求：\n定位到#listen_addresses='localhost'，PostgreSQL安装完成后，默认是只接受来在本机localhost的连接请求。\n将行开头的#去掉，将行内容修改为listen_addresses='*'来允许数据库服务器监听来自任何主机的连接请求。\ninvalid input syntax for type timestamp with time zone 在执行以下sql时报错：\n1 select COALESCE(null,null,now(),\u0026#39;\u0026#39;); 报错如下：\n1 2 3 4 SQL Error [22007]: ERROR: invalid input syntax for type timestamp with time zone: \u0026#34;\u0026#34; Position: 33 org.postgresql.util.PSQLException: ERROR: invalid input syntax for type timestamp with time zone: \u0026#34;\u0026#34; Position: 33 由于coalesce()要求输入参数是null或字符串，而now()返回的结果是带有时区的时间戳，所以就会报错；需要把时间戳转换成字符串才可以：\n1 2 3 select COALESCE(null,null,now()||\u0026#39;\u0026#39;,\u0026#39;\u0026#39;); select COALESCE(null,null,now()::varchar,\u0026#39;\u0026#39;); 怎么转义字符 使用E和反斜杠进行转义 在PostgreSQL 9之前的版本中，可以直接使用反斜杠\\进行转义；比如：\\b表示退格，\\n表示换行，\\t表示水平制表符，\\r标示回车，\\f表示换页。除此之外还支持\\digits和\\xhexdigits，分别表示转义八进制和十六进制数据。\n但是在PostgreSQL 9之后的版本，反斜杠已经变成了普通字符；如果想要使用反斜杠来转义字符，就必须在需要转义的字符串前面加上E（E就是Escape），如下：\n1 select E\u0026#39;张\\t小明\u0026#39;; 直接用一个单引号来转义单引号 在SQL标准中字符串是用单引号括起来的，而在PostgreSQL中遵守了该标准，双引号则是用来表示变量的，如果在字符串中需要使用到单引号，就需要对其进行转义。\n除了使用E和反斜杠进行转义单引号外：\n1 select E\u0026#39;\\\u0026#39;233\u0026#39;; 还可以直接用一个单引号来转义单引号：\n1 select \u0026#39;\u0026#39;\u0026#39;233\u0026#39;; 这两种方式都能得到'233的结果而不会报错，第二种方式比较简单，也可以通过修改standard_conforming_strings参数的值来让反斜杠从普通字符变回转义字符：\n查询并修改该参数的值：\n1 2 3 show standard_conforming_strings; SET standard_conforming_strings = on; SET standard_conforming_strings = off; 当该参数的值为off时就可以直接使用反斜杠作为转义字符里，如下：\n1 select \u0026#39;\\\u0026#39;233\u0026#39;; 将会得到'233的结果而不会报错。\n如何杀掉被锁死的进程 杀掉指定进程 PostgreSQL提供了两个函数：pg_cancel_backend()和pg_terminate_backend()，这两个函数的输入参数是进程PID，假定现在要杀死进程PID为20407的进程，使用方法如下：\n1 2 3 4 select pg_cancel_backend(20407); --或者执行这个函数也可以： select pg_terminate_backend(20407); 这两个函数区别如下：\npg_cancel_backend()\n只能关闭当前用户下的后台进程 向后台发送SIGINT信号，用于关闭事务，此时session还在，并且事务回滚 pg_terminate_backend()\n需要superuser权限，可以关闭所有的后台进程 向后台发送SIGTERM信号，用于关闭事务，此时session也会被关闭，并且事务回滚 那么如何知道有哪些表、哪些进程被锁住了？可以用如下SQL查出来：\n1 2 3 4 select * from pg_locks a join pg_class b on a.relation = b.oid join pg_stat_activity c on a.pid = c.pid where a.mode like \u0026#39;%ExclusiveLock%\u0026#39;; 这里查的是排它锁，也可以精确到行排它锁或者共享锁之类的。这里有几个重要的column：a.pid是进程id，b.relname是表名、约束名或者索引名，a.mode是锁类型。\n杀掉指定表指定锁的进程 1 2 3 4 5 6 7 8 9 10 11 12 select pg_cancel_backend(a.pid) from pg_locks a join pg_class b on a.relation = b.oid join pg_stat_activity c on a.pid = c.pid where b.relname ilike \u0026#39;表名\u0026#39; and a.mode like \u0026#39;%ExclusiveLock%\u0026#39;; --或者使用更加霸道的pg_terminate_backend()： select pg_terminate_backend(a.pid) from pg_locks a join pg_class b on a.relation = b.oid join pg_stat_activity c on a.pid = c.pid where b.relname ilike \u0026#39;表名\u0026#39; and a.mode like \u0026#39;%ExclusiveLock%\u0026#39;; 另外需要注意的是，pg_terminate_backend()会把session也关闭，此时sessionId会失效，可能会导致系统账号退出登录，需要清除掉浏览器的缓存cookie（我们系统遇到的情况是这样的）。\n参考链接 pgadmin4远程连接 postgresql服务 PostgreSQL 允许远程访问设置方法 postgresql字符转义 pg_cancel_backend与pg_terminate_backend函数的区别 pg_cancel_backend()和pg_terminate_backend() ","permalink":"https://lewky.cn/posts/postgresql-issues/","tags":["工作记录"],"title":"PostgreSQL问题汇总"},{"categories":["PostgreSQL"],"contents":"PostgreSQL连接数据库的两种方式 PostgreSQL在安装时自带了pgAdmin和psql，pgAdmin是可视化工具，psql是命令行工具。\n虽然pgAdmin操作起来会更加直观简单，但是在restore和backup db的时候，效率和性能会比较低下，如果db过于庞大，还会导致pgAdmin内存溢出。\n推荐使用psql来连接数据库进行备份和恢复db，同样大小的db，使用psql来restore会比pgAdmin快上数倍！\npsql连接数据库 直接连接到指定的数据库 1 psql -h \u0026lt;dbserver_IP\u0026gt; -p\u0026lt;dbserver_port\u0026gt; -d \u0026lt;database_Name\u0026gt; -U \u0026lt;db user\u0026gt; 如果host是localhost，可以不指定该参数，当不指定端口号时会使用默认的端口号5432，或者你可以通过-p来指定其他端口号。\n比如你想连接本地的db：test:5432，用户名是postgres，可以使用如下的命令：\n1 psql -d test -U postgres 如果有密码的话会提示你输入密码，连接数据库后就可以直接通过sql语句来进行相关的操作了。\n先登陆psql控制台，再连接指定的数据库 psql命令也可以不指定某个数据库，如下：\n1 psql -h \u0026lt;dbserver_IP\u0026gt; -p\u0026lt;dbserver_port\u0026gt; -U \u0026lt;db user\u0026gt; 这时候登陆成功后会进入psql的命令台，此时可以跑一些数据库备份、创建数据库或者连接数据库之类的操作。\n在psql的命令台输入\\c \u0026lt;database_Name\u0026gt;，接着按下回车键，即可连接到对应的数据库，如下：\n1 2 3 4 5 6 postgres=# \\c cbx6_dev WARNING: Console code page (437) differs from Windows code page (1252) 8-bit characters might not work correctly. See psql reference page \u0026#34;Notes for Windows users\u0026#34; for details. You are now connected to database \u0026#34;cbx6_dev\u0026#34; as user \u0026#34;postgres\u0026#34;. cbx6_dev=# 怎么切换到不同的数据库 如果已经连接到一个数据库了，这时候想切换到另一个数据库怎么办？很简单，还是跑这个\\c的命令即可。\n退出psql控制台 和其他的命令行工具不一样，psql在退出时并不是使用exit，而是使用\\q，接着按下回车就行了，这里的q指的就是quit。\npsql自动输入密码 方式一：设置环境变量PGPASSWORD 如下：\n1 2 3 4 5 #linux export PGPASSWORD=12345 #windows set PGPASSWORD=12345 方式二：使用密码文件.pgpass 在~/目录下创建隐藏文件.pgpass，~/目录也就是当前用户的用户目录。在密码文件中填写hostname:port:database:username:password的内容，如下：\n1 2 3 localhost:5432:db1:admin:admin localhost:5432:db2:admin:admin localhost:5432:db3:admin:admin 然后需要配置一个环境变量PGPASSFILE，指向.pgpass密码文件的路径：\n1 set PGPASSFILE=C:\\Users\\xxx\\.pgpass 这种方法的好处是可以同时定义多个不同主机上的数据库账号密码。\n方式三：修改服务端配置文件pg_hba.conf 打开PostgreSQL安装目录下的\\data\\pg_hba.conf，将其中的连接对应的md5改为trust，然后重启服务。如下：\n1 2 3 4 5 6 # TYPE DATABASE USER ADDRESS METHOD # IPv4 local connections: host all all 127.0.0.1/32 md5 \u0026lt;= 改为trust host all all 172.20.1.0/24 md5 host all all 172.168.199.0/24 md5 psql运行SQL文件 方式一：连接db后执行SQL文件 首先通过psql连接到对应的db：\n1 psql -d db1 -U userA 接着输入密码，进入数据库后，输入：\n1 \\i /pathA/xxx.sql 这里有个问题，如果你把SQL文件的路径里的路径分隔符写成了\\，会报错说Permission denied。\n这里的文件路径必须使用Linux平台下的路径分隔符/，否则会报错。\n方式二：直接通过psql命令执行SQL文件 这种方式无需先登录数据库，直接用一个命令就可以了：\n1 psql -d db1 -U userA -f /pathA/xxx.sql 接着输入密码即可执行SQL文件到对应的db里。\n小技巧：可以直接把sql文件拖到cmd窗口里，会自动把该sql文件的所在路径给输入到命令行中。\n导出db dump 格式如下：\n1 pg_dump -h \u0026lt;host\u0026gt; -p \u0026lt;port\u0026gt; -U \u0026lt;db_user\u0026gt; -F c -f \u0026lt;dump_path\u0026gt; \u0026lt;db_name\u0026gt; demo:\n1 pg_dump -h localhost -p 5432 -U postgres -F c -f D:\\dump_jar\\test.dump test 恢复备份（导入db dump） 1 pg_restore -h \u0026lt;host\u0026gt; -p \u0026lt;port\u0026gt; -U \u0026lt;db_user\u0026gt; -W -O -d \u0026lt;db_name\u0026gt; \u0026lt;dump_path\u0026gt; demo:\n1 pg_restore -h localhost -p 5432 -U postgres -W -O -d test test.DUMP 这里的db要先创建好，dump本质上就是一大堆sql，可以通过该命令导入到已存在的db里。另外，执行pg_restore时需要输入密码。\n参考链接 PostgreSQL 教程 在脚本中调用psql如何自动输入密码 psql执行文件时出现Permission denied ","permalink":"https://lewky.cn/posts/postgresql-psql.html/","tags":["工作记录"],"title":"PostgreSQL - psql使用汇总"},{"categories":["工作记录"],"contents":"问题与分析 最近在查项目的log时发现报了大量的NPE(NullPointerException)，诡异的是只log了Exception的类名，却没有具体的堆栈信息，以致于无法对该NPE异常进行准确定位。\n这是因为jvm自身存在着优化机制，但一个同样的异常重复出现并被打印到log后，jvm可以不提供具体的堆栈信息来提高性能。关于这个的具体信息我们可以从官网上查到相关的资料：\nhttp://www.oracle.com/technetwork/java/javase/relnotes-139183.html#vm\nThe compiler in the server VM now provides correct stack backtraces for all \u0026ldquo;cold\u0026rdquo; built-in exceptions. For performance purposes, when such an exception is thrown a few times, the method may be recompiled. After recompilation, the compiler may choose a faster tactic using preallocated exceptions that do not provide a stack trace. To disable completely the use of preallocated exceptions, use this new flag: -XX:-OmitStackTraceInFastThrow.\n谷歌翻译如下：\n服务器VM中的编译器现在为所有“冷”内置异常提供正确的堆栈回溯。出于性能目的，当抛出这样的异常几次时，可以重新编译该方法。重新编译之后，编译器可以使用不提供堆栈跟踪的预分配异常来选择更快的策略。要完全禁用预分配的异常，请使用以下新标志：-XX：-OmitStackTraceInFastThrow。\n解决方案 有两个解决方案，第一个是安装官网说的，可以通过设置jvm的启动参数来关闭该策略：\n1 -XX：-OmitStackTraceInFastThrow 另一个解决方案是不设置启动参数，直接重新启动服务器，比如Tomcat。重启服务器时jvm被重新启动，这样再遇到同样的Exception时就会打印出来，当然如果后续如果重复遇到同样的Exception还是无法打印出具体的异常栈信息。\n当时我是选择了后者这个方案，因为如果启用了该参数会导致log日志太过庞大，也降低了性能，直接重启服务器，并快速定位bug以便于解决问题。\n补充 如果想了解更多关于该参数的细节，可以参考下边的文章：\n异常栈信息不见了之JVM参数OmitStackTraceInFastThrow ","permalink":"https://lewky.cn/posts/a3da2383.html/","tags":["Java","工作记录"],"title":"log日志中不打印异常栈的具体信息"},{"categories":["Hexo系列"],"contents":"Coding Pages申请SSL/TLS证书错误 某天发现我的个人站点SSL/TLS证书到期，我的证书是由Coding Pages提供的，每次申请成功后有效期是三个月，证书到期后可以继续免费申请。但是当我登陆进入Coding Pages服务的后台并点击申请证书时，竟然报错了！！\n我重新点了申请，几秒后依然报错，并提示我半小时只能申请一次。我查看了下报错的提示信息，如下：\nurn:acme:error:unauthorized:Invalid response from http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxx\n一时间也不明白是怎么回事，因为我第一次申请的时候不用几秒钟就成功了，由于报错信息中包含了本静态博客的部署时间，我以为可能存在部署时间的校验，于是重新部署了一下，半小时后继续申请，依然报同样的错误。\n之后百度发现了Coding Pages的官方文件：Coding Pages 常见问题\n这时候按照官方文件的指引，找到了和我一样的错误信息的解决方案：\n错误原因：无法获取正确的域名验证信息 解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io 解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器\n因为Coding Pages的静态Pages是免费的，而动态Pages是收费的，对于用Hexo搭建的静态站点，自然是选择免费的静态Pages服务就足够了。于是解决方式1对我来说就不存在了，接着联想到之前我对部署在GitHub Pages上的个人站点进行了自定义域名绑定+域名解析设置，有些豁然开朗的感觉。\n由于我的个人站点是同时部署到GitHub Pages和Coding Pages上的，接着在阿里云域名解析里进行了配置：默认的解析线路将我的域名指向pages.coding.me，国外的解析路线则是指向了lewky.github.io。\n之所以这样配置，是因为国内部分地区无法直接访问GitHub，自然就无法访问我部署在GitHub上的个人站点，于是我又选择了Coding.net的Pages服务，这样国内用户就可以快速访问到我部署在Coding Pages的个人站点，而国外用户则是快速访问到Coding Pages上的个人站点。\n问题就出现在这里，因为我第一次申请SSL/TLS证书的时候，还没有解析境外的线路，所以很快就申请成功了。后来添加了国外线路的解析，这导致在Coding Pages的后台申请证书时无法通过验证，自然就申请失败了。\n解决方法 由于我是在阿里云购买的域名，于是登陆到阿里云域名解析的后台系统，打开个人域名的解析设置，暂停对于境外线路的解析。这里暂停就行了，一般来说大概需要5分钟左右的生效时间，毕竟DNS解析是存在缓存的。\n五分钟后，我又进入Coding Pages服务的后台，再一次申请SSL/TLS证书，果不其然，几秒钟后我申请证书成功，又给续了三个月。\n最后，再次返回阿里云域名解析的后台，将境外解析的线路再次启用，嗯，完美。\n这里顺便罗列下申请证书时所有可能遇到的错误与解决方案，以备不时之需。\n错误类型：urn:acme:error:connection 1、错误信息：DNS problem: NXDOMAIN looking up A for example.com\n错误原因：域名不存在 解决方式1：检查域名是否填写正确 解决方式2：到域名注册商处检查是否设置了 DNS 服务器 解决方式3：咨询 DNS 服务商是否支持解析该域名\n2、错误信息：DNS problem: SERVFAIL looking up A for exmaple.com\n错误原因：DNS 解析 A 记录出错 解决方式1：到域名注册商处检查是否设置了 DNS 服务器 解决方式2：咨询 DNS 服务商是否屏蔽了 Let’s Encrypt 的解析请求\n3、错误信息：DNS problem: SERVFAIL looking up CAA for example.com\n错误原因：DNS 解析 CAA 记录出错 解决方式1：到域名注册商处检查是否设置了 DNS 服务器 解决方式2：咨询 DNS 服务商是否支持解析 CAA 记录\n4、错误信息：DNS problem: query timed out looking up A for exmaple.com\n错误原因：DNS 解析超时 解决方式1：到域名注册商处检查是否设置了 DNS 服务器 解决方式2：咨询 DNS 服务商是否屏蔽了 Let’s Encrypt 的解析请求 解决方式3：重新申请 解决方式4：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器\n5、错误信息：Fetching http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxx\n错误原因：获取域名验证信息失败 解决方式1：重新申请 解决方式2：请确认是否启动了 DNS 的分区解析。如果有则要把国外的解析记录也设置成 CNAME 至 pages.coding.me。SSL 证书是通过 Let’s Encrypt API 申请。申请证书前需要验证域名，而 Let’s Encrypt 位于国外，所以需要保证 Let’s Encrypt 能通过您的域名正常访问到 Coding Pages 服务器以读取验证信息。\n错误类型：urn:acme:error:malformed 错误信息：Error creating new authz :: Name does not end in a public suffix\n错误原因：域名不以公共后缀结尾 解决方式：咨询域名注册商\n错误类型：urn:acme:error:unauthorized 1、错误信息：Invalid response from http://exmaple.com/.well-known/acme-challenge/xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx: xxxxxxxxx\n错误原因：无法获取正确的域名验证信息 解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io 解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器\n2、错误信息：The key authorization file from the server did not match this challenge\n错误原因：无法获取正确的域名验证信息 解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io 解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器\n3、错误信息：Error creating new authz :: “example.com” was considered an unsafe domain by a third-party API\n错误原因：无法获取正确的域名验证信息 解决方式：使用 https://transparencyreport.google.com/safe-browsing/search 查看域名存在的安全隐患，按照说明进行清理，清理完后到 https://www.stopbadware.org/ 提交审查请求。审查通过后，回到 Coding Pages 重新申请证书\n错误类型：urn:acme:error:unknownHost 错误信息：No valid IP addresses found for example.com\n错误原因：找不到可用 IP 地址 解决方式1：检查 DNS 的 CNAME 记录是否设置正确，静态 Pages 为 pages.coding.me，动态 Pages 为 pages.coding.io 解决方式2：检查域名的 DNS 是否将海外线路解析到 Coding Pages 的服务器 解决方式3：咨询 DNS 服务商是否屏蔽了 Let’s Encrypt 的解析请求\n错误类型：urn:acme:error:rateLimited 错误信息：Error creating new cert :: too many certificates already issued for exact set of domains: example.com\n错误原因：证书申请数目超出限制 解决方式：下周再重新申请，详情见 https://letsencrypt.org/docs/rate-limits/\n错误类型：urn:acme:error:rejectedIdentifier 错误信息：Error creating new authz :: Policy forbids issuing for name\n错误原因：相关政策禁止为此域名签发证书\nhexo-neat插件踩坑记录 由于在使用hexo-neat插件时，可以在命令窗口中看到各个文件的压缩率，于是我就开始捣鼓跳过哪些文件可以让效率更高。在鼓捣了一段时间之后，记录下使用该插件的一些注意事项，避免日后重蹈覆辙，也希望能对各位看官有所帮助。\n跳过压缩文件的正确配置方式 如果按照官方插件的文档说明来配置exclude，你会发现完全不起作用。这是因为配置的文件路径不对，压缩时找不到你配置的文件，自然也就无法跳过了。你需要给这些文件指定正确的路径，万能的配置方式如下：\n1 2 3 4 neat_css: enable: true exclude: - \u0026#39;**/*.min.css\u0026#39; 压缩html时不要跳过.md文件 .md文件就是我们写文章时的markdown文件，如果跳过压缩.md文件，而你又刚好在文章中使用到了NexT自带的tab标签，那么当hexo在生成静态页面时就会发生解析错误。这会导致使用到了tab标签的页面生成失败而无法访问。\n当初为了找到这个原因花了我两个晚上的时间，简直是夜不能寐。\n压缩html时不要跳过.swig文件 .swig文件是模板引擎文件，简单的说hexo可以通过这些文件来生成对应的页面。如果跳过这些文件，那么你将会发现，你的所有页面完全没有起到压缩的效果，页面源代码里依然存在着一大堆空白。\n文章标题含有双引号\u0026quot;导致页面渲染失败无法打开 在用Hexo写文章时，如果文章标题含有双引号\u0026quot;，也就是说如果在文件头里的title出现双引号，如下：\n1 2 3 --- title: Hexo - 文章标题含有双引号\u0026#34;导致页面渲染失败无法打开 --- 由于这里的写法属于yml语法，双引号属于特殊符号，上述的title的写法就会在执行hexo g时报错，当我们在浏览器里打开这篇文章的页面时就会渲染失败无法打开。\n解决方法 我们需要对这里的双引号进行转义，对于这些特殊字符，可以用对应的HTML字符实体来替换。\n对于双引号，其字符实体是\u0026amp;#34;或者\u0026amp;quot;。\n最终我们在hexo文章的文件头里，应该这样写：\n1 2 3 --- title: Hexo - 文章标题含有双引号\u0026amp;#34;导致页面渲染失败无法打开 --- 补充 当然，对于文件头之外的部分，则是属于markdown语法的部分，此外由于我们的文章会被swig渲染，同样有一些特殊字符，比如 {{}}，如果在代码块之外的地方使用到这些特殊字符，就会报错！对于不同的语言，各自的特殊字符是不一样的。\n这里补充下各种常用到的特殊字符的字符实体：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ! \u0026amp;#33; — 惊叹号 Exclamation mark \u0026#34; \u0026amp;#34; \u0026amp;quot; — 双引号 Quotation mark # \u0026amp;#35; — 数字标志 Number sign $ \u0026amp;#36; — 美元标志 Dollar sign % \u0026amp;#37; — 百分号 Percent sign \u0026amp; \u0026amp;#38; \u0026amp;amp; — 与符号(\u0026amp;) Ampersand \u0026#39; \u0026amp;#39; — 单引号 Apostrophe ( \u0026amp;#40; — 小括号左边部分 Left parenthesis ) \u0026amp;#41; — 小括号右边部分 Right parenthesis * \u0026amp;#42; — 星号 Asterisk + \u0026amp;#43; — 加号 Plus sign \u0026lt; \u0026amp;#60; \u0026amp;lt; 小于号 Less than = \u0026amp;#61; — 等于符号 Equals sign - \u0026amp;#45; \u0026amp;minus; — 减号 \u0026gt; \u0026amp;#62; \u0026amp;gt; — 大于号 Greater than ? \u0026amp;#63; — 问号 Question mark @ \u0026amp;#64; — Commercial at [ \u0026amp;#91; — 中括号左边部分 Left square bracket \\ \u0026amp;#92; — 反斜杠 Reverse solidus (backslash) ] \u0026amp;#93; — 中括号右边部分 Right square bracket { \u0026amp;#123; — 大括号左边部分 Left curly brace | \u0026amp;#124; — 竖线Vertical bar } \u0026amp;#125; — 大括号右边部分 Right curly brace 如果想要在文章中使用空格，直接输入空格是没用的，同样可以使用字符实体来代替，即\u0026amp;nbsp;。这个代表不间断空格：non-breaking space。\nHexo3.X.X版本无法生成baidusitemap 在安装了hexo-generator-baidu-sitemap后，运行hexo g报错如下：\nerror.jpg\r到了作者的GitHub上发现也有人提了相关的issue，不过都过了相当一段时间了依然没有解决，最后还是自己动手丰衣足食，解决方法很简单，因为Hexo3.X.X版本改变了代码导致toArray()无法使用，我们直接将该方法去掉就行了。\n打开 node_modules\\hexo-generator-baidu-sitemap\\baidusitemap.ejs，将这里边的 post.tags.toArray() 和 post.categories.toArray() 改成 post.tags 和 post.categories，简单的说就是把这里的 toArray() 去掉，新版本的Hexo的tags和categories可以直接遍历。\ncode.jpg\r接下来重新运行 hexo g 和 hexo s，本地调试成功~\nCNAME文件在每次部署后就没了 一般我们会将Hexo博客搭建到Github上，如果在Github上为其配置一个自定义的域名时，会自动在项目仓库根目录下新添加一个CNAME文件。但是这里有个问题，如果将Hexo博客重新部署一遍后，Github仓库里的这个CNAME文件就会消失掉，又需要重新配置一遍。\n其实这里有个技巧，我们可以将需要上传部署到Github的文件都放在source文件夹里，例如CNAME文件、favicon.ico、或者其他的图片等等，这样在执行hexo d这个命令之后，这些文件就不会被删除了。\nHexo在执行命令时是不会删除掉source目录下的文件的，我们可以在该目录下随意增加其他文件或者文件夹，建议在该目录下添加子文件夹，然后在子文件夹里添加文件，这样便于文件分档归类。\nTemplate render error unexpected token 发现在使用hexo g时报错如下：\n1 2 FATAL Something\u0026#39;s wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Template render error: unexpected token: }} 一时间很诧异，因为前几天还可以正常生成静态文件，现在忽然就挂了。看看报错的信息，说是模板渲染失败，因为出现了预期外的标志。因为我刚刚写了新的文章，就出现了这个错误，可以想象到，应该是文章中出现了特殊字符导致hexo命令执行失败了。\n百度了下，确实如此。因为在Hexo中，有些特殊字符如果不进行转义的话，在渲染模板时就会报错。\n如果遇到类似的报错，解决方法很简单，就是对这些特殊字符进行转义，需要使用转义标签来将这些特殊字符包括起来，如下：\n1 2 3 {% raw %} 特殊字符 {% endraw %} 比如我的报错是因为使用{% raw %}}}{% endraw %}，那么就需要对这对大括号进行转义：\n1 2 3 {% raw %} {{ something... }} {% endraw %} 如果是在引用块里，可以随便使用特殊字符；如果是行内引用块，就需要进行转义了。\n记录一次Pages服务部署失败的原因 问题与分析 某天忽然发现，一直运行得好好的Pages服务部署失败了，GitHub Pages报错如下：\n1 2 Your site is having problems building: The tag cq on line 3 in source/high/index.md is not a recognized Liquid tag. For more information, see https://help.github.com/articles/page-build-failed-unknown-tag-error/. 与此同时，Coding Pages同样也报错了：\n1 2 3 4 5 6 Starting jekyll build. \u0026gt; jekyll build --safe Configuration file: /usr/src/app/_config.yml jekyll 3.6.2 | Error: The next theme could not be found. Jekyll build exit with code 1. Fail to build jekyll site. 首先我使用的是Hexo的next主题，而根据GitHub Pages的报错信息来看，是说在source/high/index.md里使用到了一个不认识的cq标签。\n这个标签是next主题自带的，使用该标签快一年了，还是第一次遇到报这个错。接着根据Coding Pages的报错来看，则是说/usr/src/app/_config.yml里找不到jekyll的主题。\n这就很奇怪了，我使用的明明是hexo，怎么忽然就变成jekyll了？一阵瞎折腾过后，一直部署失败。我忽然想起来一个事情，我之前曾经拿本地的博客仓库的git配置练过手，难道和这个有关？\n我开始查找本地博客仓库的git配置，我是使用hexo-deployer-git这个插件来将本地生成的静态博客发送到远程仓库的。\n当我在本地在执行hexo g后，会在博客根目录下生成一个public文件夹，这个文件夹里的文件组合起来就是一个完整的静态博客。\n接着如果执行hexo d，就会把这个public文件夹的东西完完整整拷贝到.deploy_git文件夹里，然后会把该文件夹里的所有文件全部推送push到远程库。之后会触发Pages服务的钩子去build项目，然后部署到网站上。\n发现线索 我打开public文件夹，发现生成出来的文件很正常，接着打开.deploy_git文件夹，发现也很正常，接着查看远程库里的文件，终于发现了问题。\n在远程库的分支里，根本就没有hexo相关的文件，至此算是找到原因了。\n很显然，我在执行hexo d时出了问题，没能正常将文件push到远程库，于是部署就失败了。之前该命令是没问题的，可之前我曾经动过手脚，修改过博客项目里的git配置，手动修改了.git里的文件，莫非这就是问题的根源？\n解决方法 基于以上的猜想，我直接删掉了本地博客项目的.deploy_git文件夹，重新执行命令：\n1 2 hexo cl hexo g -d 等待片刻后，我终于看到远程部署成功，我的个人站点再次运转成功！\n皇天不负有心人啊！原因终于明了，是.deploy_git文件夹出现问题，删掉该文件夹，重新运行hexo d即可。\n记录下这次的遭遇，遇到问题应该静下心来，仔细分析，才不容易瞎折腾~\n参考链接 Coding Pages的官方文件：Coding Pages 常见问题 Hexo 特殊符号的转义问题 HTML 字符实体 常用特殊符号的HTML代码(HTML字符实体) Hexo的一个小BUG(Template render error) Hexo 异常 - Template render error unexpected token ","permalink":"https://lewky.cn/posts/hexo-4.html/","tags":["Hexo","NexT主题","踩坑记录"],"title":"Hexo系列(4) - NexT主题踩坑记录"},{"categories":["Hexo系列"],"contents":"前言 本系列主要介绍和hexo-NexT主题相关的一些写作技巧，可能会涉及到部分前端知识(不了解也没关系，能用就行)。我之所以选择hexo-NexT来搭建个人网站，一个很重要的原因就是因为简单、方便、快捷！不需要服务器，直接通过Markdown来进行写作，不仅文章布局美观，还可以节省大量的时间。\n此外NexT主题很贴心地自带了一些样式，让你可以不需要自己写一大堆html标签就能得到美观的页面效果。\n本系列针对的是NexT 5.1.4版本的样式，请到我的个人站点更加直观地看到页面效果，不便之处还请见谅。 -\u0026gt;这是本文在个人站点的链接\u0026lt;-\n文本居中引用 该样式可以将一段文本居中显示，并在首尾各自生成一个引号图片，效果如下：\nhexo-write-1.jpg\r源码如下：\n1 2 3 4 5 {% cq %} 人类的本质是复读机。 ——**复读机** {% endcq %} 原本该样式的字体是黑色的，我把它改成红色了。这里的cq是标签别名，也可以用完整的标签名：\n1 2 3 4 5 {% centerquote %} 人类的本质是复读机。 ——**复读机** {% endcenterquote %} 图片突破容器宽度限制 使用此标签引用图片时，图片将自动扩大 26%，并突破文章容器的宽度。 此标签使用于需要突出显示的图片, 图片的扩大与容器的偏差从视觉上提升图片的吸引力。效果如下：\n附上一张wlop大大的saber~\nhexo-write-2.jpg\r使用方式如下：\n1 2 3 4 {% fullimage /image-url, alt, title %} \u0026lt;!-- 别名 --\u0026gt; {% fi /image-url, alt, title %} 这里的alt和title可以不写，alt属性是找不到图片时显示的文本，title是鼠标停留在图片上时显示的文本。\nNote标签 本标签出自于Bootstrap，使用前需要先启用主题配置文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 # 主题自带的标签样式，有 note、label、tabs 三种 # Note tag (bs-callout). note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. # Note标签的样式有四种： # - simple：默认的样式，也是Bootstrap Callout旧版本的样式。 # - modern：Bootstrap Callout新版本(v2-v3)的样式。 # - flat：该样式会连同背景也一起渲染，如同Mozilla或者StackOverflow那样。 # - disabled：禁用本Note标签。 style: flat icons: true border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0 效果如下：\nhexo-write-3.jpg\rNote标签一共有以上六种类型：default,primary,success,info,warning,danger，源码如下：\n1 2 3 4 5 6 {% note default %}default{% endnote %} {% note primary %}primary{% endnote %} {% note success %}success{% endnote %} {% note info %}info{% endnote %} {% note warning %}warning{% endnote %} {% note danger %}danger{% endnote %} Label标签 使用前同样需要启用配置：\n1 2 # Label tag. label: true 效果如下： hexo-write-4.jpg\r和Note标签一样，同样是六种类型。@前面是类型，@后面是显示的文本内容。这个label标签的样式并不好看，我基本不用。\nTab标签 这个标签和浏览器的tab是类似的，使用前也需要启用配置：\n1 2 3 4 5 6 7 # Tabs tag. tabs: enable: true transition: tabs: true labels: true border_radius: 3 效果如下：\nhexo-write-5.jpg\r源码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 {% tabs 贴吧, 1 %} \u0026lt;!-- tab android开发吧 --\u0026gt; 有问题为什么不先问问隔壁Java吧呢？ \u0026lt;!-- endtab --\u0026gt; \u0026lt;!-- tab java吧 --\u0026gt; 有问题为什么不先问问隔壁C++吧呢？ \u0026lt;!-- endtab --\u0026gt; \u0026lt;!-- tab c++吧 --\u0026gt; 有问题为什么不先问问隔壁C语言吧呢？ \u0026lt;!-- endtab --\u0026gt; \u0026lt;!-- tab c语言 --\u0026gt; 有问题为什么不先问问神奇海螺吧呢？ \u0026lt;!-- endtab --\u0026gt; \u0026lt;!-- tab 神奇海螺 --\u0026gt; 有问必答不知道 \u0026lt;!-- endtab --\u0026gt; {% endtabs %} 简单介绍下常规用法：\n源码第一行的数字表示默认显示哪一个tab页面，如果是-1则表示隐藏所有tab页面内容。 如果不为每个tab单独制定名字，则会以第一行源码的名字为每个tab命名，并自动在名字后加上1,2,3...以示区分。 tab的名字支持fontawesome图标，使用方法是@加上图标的名字，例如@home，注意该图标需要添加在tab名字的最后，渲染时图标会自动放在名字最前面，比如：\u0026lt;!-- tab android开发吧@home --\u0026gt; 更多用法可以参考该文章\n按钮标签样式 这个样式和阅读全文那个按钮一样，效果如下：\nhexo-write-6.jpg\r源码如下：\n1 {% btn https://www.baidu.com, 点击前往百度, download fa-lg fa-fw %} 更多用法可以参考该文章 此外还有其他的标签样式的使用方法，请参考本文末尾的参考链接文章。\n如何在文章中插入图片 网上有不少办法，有的是启用配置文件中的属性，有的则是安装插件，这里只介绍最简单的一种方法。\n在 source/ 目录下新建一个文件夹，比如 images；在该文件夹下存放各种图片资源，比如 test.jpg； 新建一篇文章，在文章中使用markdown的插入图片语法： 1 ![test](/images/test.jpg) 这里使用的是绝对路径，如果使用相对路径比如images/test.jpg可能会无法访问到该图片资源。建议在博客或者配置中都使用绝对路径。 修改默认的post和draft的模板 通过hexo n post XXX或者hexo n draft XXX所生成的文章或草稿是根据默认的模板来生成的，我们可以自己来定制想要的模板。\n在站点根目录下的 scaffolds 文件夹下，存放着 draft.md， page.md 和 post.md这三个文件夹，一般我们只需要修改draft和post这两个模板就行了。\n我们可以在模板的文件头里添加自己想要的格式，如下：\n1 2 3 4 5 6 --- title: {{ title }} date: {{ date }} tags: categories: --- 这样使用命令生成的draft或post都会默认带有上边的文件头了。\n添加新的模板来生成定制的post 我们还可以在 scaffolds 目录下添加新的模板文件，比如 Hexo.md，其模板内容如下：\n1 2 3 4 5 6 7 8 --- title: {{ title }} date: {{ date }} tags: - Hexo categories: - Hexo --- 然后通过命令：\n1 hexo n hexo XXX 注意，这里的第二个 hexo 指的是我们刚刚新添加的模板文件 hexo.md 的文件名；这里的文件名和命令都是大小写不敏感的。\n执行完命令会在 source/_posts 目录下生成与 hexo.md 模板相对应的文章。\n如何使用上标、下标 Markdown可以和HTML的语法兼容，可以通过HTML的上标和下标标签来实现效果：\n标签 写法 效果 上标 2\u0026lt;sup\u0026gt;10\u0026lt;/sup\u0026gt; 210 下标 H\u0026lt;sub\u0026gt;2\u0026lt;/sub\u0026gt;O H2O 这里解释下，sup指的是superscript上标，sub指的是subscript下标。\n如何给文本加下划线 Markdown可以和HTML的语法兼容，可以通过HTML的\u0026lt;u\u0026gt;标签来实现效果：\n写法 效果 \u0026lt;u\u0026gt;下划线\u0026lt;/u\u0026gt; 下划线 这里解释下，u指的是underline下划线。\n注意：尽量不要给文本加下划线，因为这会和超链的表现形式混淆，会被误以为是个超链。\n如何给文本加删除线 用Html的\u0026lt;s\u0026gt;来实现：\n1 \u0026lt;s\u0026gt;这段文字已经被删除\u0026lt;/s\u0026gt; 也可以用~~来实现：\n1 ~~这段文字已经被删除~~ 效果如下：\n这段文字已经被删除\n如何添加分隔线 连续使用三个相同的星号、下划线或者中划线即可，符号之间可以有空格，如下：\n1 2 3 4 5 *** * * * ** * 效果如下：\n下面是分隔线\n上面是分隔线\n参考链接 官方文档：内置标签 - NexT 使用文档 打造个性超赞博客Hexo+NexT+GitHubPages的超深度优化 样式汇总 在markdown中如何加入上标、下标？ HTML\u0026lt;u\u0026gt;标签 ","permalink":"https://lewky.cn/posts/hexo-3.html/","tags":["Hexo","NexT主题","写作技巧"],"title":"Hexo系列(3) - NexT主题和Markdown的写作技巧"},{"categories":["Hexo系列"],"contents":"前言 网上有不少相关的帖子，不过版本会比较旧，而不同版本可能存在代码不同的问题，不过大部分还是大同小异，本系列就不啰嗦重复了，基本只会按照本人所使用的版本以及个人所使用到的内容来进行介绍。\n该系列是对我所使用的Next主题进行个性化定制，涉及到js和css等的修改，还有各种插件的使用，包括使用过程中的一些踩坑记录；另外也会对Next主题进行一些写作技巧的介绍与运用，希望能对大家有所帮助。有疑问的朋友可以给我留言，我会尽可能回复O(∩_∩)O。\n我所使用的Hexo和NexT的版本如下：\n1 2 hexo: 3.7.1 next: 5.1.4 另外本文篇幅太长，阅读体验不好，将其进行分章如下：\nHexo系列(2.0) - NexT主题美化与博客功能增强 · 第一章 Hexo系列(2.1) - NexT主题美化与博客功能增强 · 第二章 关于配置文件 对于使用了Next主题的Hexo静态博客，存在着两个至关重要的配置文件_config.yml。在本系列中，统一将位于站点根目录下的该文件称为站点配置文件，将位于themes\\next目录下的该文件称为主题配置文件。\n准备工作：添加美化博客的相关文件 本系列会使用到大量的css与JavaScript的相关内容，为了更有效率与可观赏性的美化博客，我们将这些美化相关的东西都尽可能地写到一类文件中，方便日后查询与修改。譬如下边的几个文件里，就存放了博客的大部分美化内容：\nthemes/next/source/css/_custom/custom.styl themes/next/source/js/src/custom.js themes/next/layout/_partials/head/custom-head.swig themes/next/layout/_custom/custom-foot.swig 除了第一个文件custom.styl保存的是css代码，另外三个文件都是保存的js代码。这几个文件分别会在页面的以下位置中被引入：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; .... {{ custom.styl }} //css .... {{ custom-head.swig }} //js .... \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; .... .... {{ custom-foot.swig }} //js {{ custom.js }} //js \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这里的custom.styl，custom-head.swig是原本的NexT主题自带的，另外两个是我自己添加的，之所以又添加了另外两个js文件，是因为在页面的不同地方引入js文件会对页面产生不一样的效果与影响。\n添加 custom-foot.swig 文件 在themes/next/layout/_custom/目录下添加custom-foot.swig文件，该文件内容如下：\n1 2 3 4 5 {# Custom foot in body, Can add script here. #} \u0026lt;!-- 自定义的js文件 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/js/src/custom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 接着修改themes\\next\\layout\\_layout.swig，在body标签的闭合标签前添加一行代码，表示将我们新添加的custom-foot.swig文件包括进去：\n1 2 3 4 5 6 \u0026lt;body\u0026gt; .... {% include \u0026#39;_custom/custom-foot.swig\u0026#39; %} \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这个文件的作用是负责引入我们想要的js文件，比如其他第三方js的cdn等等。因为页面在引入js文件时是阻塞式的，如果我们在页面的最开始就引入这些js文件，而这些文件又比较大，会造成页面在渲染时长时间处于白屏状态。\n添加 custom.js 文件 在themes/next/source/js/src目录下添加custom.js文件，该文件用来存放我们自己写的js函数等等，需要注意的是，我们之前是在custom-foot.swig文件中的script标签里引入了该文件，也就是说，在该文件里，我们不能再自己添加script标签了，直接书写js函数就行了，如下所示：\n1 2 3 4 /* 返回随机颜色 */ function randomColor() { return \u0026#34;rgb(\u0026#34;+~~(255*Math.random())+\u0026#34;,\u0026#34;+~~(255*Math.random())+\u0026#34;,\u0026#34;+~~(255*Math.random())+\u0026#34;)\u0026#34;; } 改变页面的字体大小 打开 themes\\next\\source\\css\\_variables\\base.styl，该文件保存了一些基础变量的值，我们找到$font-size-base，将值改为16px。\n1 2 // Font size $font-size-base = 16px 这个文件里定义了很多常量，有兴趣的可以自己去琢磨琢磨，修改一些其他的变量。\n文章启用tags和categories 可能是该版本的NexT主题的关系，在我第一次使用NexT主题时，折腾了很久都没办法让菜单栏里的tags和categories的页面生效，一直显示白屏。后来终于在知乎找到答案，首先我们需要将某篇文章设置tags和categories，如下：\n1 2 3 4 5 6 7 8 --- title: Test tags: - MyTag categories: - MyCategory date: 20xx-xx-xx xx:xx:xx --- 接下来是重点了，首先确定是否已经在主题配置文件中启用了tags和categories这两个菜单，如下：\n1 2 3 4 5 menu: home: / || fas fa-home archives: /archives/ || fas fa-archive categories: /categories/ || fas fa-th tags: /tags/ || fas fa-tags 接着确定是否在source目录下是否已经存在tags和categories这两个文件夹，如果不存在需要运行下边的命令：\n1 2 hexo n page tags hexo n page categories 运行之后会在source目录下生成对应的两个文件夹，在文件夹下会存在一个index.md文件，打开这两个index.md文件，分别添加type: tags和type: categories，如下：\n1 2 3 4 5 --- title: 标签 date: 20xx-xx-xx xx:xx:xx type: tags --- 1 2 3 4 5 --- title: 分类 date: 20xx-xx-xx xx:xx:xx type: categories --- 接下来重新使用本地调试三连，就可以看到tags和categories这两个菜单的页面显示正常了。\n去掉图片边框 NexT主题默认会有图片边框，不太好看，我们可以把边框去掉。打开 themes\\next\\source\\css\\_custom\\custom.styl，添加如下CSS代码：\n1 2 3 4 5 6 7 8 /* 去掉图片边框 */ .posts-expand .post-body img { border: none; padding: 0px; } .post-gallery .post-gallery-img img { padding: 3px; } 修改语法高亮的主题 语法高亮就是在引入代码时让代码呈现特定的样式，而在Markdown文件中语法高亮的使用方法是在引入代码的前一行添加三个反引号加上使用的语言名字，然后在引入代码的下一行使用三个反引号结尾。\n如下所示的格式，就表示html代码的语法高亮：\n1 \u0026lt;h2\u0026gt;Hello World!\u0026lt;/h2\u0026gt; 其源码如下：\n1 \u0026lt;h2\u0026gt;Hello World!\u0026lt;/h2\u0026gt; 由于NexT默认的语法高亮的主题比较一般，我们可以换成其他的主题，比如我所使用的就是黑色的主题。\n打开主题配置文件，修改如下配置：\n1 2 3 4 5 6 # 语法高亮主题 # Code Highlight theme # Available value: # normal | night | night eighties | night blue | night bright # https://github.com/chriskempson/tomorrow-theme highlight_theme: night eighties 指定Markdown的解析器 上边我们设置了语法高亮后，虽然在本地调试没有问题，然而当我们将博客部署到GitHub Pages和 Coding Pages后却发现，前者的页面不支持语法高亮，而后者支持。百度后才知道原来是因为 GitHub 默认使用的 Markdown 解析器不支持语法高亮，解决方法如下：\n打开站点配置文件_config.yml，在末尾添加如下内容：\n1 2 3 markdown: redcarpet redcarpet: extensions: [\u0026#34;fenced_code_blocks\u0026#34;, \u0026#34;autolink\u0026#34;, \u0026#34;tables\u0026#34;, \u0026#34;strikethrough\u0026#34;] 接下来重新执行部署三连命令，就会发现 GitHub Pages 上部署的页面语法高亮显示成功了。\n添加背景图片轮播 动态背景图片插件jquery-backstretch jquery-backstretch是一款简单的jQuery插件，可以用来设置动态的背景图片，以下是官方网站的介绍。\nA simple jQuery plugin that allows you to add a dynamically-resized, slideshow-capable background image to any page or element.\n可以直接在页面中引入该插件的cdn来调用函数，也可以直接下载下来使用，这是官方地址。\n鉴于cdn的地址偶尔发发生改变，这里提供该插件的GitHub仓库地址：https://github.com/jquery-backstretch/jquery-backstretch\n如果本文提及的cdn地址不正确，可能是发生了迁移，建议自行百度最新的cdn地址。\n下面是jquery-backstretch的使用方法。\n引入该插件的cdn 打开themes\\next\\layout\\_custom\\custom-foot.swig，引入该背景图片插件的cdn：\n1 2 3 4 5 6 7 8 {# Custom foot in body, Can add script here. #} \u0026lt;!-- 图片轮播js文件cdn --\u0026gt; \u0026lt;script src=\u0026#34;https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;!-- 自定义的js文件 --\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;/js/src/custom.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 需要注意的是，我们要引入的插件cdn，都需要在自定义的js文件custom.js之前引入才行！否则，插件会在访问页面时无法生效，可以在浏览器的控制台看到报错。\n调用backstretch函数 在themes\\next\\source\\js\\src\\custom.js中添加如下代码：\n1 2 3 4 5 6 7 8 /* 轮播背景图片 */ $(function () { $.backstretch([ \u0026#34;/images/background/saber1.jpg\u0026#34;, \u0026#34;/images/background/saber2.jpg\u0026#34;, \u0026#34;/images/background/bg1.jpg\u0026#34; ], { duration: 60000, fade: 1500 }); }); 这里可以随意添加你想要轮播的图片，但要确保图片路径是正确的，比如我的背景图片就存放在站点根目录下的images/background/目录下。\n然后duration指的是轮换图片的时间，单位是毫秒，也就是说这里的代码表示一分钟就轮换到下一张图片；\nfade指的是轮换图片时会有个渐进渐出的动作，而这个过程需要花费的时间单位也是毫秒，如果不加上这个参数，就表示离开轮换成下一张图片。\n注意这里的$.backstretch指的是对整个页面设置背景图片，我们也可以专门给某个元素设置背景图片，如下：\n1 2 3 4 $(function () { $(\u0026#34;.saber1\u0026#34;).backstretch([\u0026#34;/images/background/saber1.jpg\u0026#34;]); $(\u0026#34;.saber2\u0026#34;).backstretch([\u0026#34;/images/background/saber2.jpg\u0026#34;]); }); 如果只有一张图片，就没必要设置duration和fade参数了。\n为背景图片设置样式 虽然我们设置好了背景图片，但如果页面的许多元素是不透明的，背景图片可能并不能很好地被看见，所以我们可以对背景图片和其他的页面元素进行设置样式。\n首先为背景图片设置透明度，因为有的图片颜色比较深厚，而页面多为白色，然后造成喧宾夺主的感觉。\n1 2 3 4 /* 背景图片透明度 */ .backstretch { opacity: .75; } 接下来设置页面元素透明度，需要注意的是，如果我们在主题配置文件中启用了搜索功能，那么就不能简单粗暴地直接将整个页面都设置透明度，这会导致搜索框失效，无法正常使用。原因是因为搜索框是通过jQuery临时添加的，如果整个页面都设置了透明度，会导致搜索框的z-index失效而无法触发点击事件。\n我在折腾了一段时间后，终于想到了个取巧的方法，那就是将搜索框的父元素设置为白色透明的，而其他页面元素则直接设置透明度，如下：\n1 2 3 4 5 6 7 /* 页面透明度 */ .content-wrap, .sidebar { opacity: .9 !important; } .header-inner { background: rgba(255, 255, 255, 0.9) !important; } 添加GitHub彩带和GitHub Corner 页面右上角添加GitHub彩带 你可以在这里找到一共12种样式的GitHub彩带，复制其中的超链代码。\n在themes\\next\\layout\\_layout.swig目录下找到头部彩带相关的代码：\n1 \u0026lt;div class=\u0026#34;headband\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; 在这里的div标签内部添加我们刚刚复制的超链代码，并修改超链指向你的GitHub地址：\n1 2 3 \u0026lt;div class=\u0026#34;headband\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://github.com/lewky\u0026#34;\u0026gt;\u0026lt;img style=\u0026#34;position: absolute; top: 0; right: 0; border: 0;\u0026#34; src=\u0026#34;https://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png\u0026#34; alt=\u0026#34;Fork me on GitHub\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 当然我本人并不是很推荐用这种方法，因为这个超链使用的图片有时候会加载很久，最后图片还是挂掉了，我是直接将图片保存到站点的images目录下，然后直接使用自己站点的图片，这样可以避免加载过久甚至图片挂掉的情况。\n1 2 3 \u0026lt;div class=\u0026#34;headband\u0026#34;\u0026gt; \u0026lt;a href=\u0026#34;https://github.com/lewky\u0026#34; target=\u0026#34;_blank\u0026#34;\u0026gt;\u0026lt;img style=\u0026#34;position: absolute; top: 0; right: 0; border: 0;\u0026#34; src=\u0026#34;/images/headband/forkme_right_red.png\u0026#34; alt=\u0026#34;Fork me on GitHub\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 我只找到了10张彩带图片，可以直接在我的GitHub项目中找到这些图片并复制到自己的站点上。\n页面右上角添加GitHub Corner 这是我后来在其他博客中见到的，可能是6.x.x版本的NexT主题自带的，由于我使用的主题版本较低，只能自己添加了。\n还是在themes\\next\\layout\\_layout.swig目录下，找到如下代码：\n1 2 3 \u0026lt;header id=\u0026#34;header\u0026#34; class=\u0026#34;header\u0026#34; itemscope itemtype=\u0026#34;http://schema.org/WPHeader\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;header-inner\u0026#34;\u0026gt; {%- include \u0026#39;_partials/header.swig\u0026#39; %} \u0026lt;/div\u0026gt; \u0026lt;/header\u0026gt; 我们在这个header标签的下边，添加一个超链代码：\n1 2 3 4 5 6 \u0026lt;a href=\u0026#34;https://github.com/lewky\u0026#34; class=\u0026#34;github-corner\u0026#34; target=\u0026#34;_blank\u0026#34; title=\u0026#34;Follow me on GitHub\u0026#34; aria-label=\u0026#34;Follow me on GitHub\u0026#34;\u0026gt; \u0026lt;svg width=\u0026#34;80\u0026#34; height=\u0026#34;80\u0026#34; viewBox=\u0026#34;0 0 250 250\u0026#34; style=\u0026#34;fill:#222; color:#fff; position: absolute; top: 0; border: 0; right: 0;\u0026#34; aria-hidden=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;path d=\u0026#34;M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\u0026#34;\u0026gt;\u0026lt;/path\u0026gt;\u0026lt;path d=\u0026#34;M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\u0026#34; fill=\u0026#34;currentColor\u0026#34; style=\u0026#34;transform-origin: 130px 106px;\u0026#34; class=\u0026#34;octo-arm\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;path d=\u0026#34;M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\u0026#34; fill=\u0026#34;currentColor\u0026#34; class=\u0026#34;octo-body\u0026#34;\u0026gt;\u0026lt;/path\u0026gt; \u0026lt;/svg\u0026gt; \u0026lt;/a\u0026gt; 将上边的超链的href改为自己的GitHub地址，然后我们需要修改这个超链的样式，在上文中提及的themes/next/source/css/_custom/custom.styl里添加如下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 /* GitHub Cornor */ .github-corner :hover .octo-arm { animation: octocat-wave 560ms ease-in-out; } @media (max-width: 991px) { .github-corner \u0026gt;svg { fill: #fff !important; color: #222 !important; } .github-corner .github-corner:hover .octo-arm { animation: none; } .github-corner .github-corner .octo-arm { animation: octocat-wave 560ms ease-in-out; } } @-moz-keyframes octocat-wave { 0%, 100% { -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); } 20%, 60% { -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); } 40%, 80% { -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); } } @-webkit-keyframes octocat-wave { 0%, 100% { -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); } 20%, 60% { -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); } 40%, 80% { -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); } } @-o-keyframes octocat-wave { 0%, 100% { -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); } 20%, 60% { -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); } 40%, 80% { -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); } } @keyframes octocat-wave { 0%, 100% { -webkit-transform: rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); -o-transform: rotate(0); transform: rotate(0); } 20%, 60% { -webkit-transform: rotate(-25deg); -moz-transform: rotate(-25deg); -ms-transform: rotate(-25deg); -o-transform: rotate(-25deg); transform: rotate(-25deg); } 40%, 80% { -webkit-transform: rotate(10deg); -moz-transform: rotate(10deg); -ms-transform: rotate(10deg); -o-transform: rotate(10deg); transform: rotate(10deg); } } 这段长长的css代码是令这个GitHub Corner能够呈现出响应式的效果，当你缩放页面的时候，你会发现页面右上角的GitHub的吉祥物——章鱼猫(Octocat)会随着页面的大小变化而变化！\n此外，当我们将鼠标移动到GitHub Corner的上方时，章鱼猫的手臂还会摆动一下哦~\n下边是GitHub Corner的项目地址，一共有10种颜色样式，任君选择！\nGitHub Corners项目地址 站点首页不显示文章全文 文章摘要设置 打开主题配置文件 _config.yml 文件，找到如下：\n1 2 3 4 5 # Automatically Excerpt. Not recommend. # Please use \u0026lt;!-- more --\u0026gt; in the post to control excerpt accurately. auto_excerpt: enable: false length: 150 把这里的false改为true就可以了在首页启动显示文章预览了，length是显示预览的长度。\n这里我们可以通过在文章使用\u0026lt;!-- more --\u0026gt;标志来精确控制文章的摘要预览，比如这篇文章就是在这个段落的末尾添加了该标志，所以本文在首页的预览就会显示到这个段落为止。\n强烈推荐使用该\u0026lt;!-- more --\u0026gt;标志来控制文章的摘要预览，因为这种方式可以让摘要也按照css文件中的样式来渲染。如果使用了自动摘要的功能，你会发现文章摘要是一大团没有样式的文本，很是难看。\n其他的文章配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 # --------------------------------------------------------------- # Post Settings # --------------------------------------------------------------- # Automatically scroll page to section which is under \u0026lt;!-- more --\u0026gt; mark. # 自动将页面滚动到\u0026lt;!-- more --\u0026gt;标记下的地方。 scroll_to_more: false # Automatically saving scroll position on each post/page in cookies. # 自动保存每篇文章或页面上一次滚动的地方。 save_scroll: false # Automatically excerpt description in homepage as preamble text. # 自动在首页对文章进行摘要描述作为前言文本。 excerpt_description: true # Automatically Excerpt. Not recommend. # Please use \u0026lt;!-- more --\u0026gt; in the post to control excerpt accurately. # 不推荐使用自动摘要。 # 请在文章中使用\u0026lt;!-- more --\u0026gt;标志来精确控制摘要长度。 auto_excerpt: enable: true length: 200 # Post meta display settings # 文章元数据展示设置 post_meta: # 文本显示 item_text: true # 创建时间 created_at: true # 更新时间 # 这个更新时间有点问题，因为每次重新生成文章/部署时都会刷新更新时间，不建议使用 updated_at: false # 目录分类 categories: true # Post wordcount display settings # Dependencies: https://github.com/willin/hexo-wordcount # 文章字数展示设置 post_wordcount: # 文本显示 item_text: true # 文章字数统计 wordcount: true # 阅读时长 min2read: true # 站点总字数统计 totalcount: true # 该post_wordcount的所有设置另起一行显示 separated_meta: true 使用hexo-neat插件压缩页面静态资源 为什么要压缩页面静态资源 对于个人博客来说，优化页面的访问速度是很有必要的，如果打开你的个人站点，加载个首页就要十几秒，页面长时间处于空白状态，想必没什么人能够忍受得了吧。我个人觉得，如果能把页面的加载时间控制在三四秒内，就很不错了。\n那么怎么提高hexo这个静态博客的页面加载速度呢？可以从以下的几个方面去入手：\n将js文件尽可能放置到body的闭合标签之前，因为在加载或者引入js文件时是阻塞式的，如果我们在页面的最开始就引入这些js文件，而这些文件又比较大，会造成页面在渲染时长时间处于白屏状态。 尽量避免去引用访问速度非常低下的cdn或者图片，可以改用访问速度更快的cdn，或者将难以迅速加载的图片保存到自己的站点目录下，以免在加载图片时耗费了大量的时间，最后还加载不出来。 对页面的静态资源进行压缩，包括css、js和html等文件。我们自己添加的css和js文件为了可读性，往往会有很多换行和空格，这些对于浏览器来说并没什么卵用，甚至还会降低渲染页面的速度。至于html文件，由于Markdown转成html的bug，会导致页面存在大量的空白，如果你查看下页面的源代码，就会发现这些大量的空白符，十分难看。这也会造成页面渲染的性能问题。 hexo的压缩静态资源插件 网上有很多相关的博文，常规的做法是使用gulp来进行压缩，gulp是Node.js下的自动构建工具，通过一列的task执行步骤进行自动流程化处理。\n使用这种方法会比较麻烦，每次压缩时还需要输入额外的命令，比较繁琐，个人不是很喜欢，有兴趣的可以去自己了解下相关的东西。这篇教程里很多详细的说明，里边有说到gulp的使用，绝对的精品文章。\n这里我选择的是由rozbo大佬开发的hexo-neat压缩插件，配置简单，无需额外命令，你只要使用原本的调试三连或者部署三连就可以自动帮你完成静态资源的压缩！\n如何使用hexo-neat 首先在站点根目录下安装hexo-neat，如下：\n1 npm install hexo-neat --save 接着为站点配置文件添加相关配置，下边是我自己站点的相关配置，直接添加到站点配置文件_config.yml的末尾就可以。可以安装自己的需求去自定义配置，不过有些注意事项，可以参考我后文的踩坑记录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 # hexo-neat # 博文压缩 neat_enable: true # 压缩html neat_html: enable: true exclude: # 压缩css neat_css: enable: true exclude: - \u0026#39;**/*.min.css\u0026#39; # 压缩js neat_js: enable: true mangle: true output: compress: exclude: - \u0026#39;**/*.min.js\u0026#39; - \u0026#39;**/jquery.fancybox.pack.js\u0026#39; - \u0026#39;**/index.js\u0026#39; 将博客同时部署到Github和Coding 由于本人只是将Hexo博客同时部署到 Github 和 Coding.net ，所以这里只介绍怎么同时部署到这两个网站的pages。\n之所以选择这两个网站，是因为国外用户可以访问 Github，而国内用户可以访问 Coding.net。另外，Coding.net可以拥有自己的私人仓库。\n修改站点配置文件 在站点根目录下找到 _config.yml文件，将里边的deploy节点修改成下边的形式：\n1 2 3 4 5 6 7 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: github: git@github.com:{username}/{repository}.git,master coding: git@git.coding.net:{username}/{repository}.git,master 将上边的仓库url的{username}/{repository}改成自己的项目地址，这里使用的是SSH协议的Git仓库地址，即：\n1 git@{domain}:{username}/{repository}.git 还有一种是HTTPS协议的Git仓库地址，即：\n1 https://{domain}/{username}/{repository}.git 一般推荐使用SSH协议的地址，因为可以免去每次push都要输入账号密码的繁琐，而且也够安全。\n在 Github 和 Coding.net 上各自创建一个仓库 如果我们只是将项目部署到某一个代码托管站点而已，那么该项目仓库的名字可以随便起；但是现在我们需要将项目同时部署到 Github 和 Coding.net 上，那就不能随意命名了。\n我们需要采用特定的命名方式，才能正确将Hexo博客同时部署到这两个站点上；否则很可能会导致只有博客的主页能访问到，而其他的路径全部失效。\n不同Pages服务对仓库的命名要求可能不同。对于 Coding.net，你可以选择建立一个私人仓库来部署自己的Hexo博客，不过和 Github 不同的地方在于：\nGithub 的仓库名要命名为：\n1 {username}.github.io 而 Coding.net 的仓库名要命名为：\n1 {username} 这里的 username 指的是你在这两个网站上的用户名，只有以这种命名形式的仓库，才能够不通过子域名的形式来访问我们的博客。\n比如说，我的 Github 和Coding.net 的账号都是lewky，那么在部署博客成功后，我就可以通过下边的url来访问我的Hexo博客：\n1 2 https://lewky.github.io/ https://lewky.coding.me/ 如果将仓库名命名为其他的形式，比如：hexo-blog，那么要访问该博客，就需要输入下边的url：\n1 2 https://lewky.github.io/hexo-blog https://lewky.coding.me/hexo-blog 这里的仓库名hexo-blog就变成了子域名，于是问题就来了，对于存在子域名的Hexo博客，需要在站点配置文件里配置url节点：\n1 2 3 4 5 6 # URL ## If your site is put in a subdirectory, set url as \u0026#39;http://yoursite.com/child\u0026#39; and root as \u0026#39;/child/\u0026#39; url: http://yoursite.com root: / permalink: :year/:month/:day/:title/ permalink_defaults: 如果不配置这里的url节点，会导致除了首页以外的所有页面都请求404；但是我们由于是同时部署在两个网站上，其父域名是不一样的，那么这里的url节点也就只能配置一个而牺牲另一个了；但是如果你有自己的域名，就可以解决这个问题了：直接在这里配置自己的域名就行了。\n创建RSA密钥对 使用 Git Bash 生成RSA密钥对：\n1 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 看到提示就按一次回车，在连续三次回车后，就表示创建成功了。\n接着将 ~/.ssh 目录下将里边的 id_rsa.pub 文件里的内容复制到剪切板。\nGithub 配置 SSH key 登陆 Github 的账号：\n进入 Settings 页面 选择 SSH and GPG keys 点击 New SSH key 填写 Title（用来给公钥起一个名字，以便和其他的公钥区分开来） 然后在 Key 里将我们刚刚复制的公钥复制进去 最后点击 Add SSH key，这时候 GitHub 会要你输入账号密码进行确认。 Coding.net 配置 SSH key Coding.net 和 Github 有些不一样，Coding.net存在账户公钥和部署公钥；\n账户公钥配置后拥有账户下所有项目的读写权限 部署公钥配置后默认拥有该项目的只读权限，如果需要获取推送权限，需要勾选部署公钥设置里的『授予推送权限』 登陆 Coding.net 的账号：\n进入个人设置 选择 SSH 公钥 选择新增公钥 填写公钥名称和内容 添加后输入输入账号密码进行确认 验证 SSH 连接 使用 Git Bash 输入：\n1 ssh -T git@github.com 第一次连接时会问你是否继续连接，输入 yes 即可；接下来验证 Coding.net 的ssh连接：\n1 ssh -T git@git.coding.net 同样输入 yes 即可。\n如果按照前边说的来配置，这里的 SSH 验证应该都是没问题的。\n接下来只要撰写博文，然后使用命令进行部署就行了：\n1 2 hexo clean hexo g -d 参考链接 hexo的next主题个性化配置教程 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 hexo-neat项目地址 hexo博客压缩优化 Hexo-Neat介绍 ","permalink":"https://lewky.cn/posts/hexo-2.html/","tags":["Hexo","NexT主题","主题美化","功能增强"],"title":"Hexo系列(2.0) - NexT主题美化与博客功能增强 · 第一章"},{"categories":null,"contents":"\rHigh!!! 前方高能♂ 1.gif\r2.gif\r","permalink":"https://lewky.cn/funny/high/","tags":null,"title":"Everybody~ High起来!"},{"categories":["Java"],"contents":"一、基础篇 1.1 JVM JVM内存结构\n堆、栈、方法区、直接内存、堆和栈区别\nJava内存模型\n内存可见性、重排序、顺序一致性、volatile、锁、final\n垃圾回收\n内存分配策略、垃圾收集器（G1）、GC算法、GC参数、对象存活的判定\nJVM参数及调优\nJava对象模型\noop-klass、对象头\nHotSpot\n即时编译器、编译优化\n类加载机制\nclassLoader、类加载过程、双亲委派（破坏双亲委派）、模块化（jboss modules、osgi、jigsaw）\n虚拟机性能监控与故障处理工具\njps, jstack, jmap、jstat, jconsole, jinfo, jhat, javap, btrace、TProfiler\n编译与反编译\njavac 、javap 、jad 、CRF\n1.2 Java基础知识 阅读源代码\nString、Integer、Long、Enum、BigDecimal、ThreadLocal、ClassLoader \u0026amp; URLClassLoader、ArrayList \u0026amp; LinkedList、 HashMap \u0026amp; LinkedHashMap \u0026amp; TreeMap \u0026amp; CouncurrentHashMap、HashSet \u0026amp; LinkedHashSet \u0026amp; TreeSet\nJava中各种变量类型\n熟悉Java String的使用，熟悉String的各种函数\nJDK 6和JDK 7中substring的原理及区别、replaceFirst、replaceAll、replace区别、String对“+”的重载、String.valueOf和Integer.toString的区别、字符串的不可变性\n自动拆装箱\nInteger的缓存机制\n熟悉Java中各种关键字\ntransient、instanceof、volatile、synchronized、final、static、const 原理及用法。\n集合类\n常用集合类的使用、ArrayList和LinkedList和Vector的区别 、SynchronizedList和Vector的区别、HashMap、HashTable、ConcurrentHashMap区别、Java 8中stream相关用法、apache集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因\n枚举\n枚举的用法、枚举与单例、Enum类\nJava IO\u0026amp;Java NIO，并学会使用\nbio、nio和aio的区别、三种IO的用法与原理、netty\nJava反射与javassist\n反射与工厂模式、 java.lang.reflect.*\nJava序列化\n什么是序列化与反序列化、为什么序列化、序列化底层原理、序列化与单例模式、protobuf、为什么说序列化并不安全\n注解\n元注解、自定义注解、Java中常用注解使用、注解与反射的结合\nJMS\n什么是Java消息服务、JMS消息传送模型\nJMX\njava.lang.management.、 javax.management.\n泛型\n泛型与继承、类型擦除、泛型中K T V E ？ object等的含义、泛型各种用法\n单元测试\njunit、mock、mockito、内存数据库（h2）\n正则表达式\njava.lang.util.regex.*\n常用的Java工具库\ncommons.lang, commons.*\u0026hellip; guava-libraries netty\n什么是API\u0026amp;SPI\n异常\n异常类型、正确处理异常、自定义异常\n时间处理\n时区、时令、Java中时间API\n编码方式\n解决乱码问题、常用编码方式\n语法糖\nJava中语法糖原理、解语法糖\n1.3 Java并发编程 什么是线程，与进程的区别\n阅读源代码，并学会使用\nThread、Runnable、Callable、ReentrantLock、ReentrantReadWriteLock、Atomic*、Semaphore、CountDownLatch、、ConcurrentHashMap、Executors\n线程池\n自己设计线程池、submit() 和 execute()\n线程安全\n死锁、死锁如何排查、Java线程调度、线程安全和内存模型的关系\n锁\nCAS、乐观锁与悲观锁、数据库相关锁机制、分布式锁、偏向锁、轻量级锁、重量级锁、monitor、锁优化、锁消除、锁粗化、自旋锁、可重入锁、阻塞锁、死锁\n死锁\nvolatile\nhappens-before、编译器指令重排和CPU指令重\nsynchronized\nsynchronized是如何实现的？synchronized和lock之间关系、不使用synchronized如何实现一个线程安全的单例\nsleep 和 wait\nwait 和 notify\nnotify 和 notifyAll\nThreadLocal\n写一个死锁的程序\n写代码来解决生产者消费者问题\n守护线程\n守护线程和非守护线程的区别以及用法\n二、进阶篇 2.1 Java底层知识 字节码、class文件格式\nCPU缓存，L1，L2，L3和伪共享\n尾递归\n位运算\n用位运算实现加、减、乘、除、取余\n2.2 设计模式 了解23种设计模式\n会使用常用设计模式\n单例、策略、工厂、适配器、责任链。\n实现AOP\n实现IOC\n不用synchronized和lock，实现线程安全的单例模式\nnio和reactor设计模式\n2.3 网络编程知识 tcp、udp、http、https等常用协议\n三次握手与四次关闭、流量控制和拥塞控制、OSI七层模型、tcp粘包与拆包\nhttp/1.0 http/1.1 http/2之前的区别\nJava RMI，Socket，HttpClient\ncookie 与 session\ncookie被禁用，如何实现session\n用Java写一个简单的静态文件的HTTP服务器\n实现客户端缓存功能，支持返回304 实现可并发下载一个文件 使用线程池处理客户端请求 使用nio处理客户端请求 支持简单的rewrite规则 上述功能在实现的时候需要满足“开闭原则”\n了解nginx和apache服务器的特性并搭建一个对应的服务器\n用Java实现FTP、SMTP协议\n进程间通讯的方式\n什么是CDN？如果实现？\n什么是DNS？\n反向代理\n2.4 框架知识 Servlet线程安全问题\nServlet中的filter和listener\nHibernate的缓存机制\nHiberate的懒加载\nSpring Bean的初始化\nSpring的AOP原理\n自己实现Spring的IOC\nSpring MVC\nSpring Boot2.0\nSpring Boot的starter原理，自己实现一个starter\nSpring Security\n2.5 应用服务器知识 JBoss\ntomcat\njetty\nWeblogic\n2.6 工具 git \u0026amp; svn\nmaven \u0026amp; gradle\n三、高级篇 3.1 新技术 Java 8\nlambda表达式、Stream API、\nJava 9\nJigsaw、Jshell、Reactive Streams\nJava 10\n局部变量类型推断、G1的并行Full GC、ThreadLocal握手机制\nSpring 5\n响应式编程\nSpring Boot 2.0\n3.2 性能优化 使用单例、使用Future模式、使用线程池、选择就绪、减少上下文切换、减少锁粒度、数据压缩、结果缓存\n3.3 线上问题分析 dump获取\n线程Dump、内存Dump、gc情况\ndump分析\n分析死锁、分析内存泄露\n自己编写各种outofmemory，stackoverflow程序\nHeapOutOfMemory、 Young OutOfMemory、MethodArea OutOfMemory、ConstantPool OutOfMemory、DirectMemory OutOfMemory、Stack OutOfMemory Stack OverFlow\n常见问题解决思路\n内存溢出、线程死锁、类加载冲突\n使用工具尝试解决以下问题，并写下总结\n当一个Java程序响应很慢时如何查找问题、 当一个Java程序频繁FullGC时如何解决问题、 如何查看垃圾回收日志、 当一个Java应用发生OutOfMemory时该如何解决、 如何判断是否出现死锁、 如何判断是否存在内存泄露\n3.4 编译原理知识 编译与反编译\nJava代码的编译与反编译\nJava的反编译工具\n词法分析，语法分析（LL算法，递归下降算法，LR算法），语义分析，运行时环境，中间代码，代码生成，代码优化\n3.5 操作系统知识 Linux的常用命令\n进程同步\n缓冲区溢出\n分段和分页\n虚拟内存与主存\n3.5 数据库知识 MySql 执行引擎\nMySQL 执行计划\n如何查看执行计划，如何根据执行计划进行SQL优化\nSQL优化\n事务\n事务的隔离级别、事务能不能实现锁的功能\n数据库锁\n行锁、表锁、使用数据库锁实现乐观锁、\n数据库主备搭建\nbinlog\n内存数据库\nh2\n常用的nosql数据库\nredis、memcached\n分别使用数据库锁、NoSql实现分布式锁\n性能调优\n3.6 数据结构与算法知识 简单的数据结构\n栈、队列、链表、数组、哈希表、\n树\n二叉树、字典树、平衡树、排序树、B树、B+树、R树、多路树、红黑树\n排序算法\n各种排序算法和时间复杂度 深度优先和广度优先搜索 全排列、贪心算法、KMP算法、hash算法、海量数据处理\n3.7 大数据知识 Zookeeper\n基本概念、常见用法\nSolr，Lucene，ElasticSearch\n在linux上部署solr，solrcloud，，新增、删除、查询索引\nStorm，流式计算，了解Spark，S4\n在linux上部署storm，用zookeeper做协调，运行storm hello world，local和remote模式运行调试storm topology。\nHadoop，离线计算\nHDFS、MapReduce\n分布式日志收集flume，kafka，logstash\n数据挖掘，mahout\n3.8 网络安全知识 什么是XSS\nXSS的防御\n什么是CSRF\n什么是注入攻击\nSQL注入、XML注入、CRLF注入\n什么是文件上传漏洞\n加密与解密\nMD5，SHA1、DES、AES、RSA、DSA\n什么是DOS攻击和DDOS攻击\nmemcached为什么可以导致DDos攻击、什么是反射型DDoS\nSSL、TLS，HTTPS\n如何通过Hash碰撞进行DOS攻击\n用openssl签一个证书部署到apache或nginx\n四、架构篇 4.1 分布式 数据一致性、服务治理、服务降级\n分布式事务\n2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC\nDubbo\n服务注册、服务发现，服务治理\n分布式数据库\n怎样打造一个分布式数据库、什么时候需要分布式数据库、mycat、otter、HBase\n分布式文件系统\nmfs、fastdfs\n分布式缓存\n缓存一致性、缓存命中率、缓存冗余\n4.2 微服务 SOA、康威定律\nServiceMesh\nDocker \u0026amp; Kubernets\nSpring Boot\nSpring Cloud\n4.3 高并发 分库分表\nCDN技术\n消息队列\nActiveMQ\n4.4 监控 监控什么\nCPU、内存、磁盘I/O、网络I/O等\n监控手段\n进程监控、语义监控、机器资源监控、数据波动\n监控数据采集\n日志、埋点\nDapper\n4.5 负载均衡 tomcat负载均衡、Nginx负载均衡\nDNS\nDNS原理、DNS的设计\nCDN\n数据一致性\n五、扩展篇 5.1 云计算 IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess\n5.2 搜索引擎 Solr、Lucene、Nutch、Elasticsearch\n5.3 权限管理 Shiro\n5.4 区块链 哈希算法、Merkle树、公钥密码算法、共识算法、Raft协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名\n比特币\n挖矿、共识机制、闪电网络、侧链、热点问题、分叉\n以太坊\n超级账本\n5.5 人工智能 数学基础、机器学习、人工神经网络、深度学习、应用场景。\n常用框架\nTensorFlow、DeepLearning4J\n5.6 其他语言 Groovy、Python、Go、NodeJs、Swift、Rust\n六、推荐书籍 《深入理解Java虚拟机》 《Effective Java》 《深入分析Java Web技术内幕》 《大型网站技术架构》 《代码整洁之道》 《Head First设计模式》 《maven实战》 《区块链原理、设计与应用》 《Java并发编程实战》 《鸟哥的Linux私房菜》 《从Paxos到Zookeeper》 《架构即未来》 ","permalink":"https://lewky.cn/posts/5044311b.html/","tags":["Java"],"title":"Java工程师成神之路(2018版本)"},{"categories":["cmd"],"contents":"相信大家或多或少都遇到过类似的情况：从网上下载了好多图片(或者其他的文件)，这些图片的名字往往都是些乱七八糟的字母数字的组合，我们想要一次性修改几十张上百张的图片的名字应该怎么办呢？\n这里有两种方法，最简单的就是直接使用Windows自带的批量重命名方法；但是这种方法有缺陷，只能以固定的命名规律来命名。另一种方法就是通过dos命令来批量修改文件名。\nWindows自带的批量重命名 选定所有你想修改的文件，然后右键菜单选择重命名，接下来输入随便一个名字，比如 photo，然后回车确定。接下来你就会看到被选中的 n 张图片都被重命名为从 photo (1) 到 photo (n) 这样的名字。\n如果你很介意名字中出现的 (n)的格式，那么推荐你使用下边的方法来进行批量重命名文件。\n通过dos命令来批量修改文件名 首先新建一个txt文件，然后修改名字为rename.bat(随便起名字，只是后缀必须是.bat) 用编辑器打开该bat文件并输入以下dos命令并保存该文件(如果没有编辑器比如EditPlus之类的，就先在txt文件里输入以下dos命令再重新改名为.bat后缀的名字) 1 2 3 4 5 6 7 @echo off set a=0 setlocal EnableDelayedExpansion for %%n in (*.png) do ( set /A a+=1 ren \u0026#34;%%n\u0026#34; \u0026#34;bilibili_!a!.png\u0026#34; ) 这里的命令表示将当前目录下的所有png后缀的图片都改名为bilibili_{a}.png，这里的{a}是从1开始到n的数字。\n双击执行该bat文件(注意该bat文件需要放在和要重命名的图片同一个目录下)，就会发现文件名变成了下图的样子：\nrename1.jpg\r下图中红框标出来的三个地方可以随自己喜欢任意修改：\nrename2.jpg\r","permalink":"https://lewky.cn/posts/79682f1b.html/","tags":["cmd"],"title":"cmd - 批量重命名文件"},{"categories":["数据库"],"contents":"前言 公司使用的是 PostgreSQL 数据库，可以使用 pgAdmin 或者 DBeaver 进行连接该数据库。个人更喜欢用 DBeaver，因为其界面更加美观，操作也相对简单。对于习惯了eclipse的开发者来说，DBeaver绝对是个不错的选择。\nDBeaver 是一个通用的数据库管理工具和 SQL 客户端，支持 MySQL, PostgreSQL, Oracle, DB2, MSSQL, Sybase, Mimer, HSQLDB, Derby, 以及其他兼容 JDBC 的数据库。\nDBeaver 提供一个图形界面用来查看数据库结构、执行 SQL 查询和脚本，浏览和导出数据，处理 BLOB/CLOB 数据，修改数据库结构等等。\n快捷键hot key ctrl + enter 执行sql\nctrl + alt + ↑ 向上复制一行\nctrl + alt + ↓ 向下复制一行\nctrl + shift + ↑ 向上移动一行\nctrl + shift + ↓ 向下移动一行\nctrl + alt + F 对sql语句进行格式化，对于很长的sql语句很有用\nctrl + d 删除当前行\nalt + ↑ 向上选定一条sql语句\nalt + ↓ 向下选定一条sql语句\nctrl + / 行注释\nctrl + shift+ / 块注释\nctrl + f 查找、替换\nctrl + space sql提示(如果写了from table后也会自动提示field)\nctrl + shift + E 执行计划\nctrl + shift + U 将选定的sql转换成大写字母\nctrl + shift + L 将选定的sql转换成小写字母\n使用小技巧 有一些快捷键在使用时，只需要将光标移动到某一条sql语句上就行，不需要选定整条完整的语句。 有一些快捷键使用时是默认对当前一整个 Script 页面生效，可以通过光标来选定只想生效的范围。 双击sql语句里的括号边缘，可以直接选定括号内的内容(不包括该括号)，这个功能很方便。 双击单引号/双引号的内侧可以直接选定被单引号/双引号包括起来的内容。 导出DBeaver的连接配置和脚本文件 DBeaver默认的连接和脚本（Connections和Scripts）都保存在General这个project里的.dbeaver-data-sources.xml，所有的project被保存在%{HOME}/.dbeaver4/目录下，每个project对应一个子目录。也就是说，默认的所有连接和脚本都保存在了%{HOME}/.dbeaver4/General/.dbeaver-data-sources.xml里。\n%{HOME}就是当前用户的目录，即C:\\Users\\xxx。\n直接把.dbeaver-data-sources.xml拷贝到另一个DBeaver的对应的project目录下即可。如果有多个project，可以在DBeaver里的Database Navigator进行切换：选择倒三角图标 -\u0026gt; Active Project -\u0026gt; 选择要切换的project，默认是用的General\nMySQL支持多重查询 对于MySQL，默认情况下只能在一个窗口页面里进行查询，如果想要多开页面查询数据，需要修改参数：\n选定数据库 -\u0026gt; 编辑连接 -\u0026gt; 驱动属性 -\u0026gt; 选择allowMultiQueries，把后面的值改成true\n参考链接 dbeaver: how can I export connection configuration? ","permalink":"https://lewky.cn/posts/a815cce3.html/","tags":["可视化工具","DBeaver"],"title":"DBeaver使用汇总"},{"categories":["前端"],"contents":"如果js、css外部文件有使用到相对路径时，需要注意其相对路径的基准是不一样的。\n比如说，在index.html中引用到了外部的js和css文件，这两个文件都通过相对路径引用了某一张图片；这些文件所在的目录如下：\n1 2 3 4 5 6 7 8 . ├── js | └── index.js ├── css | └── index.css ├── images | └── bg.jpg └── index.html js文件的相对路径是以引用该js文件的页面为基准，所以在js文件中的相对路径是：\n1 2 3 function changeImage(){ document.body.style.backgroundImage=\u0026#34;url(images/bg.jpg)\u0026#34;; } css文件的相对路径是以自身的位置为基准，所以在css文件中的相对路径是：\n1 2 3 .index_bg { background-image: url(../images/bg.jpg); } index.html的代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;index\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/index.css\u0026#34; type=\u0026#34;text/css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello World!\u0026lt;/h1\u0026gt; \u0026lt;div class=\u0026#34;index_bg\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;button type=\u0026#34;button\u0026#34; onclick=\u0026#34;changeImage()\u0026#34;\u0026gt;设置背景图片\u0026lt;/button\u0026gt; \u0026lt;script src=\u0026#34;js/index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 总结\njs文件的相对路径是以引用该js文件的页面为基准 css文件的相对路径是以自身的位置为基准 ","permalink":"https://lewky.cn/posts/29169.html/","tags":["前端","JS","CSS"],"title":"js、css外部文件的相对路径问题"},{"categories":["Hexo系列"],"contents":"前言 搭建个人博客一般有两种选择，一个是使用WordPress，但是需要将博客搭建在服务器上，不过搭建好后写文章方便，适合没有程序基础的人使用。另一个是使用Hexo，相对简洁高效，不需要服务器，既可以部署在本地，也可以将博客部署到GitHub Pages上，支持Markdown语法，缺点是需要有Git基础，写文章比WordPress麻烦点。\n初次使用Hexo来搭建个人博客，确实比较手忙脚乱，这里记录一下流程，希望对大家能有所帮助。\n（注：本文是只针对Windows平台的搭建教程）\n有兴趣的可以戳下这里看看我的个人博客。\nHow to play 本搭建教程一共分为3部分：\n安装环境和本地搭建 博客的简单个性化配置 将博客部署到 GitHub Pages 请根据自身需要选择章节，以节省时间。\n安装环境 安装Node.js 安装Git 安装Hexo 安装Node.js Hexo是一个基于Node.js的快速、简洁且高效的静态站点生成框架，想要安装Hexo，需要先安装Node.js，官网的安装包有两种，一种是安装程序.msi文件，一种是.zip压缩包，这里选择.msi文件，安装后会自动配置好环境变量。\n下载链接\n安装Git Git就不多说了，作为开发者或多或少都会接触过吧，直接前往官网下载安装包即可。操作教程网上也是一堆，这里就不赘述了。\n下载链接\n如果Git和Node.js的环境变量都配置好了，可以通过在cmd中确认安装结果。\n1 2 git --version node -v 安装Hexo 安装好Node.js，就可以使用npm来安装Hexo\n1 npm install -g hexo-cli 安装完毕后，可以通过hexo version来确认是否安装成功。\n开始搭建个人博客 千里之行，始于足下，在安装好所有的环境之后，我们终于可以开始搭建博客的第一步了。\n初始化Hexo项目 首先是选择一个文件夹，用来给我们我们的个人博客的存放各种文件。接着进入该文件夹的路径，打开cmd命令窗口，这里有两种打开方式：\n按住Shift，同时点击鼠标右键，选择在此处打开命令窗口。 在上方的地址栏里输入cmd，接着回车即可快速打开命令窗口。 当然，你也可以直接Win+R然后输入cmd来打开命令窗口，不过需要再通过cd命令将路径切换到你指定的文件夹。\n接着输入指令来初始化你的博客\n1 hexo init 初始化成功后，你会看到\nStart blogging with Hexo!\n生成静态页面文件 接下来，执行命令\n1 hexo g 该命令用来生成静态页面文件到public目录，Hexo会将 source 文件夹中除 posts 文件夹之外，以下划线_开头命名的文件或文件夹、以及隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件夹会被拷贝过去。\n最后，我们只要启动Hexo服务器就行了。\n本地启动Hexo服务器 1 hexo s --debug Hexo启动服务器的速度非常快，很快你就可以看到\nHexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n恭喜你，你的个人博客已经搭建成功了，接下来只要在浏览器输入http://localhost:4000/就可以在本地访问你的博客了。\n这里使用hexo s也可以启动服务器，只不过加上--debug\t参数，如果运行中出错可以看到错误信息。\n关闭Hexo服务器 要想关闭服务器，只需要在命令窗口按下Ctrl+C就可以了，这个组合键不仅仅用于关闭服务器，事实上你在cmd窗口中任何执行中的命令都可以用这个组合键来结束命令，只要连按两次该组合键就可以连输入Y或者N都不用。\n常用的命令 1 2 3 4 5 6 7 8 hexo new \u0026#34;postName\u0026#34; #新建文章 hexo new page \u0026#34;pageName\u0026#34; # 新建页面 hexo generate # 生成静态页面至public目录 hexo server # 启动服务器(默认端口4000，\u0026#39;ctrl+c\u0026#39;关闭server) hexo deploy # 项目部署 hexo help # 查看帮助 hexo version # 查看Hexo的版本 hexo clean # 清除Hexo的缓存 上边的一些命令可以使用简写\n1 2 3 4 hexo n hexo g hexo d hexo s 本地调试三连 1 2 3 hexo clean hexo g hexo s --debug 远程部署三连 1 2 3 hexo clean hexo g hexo d 注：在使用部署命令时，需要先用npm安装 hexo-deployer-git 插件：\nnpm install hexo-deployer-git --save\r撰写第一篇博文 Hexo撰写博文也不难，分为 post 和 draft 两种，其中 post 存放在 source/_posts 目录下，draft 存放在 source/_drafts 目录下。\npost 和 draft 的区别在于前者会被发布到博客，而后者不会被发布。\n第一篇文章 1 hexo n post \u0026#34;my-first-post\u0026#34; Hexo会自动在 source/_posts 目录下新建一个名为 my-first-post 的 .md 文件；打开该文件，可以看到：\n1 2 3 4 5 --- title: my-first-post date: 2018-04-21 23:11:30 tags: --- 这是 post 模板自动生成的 YAML 文件头，title 是这篇 post 的标题，可以将其改为 My First Post；date 是创建的日期；tags 是该 post 的标签，可以添加自定义的标签：\n1 2 3 4 5 6 7 --- title: My First Post date: 2018-04-21 23:11:30 tags: - demo - first-post --- 接着再进行本地调试三连，就可以看到刚刚写好的博文了。\n1 2 3 hexo clean hexo g hexo s --debug 第一篇草稿 创建命令和前边类似：\n1 hexo n draft \u0026#34;my-first-draft\u0026#34; 另外草稿的头文件是没有日期的：\n1 2 3 4 --- title: my-first-draft tags: --- 草稿文件是不会被 hexo g 命令生成到public目录下的，也就是说这些草稿文件是无法在启动站点时被看见，你也可以直接在一篇不想要被展示的文章里加上draft: true到文件头里，以此避免被Hexo渲染到站点里。\n接下来讲下博客的简单个性化配置，譬如站点的基本配置（语言、头像、站点图标等）、安装新的Hexo主题（NexT主题）以及主题的配置。\n博客的简单个性化配置 打开站点配置文件 ，找到：\n1 2 3 4 5 6 7 8 # Site title: Hexo subtitle: description: keywords: author: John Doe language: timezone: 根据自己的需要去修改上边的配置，这些配置的注释如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Site # 站点标题 title: Hexo # 站点副标题 subtitle: # 站点描述 description: # 站点关键词 keywords: # 站点主人 author: John Doe # 站点语言 language: # 站点时区 timezone: language 目前 NexT 支持的语言如下：\n语言 language English en 简体中文 zh-Hans Français fr-FR Português pt或者pt-BR 繁體中文 zh-hk或者zh-tw Русский язык ru Deutsch de 日本語 ja Indonesian id Korean ko timezone Hexo 默认使用电脑的时区，也可以自己配置，比如：\nUTC+8\r安装新主题 Hexo有很多大佬开发的主题，很多人使用的是NexT主题，该主题也确实挺简洁好看的，新版本的NexT主题还可以选择四个主题。\n那么怎么安装新的Hexo主题呢？\n在我们的Hexo项目路径下，可以看到有个 themes 文件夹，这个文件夹就是用于存放主题文件的。\n下载 NexT 主题 首先在Hexo项目的路径下打开命令窗口，如果你没有配置好Git的环境变量，请使用Git Bash。\n1 git clone https://github.com/iissnan/hexo-theme-NexT themes/NexT 注意，当前路径是你的Hexo项目根目录，使用上边的命令才能正确地将 NexT 主题clone到themes文件夹下的NexT文件夹里。\n接下来你会看到 themes 下多了个 NexT 文件夹，点进去你会看到个.git文件夹，将该文件夹删掉，否则到时候你无法将整个完整的Hexo项目push到GitHub上。\n启用 NexT 主题 在Hexo项目中，有两个重要的配置文件 _config.yml；这两个配置文件一个在项目根目录下，一个在主题目录下。\n前者是站点配置文件，后者是主题配置文件，顾名思义，一个是Hexo项目的配置选项，一个是主题文件的配置选项。\n打开站点配置文件，用Windows自带的笔记本是无法打开该文件的，请使用其他的编辑器来打开，常见的编辑器有Notepad++，UltraEdit，EditPlus等。\n在站点配置文件中，找到：\n1 2 3 4 # Extensions ## Plugins: https://hexo.io/plugins/ ## Themes: https://hexo.io/themes/ theme: landscape 默认的博客主题就是这个，我们将其修改为NexT；这里的主题是指在 themes 文件夹下的对应主题的文件夹名字。\n**注意，在配置文件中所有的属性的值，都必须和前边的 : 之间留一个空格。**比如下边的写法就是错误的，不加上空格的话会出错。\n1 theme:landscape 选择对应主题的外观 Scheme 打开主题配置文件，找到下边的选项：\n1 2 3 4 5 6 7 8 9 # --------------------------------------------------------------- # Scheme Settings # --------------------------------------------------------------- # Schemes scheme: Muse #scheme: Mist #scheme: Pisces #scheme: Gemini 默认会使用Muse作为NexT主题的外观，通过将某个scheme前边的#去掉来启动某个外观，如下：\n1 2 3 4 5 6 7 8 9 # --------------------------------------------------------------- # Scheme Settings # --------------------------------------------------------------- # Schemes #scheme: Muse #scheme: Mist #scheme: Pisces scheme: Gemini 验证新主题 依然是老操作——启动调试模式服务器：\n1 hexo s --debug 启动成功后，使用浏览器访问http://localhost:4000/，看看博客能否访问成功。\n修改 NexT 主题配置 主题配置文件 _config.yml 位于 themes\\NexT 之下。\n3.1 头像设置 打开主题配置文件，找到如下：\n1 2 3 4 5 6 # 侧边栏头像 # Sidebar Avatar # in theme directory(source/images): /images/avatar.gif # in site directory(source/uploads): /uploads/avatar.gif # 头像的路径可以放在主题对应文件夹的source里，也可以放在站点根目录的source里，建议放在站点路径上 #avatar: /images/avatar.gif 将avatar前边的#去掉，接着配置图片的路径即可。\n网站图标 打开主题配置文件，找到如下：\n1 2 3 4 5 6 7 8 9 10 11 # 将你的网站图标放到`{站点根目录}/source/` (推荐）或者`hexo-site/themes/NexT/source/images/`目录下 # 默认的NexT主题的网站图标放在`{站点根目录}/themes/NexT/source/images/`目录下 # 如果你想将自己的网站图标放到`{站点根目录}/source/`根目录下，必须将`/images`从路径中去掉 # 如果你将网站图标放到了`{站点根目录}/source/images`路径下，需要令网站图标的名字和`{站点根目录}/themes/NexT/source/images/`路径下的网站图标不同，否则网站图标会使用后者的同名图标 favicon: small: /images/favicon-16x16-NexT.png medium: /images/favicon-32x32-NexT.png apple_touch_icon: /images/apple-touch-icon-NexT.png safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 这里需要注意的是，网站图标一般是.ico或者.gif的类型，而且图标的大小一般只有几k而已，可以使用下边的网站制作个人的网站图标，建议先将原本的图标弄成正方形的。\n在线制作ico图标\n菜单设置 打开主题配置文件，找到如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 如果该站点是运行在子目录之下（比如：domain.tld/blog；这里的blog就是指我们的博客，前边的是上一级的域名），需要将路径前的斜杠去掉（/archives -\u0026gt; archives；即是将原本的绝对路径改成了相对路径）。 # 用法：`Key：/link/ || 菜单图标` # Key就是菜单名，如果对该菜单名进行了国际化，即将其翻译放到对应的languages文件夹中，将会根据你设置的语言进行加载对应的菜单名翻译；如果没有设置翻译，则会使用这里的Key作为菜单名。这里的Key是大小写敏感的。 # 在`||`分隔符之前的值是该菜单对应的路径 # 在`||`分隔符之后的值是FontAwesome的图标（不懂的请百度什么是FontAwesome以及其用法），如果不指定图标，将会自动使用question这个图标。 menu: home: / || home #about: /about/ || user #tags: /tags/ || tags #categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat 使用方法很简单，依然是将需要展示的菜单的前边的#去掉就行，更加具体的操作信息我已经在上边的注释中给出了。\n标签分类 首先我们需要新建页面，在站点根目录打开命令窗口，分别输入命令：\n1 2 3 hexo n page \u0026#34;categories\u0026#34; hexo n page \u0026#34;tags\u0026#34; hexo n page \u0026#34;about\u0026#34; 接着你会发现在根目录的 source 目录下多出了上边的三个文件夹，里面各自有一个 index.md 文件。如果之前我们将menu里的categories，tags，about三个菜单解开了封印，那么在创建好这三个页面后就可以成功访问到，否则会报404请求错误。\n社交链接 1 2 3 4 5 6 7 8 9 10 11 12 # 如果不指定图标，会默认使用globe图标 #social: #GitHub: https://github.com/yourname || github #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype 老规矩，去掉#注释就可以启动。最后介绍下如何将本地的个人项目远程部署到 GitHub Pages，涉及到GitHub的项目仓库、Git的使用，以及Hexo的远程部署等。\n安装 hexo-deployer-git 插件 想要将Hexo项目部署到 GitHub上，需要先安装一个插件。在Hexo项目的根目录打开命令窗口，输入：\nnpm install hexo-deployer-git --save\rGitHub上创建一个仓库 仓库的名字可以随便起，不过这个仓库是作为我们的博客仓库的，所以尽量将名字以 {username}.github.io 的形式来起。\n比如，我的GitHub用户名是lewky，我就会把这个仓库命名为lewky.github.io。（为什么要这样起名，后面会说明）\n修改本地的项目配置文件 在 _config.yml 找到如下：\n1 2 3 4 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: 把刚刚我们新建的GitHub仓库链接配置进来：\n1 2 3 4 5 6 7 # Deployment ## Docs: https://hexo.io/docs/deployment.html deploy: type: git repo: git@github.com:/{user}/{repository}.git branch: master message: 请注意，这里的仓库地址如果写成：https://github.com/{user}/{repository}.git可能会在后边的部署时无法成功，需要将https://github.com改成如下格式：\n1 git@github.com: 另外这里的branch和message可以不填，branch会默认是master分支，message会默认用下边的格式模板：\n1 Site updated: {{ now(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) }} SSH key的创建与配置 最关键的一步来了，我们需要生成一对密钥对，然后将公钥配置到GitHub账号上。\n生成RSA密钥对 首先使用 Git Bash 输入：\n1 cd ~/.ssh ~ 指的是当前用户的根目录，即 C:\\Users\\{user}\\；而 .ssh 目录下一般存放着公开的SSH key文件：\nid_dsa.pub id_ecdsa.pub id_ed25519.pub id_rsa.pub 此外还有个 known_hosts 文件，SSH会把我们每个访问过的计算机的公钥(public key)都记录在里面。\n如果在使用了 cd ~/.ssh 后能找到路径，那就把该目录下的 id_rsa.pub 文件里的内容复制到剪切板。如果找不到路径，就执行命令：\n1 ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 该命令会生成新的SSH key，这里的参数含义：\n1 2 3 -t: type，生成的密钥类型 -b: bits，指定密钥长度，对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位，一般越长越安全。 -C: comment，提供一个新注释 接着会看到如下提示：\n1 Enter file in which to save the key (/c/Users/123/.ssh/id_rsa): 这里按下回车，表示将SSH key保存到默认地址，即：C:\\Users\\{user}\\\n如果本身已经存在一个RSA私钥了，会提示你：\n1 2 /c/Users/123/.ssh/id_rsa already exists. Overwrite (y/n)? 这里输入 y 可以重新生成RSA密钥对；然后就会看到如下提示：\n1 Enter passphrase (empty for no passphrase): 这里按下回车，表示不设置密码；接着会再提示你输入重复密码，依然是按下回车。\n1 Enter same passphrase again: 这时候我们的SSH key就生成好了，去 ~/.ssh 目录下将里边的 id_rsa.pub 文件里的内容复制到剪切板。\n在 GitHub 上配置SSH key 接着登陆我们的 GitHub 账号：\n进入 Settings 页面 选择 SSH and GPG keys 点击 New SSH key 填写 Title（用来给公钥起一个名字，以便和其他的公钥区分开来） 然后在 Key 里将我们刚刚复制的公钥复制进去 最后点击 Add SSH key，这时候 GitHub 会要你输入账号密码进行确认。 验证ssh连接 使用 Git Bash 输入：\n1 ssh -T git@github.com 接着会看到：\n1 2 3 The authenticity of host \u0026#39;github.com (192.30.253.112)\u0026#39; can\u0026#39;t be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? 输入 yes，会看到：\n1 2 Warning: Permanently added \u0026#39;github.com,192.30.253.112\u0026#39; (RSA) to the list of known hosts. Hi lewky! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 这时候 github.com的公钥被保存到known_hosts文件里，如果我们再执行一次ssh -T git@github.com，就不需要输入yes了，会直接看到：\n1 Hi lewky! You\u0026#39;ve successfully authenticated, but GitHub does not provide shell access. 部署到 GitHub Pages 输入命令：\n1 2 3 hexo d 或者 hexo g -d 后一条命令表示生成静态页面并部署到远处仓库，第一次部署会久一点，部署成功后会看到：\n1 2 * [new branch] HEAD -\u0026gt; master INFO Deploy done: git 接着登陆 GitHub 并进入我们的项目仓库，可以看到已经多出了很多文件，且其 message 都是默认的格式：\n1 Site updated: {{ now(\u0026#39;YYYY-MM-DD HH:mm:ss\u0026#39;) }} 接下来点击 Settings 进入该仓库的设置页面，找到 Github Pages 这一项，选择以 Master 分支作为 source，然后保存；接下来这个仓库就会被部署到 https://{username}.github.io/{仓库名}。\n如果你希望直接通过 https://{username}.github.io/ 来访问你的博客，可以将仓库名改为 {username}.github.io；这样就不需要在url后边添加上仓库名来访问了。\n接下来，开始享受你的个人博客吧 :)\n","permalink":"https://lewky.cn/posts/hexo-1.html/","tags":["Hexo","NexT主题","搭建教程","远程部署"],"title":"Hexo系列(1) - 简单搭建教程与远程部署"},{"categories":null,"contents":"博主相关 古往 \u0026amp; 今来 2017年毕业于宇宙工业大学 最先在珠海出道成为偶像从事Java开发，后去往佛山发展 码农界老腊肉一枚 (⌒▽⌒) 技能 \u0026amp; 喜好 A B Java （性感码农，在线搬砖） Markdown （关于我想成为写手的那些事） 健身 （我要打十个） 追漫看番 （老二次元了） 传音 \u0026amp; 入密 email: 1019175915@qq.com github@lewky csdn@lewky_liu cnblogs@yulinlewis 站点相关 站点及主题版本 1 2 hugo: v0.74.2/extended windows/amd64 BuildDate: unknown LoveIt: v0.2.10 建站日志 → 戳我查看建站日志 ←\n神奇页面 → 废话少说燥起来!!前方高能♂ ←\n友情链接 想添加友链可以前往友链页面留言 (ﾉ*･ω･)ﾉ～\n","permalink":"https://lewky.cn/about/","tags":null,"title":"关于"},{"categories":["生活"],"contents":" 随笔 就是随手写写的乱七八糟的玩意…… 2021-07-20 这两天Waline评论系统被一个自称为Waline Hacker的攻击了，绕过了后台审核直接恶意批量新增了几百条垃圾评论。\n去Waline项目的issue里看到了同样处境的道友，按照开发者的建议升级了服务端，并添加LOGIN=force环境变量，客户端同样新增该变量，必须登录才能发表评论。\n此外，使用了评论发布审核功能，需要经过人工审核才可发布评论。\n2021-01-18 建站1000天纪念！！\n2021-01-11 今天是2021年1月11日，连续四个1，值得拿出来单独记录一下~\n另外距离建站1000天还有最后的七天倒计时！！\n2021-01-09 这周依然没有咒术回战o(╥﹏╥)o\n2021-01-01 这周没有咒术回战o(╥﹏╥)o\n2020-12-28 马上就要建站1000天了，今年也要结束了，奋斗吧，向明神学习，我要把GitHub的贡献表格染成一片绿色！！\n2019-06-08 这周的JOJO简直爽到！尤其是最后的银镇登场bgm，真的炸裂！\n2019-05-15 又要开打贸易战了……互联网的又一波失业寒潮。\n2019-04-24 好久没更新博客了，这阵子确实忙了很多，人也颓唐了不少，是时候改变了，不能继续丧下去了……\n另外——\n建站一周年纪念！！\n2019-03-07 今天是个神奇的日子。\n早上煮的鸡蛋是双黄蛋； 上午同事报喜生了龙凤胎； 中午食堂破天荒给了一对鸡翅；\n怎么形容今天呢？简直是JOJO的奇妙冒险级别的日子~\n2019-02-19 猿宵节\n猿宵节：通常指程序猿通宵写代码的节日\n2019-02-18 建站300天纪念！！\n2019-02-17 下午看到附近的狗子躺在地上不停往空中踢腿，跟踩单车一样，百度了下也找不到类似的状况，emmm，这狗不会是在瘦腿吧……\n2019-01-27 时间过得真快，转眼就要回家过春节了，新的一年里也快过去头个月了。\n发现自己是真的越发懒散怠惰了，想想去年的这个时候，还心怀高远，精神焕发，再看看如今，去年定下的目标是越发地遥不可及了。\n应该怎么有效地调节情绪呢，总觉得自己是个有自知之明却没有自制之力的废材呀。。\n2019-01-08 第一次吃牛奶草莓，闻起来确实很香，不过吃起来倒是和普通草莓差不多。\n2018-12-19 不知道写点啥，最近一直状态不好，记录下之前写的几句诗歌吧~\n纵心猿，驰意马。\n秋风秋雨织秋意，春花春水鉴春光。\n2018-11-04 这个周末看了整整两天的《乌龙闯情关》，还是以前的电视剧好看。剧中的刘病已、霍水仙、许平君、大牛、鸠摩空都让人印象深刻，也知道了故剑情深的典故。\n现在各种快餐文化，人心浮躁，还是以前的影视、小说作品让人回味无穷，我不是个怀旧的人，却对过去的一些回忆很有感怀。这些都是宝贵的精神食粮，可能是一首歌，也可能是荧幕中、笔墨下的一个人物，每每带给我鼓舞与勇气。\n我也要努力，冲鸭！\n2018-10-24 今天是程序员节，在这个日子里，我终于将自己定制的hexo主题正式起名为Beep了~\n1024节日快乐~\n2018-10-18 又看了一遍JOJO第四部的boss战，真是百看不厌，爱死JOJO了！\n2018-10-14 每周都是等待JOJO新一集的煎熬和畅享JOJO新一集的舒爽……\n2018-10-08 《逍遥游》完结了，又追完了一本小说，现在能看的书真的不多了。。\n2018-10-07 好久没更新随笔了，这阵子人懒散了好多，肚子也多了几圈，国庆回到家里人人都说我胖了，确实，上班一年我竟然重了二十斤左右。要知道当初大一那会还不到一百斤，瘦的跟猴子似的，现在却已经一百二十多了。\n马上就要新的一年了，距离三十大关又进了一步，我时间不多啦，得加把劲践行自己的目标，顺便把肥给减了。。\n2018-09-12 今天早上看到唐家三少妻子去世的消息，有些震惊，心情不知道怎么形容，难受又复杂。高中最早接触的网络小说之一就是三少写的光之子，里边男主女主就是化用的他们夫妻两人的名字，到现在还记忆深刻。\n曾经受到三少的影响，很想去写书，只是时间无情，人很脆弱。。只能说句，三少，节哀。\n2018-08-17 今天是七夕，emmm 单身汪岁\n2018-08-13 自律真的很重要，我要培养自己的自律能力，毕竟已经是叔叔辈了……\n2018-08-06 今晚一口气看了《刺客伍六七》这部国产动画，简直爽到！上一部让我看得这么酣畅淋漓的国产动画是《凸变英雄》，之前就经常瞥见刺客伍六七的消息，只是一直都听不起兴趣去看，直到今天无意间点开了第一集，之后就一发不可收拾了，还好没错过。\n2018-08-02 建站100天！！！\n2018-07-28 今天去看了《西虹市首富》，挺有趣的，沈腾还是那么好玩，开心麻花街的作品还是让人看得好开心。当初那个春晚小品《扶不扶》真的惊为天人，已经看过十几遍了，O(∩_∩)O哈哈~\n2018-07-15 最近发现吃了香蕉后就会胃酸过多，也就是俗称的烧心。百度了下：\n香蕉性寒，脾胃虚寒、便溏腹泻者不能多食、生食，胃酸过的多者也不要吃香蕉，香蕉会增加胃酸分泌。所以最好不要空腹吃香蕉。\n明明以前吃香蕉都没什么事情，而且还是特地在饭后吃的，看来身体是真的越来越差了，要多锻炼才行。\n2018-06-13 喝了这么多年的牛奶才尴尬地发现，原来我的肠胃会对牛奶过敏，一喝牛奶就会拉肚子，以前一直以为是其他原因，没想到是对牛奶过敏，看来以后只能喝酸奶了……\n2018-04-24 在CSDN也写了一年的博客了，现在终于有了专属的个人博客了，用来记录自己平日里的感悟和积累~\n","permalink":"https://lewky.cn/posts/d65a1577.html/","tags":["随笔","生活"],"title":"随笔"},{"categories":["生活"],"contents":" Siting Log o(*￣▽￣*)ブ 持续更新中 TODO LIST 开源本站主题，主题名暂定为heap 2021-08-23 添加打赏榜\n2021-07-24 最近Waline评论被恶意攻击了，修改了配置：\n评论之前必须先注册登录 评论需要经过审核才可发布 2021-06-05 菜单栏支持子菜单 将站点部署到Vercel（2021年Vercel的原国内服务器被墙了，换了个新的CNAME才解决） 2021-06-02 添加抓猫咪游戏\n2021-04-24 添加文章top15页面\n2021-04-20 添加下拉菜单 添加BBS，使用Artitalk作为公告栏 2021-04-17 站点底部添加站点运行时间 关于页面去除头部的站点运行时间 2021-02-17 将评论改为Waline，并部署在Vercel 评论添加自定义表情包 修改友链样式 2021-01-24 修改站内搜索fuse.js的参数，优化中文搜索效果 添加site.webmanifest 添加文章过期提醒 添加文章打赏 2021-01-17 首页头像添加b站挂件\n2021-01-16 页面下方添加拉姆雷姆快捷跳转功能\n2021-01-15 添加文章加密功能\n2021-01-13 重新启用阅读原始文档功能，并解决GitHub Pages服务由于原始文档里的某些特殊代码导致部署失败的问题\n2021-01-10 添加右键菜单 评论区添加背景图片 2021-01-09 添加Mikutap。\n2020-12-29 解决LeanCloud流控问题。\n2020-12-27 友链墙功能完成。\n2020-12-23 Valine评论系统的邮件通知增强完成。\n2020-12-20 ※ 正式加入【十年之约】！\n要努力将个人站点维护十年以上！！有兴趣的朋友可以去十年之约的官网看看。\n2020-10-14 修复LoveIt主题的部分bug，更改了部分样式，主要包括：\n添加背景图片轮播 归档、分类页面添加了数量统计 修改了h2的样式 缩小目录的字体 修改了引用块样式 2020-10-09 ※ 开始将博客从Hexo迁移到Hugo，决定使用LoveIt主题，并正式将博客部署到了Pages上。\n2018-12-19 最近发现打开页面略慢略卡，发现是jquery-backstretch的cdn加载不了，原本官网使用的cdn是cloudflare的，现在改成了另一个cdn地址。\n于是将jquery-backstretch的cdn修改了官网上最新的，总算变快了。\n2018-11-16 将鼠标点击产生的文字设为不可选定。\n2018-11-10 解决在适配手机屏幕时，页面右上角的GitHub彩带被覆盖掉的问题。\n2018-09-18 添加了图片懒加载插件hexo-lazyload-image 出于强迫症，还是关闭了不蒜子的统计功能，目的是为了解决下边的问题二。 2018-08-21 最近发现了两个问题：\n如果文章不写小标题，是不会生成文章目录的，如果启用了leancloud的阅读计数功能，这时候这篇文章的阅读页面的侧边栏就会失去affix.js的固定定位效果；(该bug在火狐浏览器下偶尔会触发，在360浏览器下百分百触发) 如果启用了不蒜子计数，在360浏览器下如果滚动页面时，侧边栏的底部无法和正文模块的底部持平，侧边栏底部会比正文模块的短一些。该问题在火狐浏览器下不存在。 解决方案：\n问题一需要给每篇文章都起至少一个小标题，这样就会自动生成文章目录，也就不存在这个问题了。 也可以选择关闭leancloud的阅读计数功能，重新生成静态页面就行了。 问题二对于强迫症来说很难受，要么关闭不蒜子计数，要么不使用360浏览器。 2018-08-18 修改了hexo-neat的压缩选项，优化页面的加载\n2018-08-17 头像挂件添加自动刷新功能和彩蛋\n2018-08-14 去掉了文本首行缩进，首行缩进有个问题：当一个段落内存在换行时，比如使用\u0026lt;br\u0026gt;，会导致换行后无法缩进，不太好看；找了好久也没找到解决的方法，只能取消文本的首行缩进了。\n如果需要首行缩进还是自己手动添加\u0026amp;emsp;\u0026amp;emsp;(全角空格，即对应两个中文空格)……\n2018-07-26 改善文章目录的换行问题 添加文章不在首页显示的功能：在文件头里添加not_show: true即可启用 2018-07-21 添加了404页面\n2018-07-07 添加网页标题监听事件\n2018-06-30 代码块添加复制按钮\n2018-06-20 使用 hexo-neat 压缩博文插件，优化博客静态资源\n2018-06-16 添加 Font Awesome 4.6.2的CDN，支持使用font awesome4或5 友情链接里添加恶搞页面 关于页面添加站点运行时间 添加站点背景图片轮播 2018-06-10 使用来必力作为评论系统\n2018-06-03 添加头像挂件功能\n2018-05-12 文章启用字数统计、阅读时长，修改其显示的样式 使用 Font Awesome Free CDN ( upgrade from version 4 to 5 ) 添加文章加密功能 指定 Markdown 的解析器 修改 Hexo 永久链接的默认格式 2018-05-01 添加建站日志\n2018-04-24 ※ 使用 Hexo 搭建个人博客\n","permalink":"https://lewky.cn/posts/e62c38c4.html/","tags":["建站日志","生活"],"title":"建站日志"},{"categories":["工作记录"],"contents":"最近写了个Java正则表达式来验证RFC 5322规范的邮件地址，这个邮件地址比较复杂，对于这样一个地址：userName@domainName，它满足以下条件：\n对于userName 1、允许使用以下所有字符作为用户名： [A-Z], [a-z], [0-9], [.], [-], [_], [@], [!], [#], [$], [%], [\u0026amp;], [\u0026rsquo;], [*], [+], [/], [=], [?], [^], [`], [{], [|], [}], [~] 2、允许使用所有的ASCII字符，包括控制字符，前提条件是这些字符是被[\\]所转义的或者被一对[\u0026quot;]所包括起来，比如下边的格式： \u0026quot; [ ♥\u0026quot;或者\\]都是合法的用户名 3、[.]不能出现在用户名的开头或者结尾，也不能连续出现两个以上的[.]\n对于domainName 1、只能使用[A-Z],[a-z],[0-9],[-] 2、如果使用了[-]，那么该字符不能出现在域名的开头或结尾 3、顶级域名不能全是数字 4、至少要有二级域名\nJava正则表达式 由于是用来验证邮件地址的，使用的是matches()这个完全匹配的方法，并且使用非捕获组来提高性能。 写了两个正则表达式，一个是用来验证单个邮件地址的(比如xxx@xx.xx)；一个是用来验证多个邮件地址的，即多个邮件地址之间用空白符或者英文的逗号或分号分割开来(比如xxx@xx.xx; xx@xxx.xxx)。\n1 2 3 4 5 6 7 8 9 10 /** Regex format for multiple EmailValidator */ public static final String MULTIPLE_EMAIL_REGEX_FORMAT = \u0026#34;(?:(?:%1$s)(?:(?:\\\\s*,\\\\s*)|(?:\\\\s*;\\\\s*)|\\\\s*$))*\u0026#34;; /** Regex for single EmailValidator */ public static final String SINGLE_EMAIL_REGEX = \u0026#34;(?:(?:[A-Za-z0-9\\\\-_@!#$%\u0026amp;\u0026#39;*+/=?^`{|}~]|(?:\\\\\\\\[\\\\x00-\\\\xFF]?)|(?:\\\u0026#34;[\\\\x00-\\\\xFF]*\\\u0026#34;))+(?:\\\\.(?:(?:[A-Za-z0-9\\\\-_@!#$%\u0026amp;\u0026#39;*+/=?^`{|}~])|(?:\\\\\\\\[\\\\x00-\\\\xFF]?)|(?:\\\u0026#34;[\\\\x00-\\\\xFF]*\\\u0026#34;))+)*)@(?:(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\\\.)+(?:(?:[A-Za-z0-9]*[A-Za-z][A-Za-z0-9]*)(?:[A-Za-z0-9-]*[A-Za-z0-9])?))\u0026#34;; public static final Pattern SINGLE_EMAIL_REGEX_PATTERN = Pattern.compile(SINGLE_EMAIL_REGEX); /** Regex for multiple EmailValidator */ public static final String MULTIPLE_EMAIL_REGEX = String.format(MULTIPLE_EMAIL_REGEX_FORMAT, SINGLE_EMAIL_REGEX); public static final Pattern MULTIPLE_EMAIL_REGEX_PATTERN = Pattern.compile(MULTIPLE_EMAIL_REGEX); 上边验证单个邮件地址的正则表达式太长了，这里分一下行：\n1 2 3 4 5 public static final String SINGLE_EMAIL_REGEX = \u0026#34;(?:(?:[A-Za-z0-9\\\\-_@!#$%\u0026amp;\u0026#39;*+/=? ^`{|}~]|(?:\\\\\\\\[\\\\x00-\\\\xFF]?)|(?:\\\u0026#34;[\\\\x00-\\\\xFF]*\\\u0026#34;))+(?:\\\\.(?:(?:[A-Za-z0-9\\\\- _@!#$%\u0026amp;\u0026#39;*+/=?^`{|}~])|(?:\\\\\\\\[\\\\x00-\\\\xFF]?)|(?:\\\u0026#34;[\\\\x00-\\\\xFF]*\\\u0026#34;))+)*) @(?:(?:[A-Za-z0-9](?:[A-Za-z0-9-]*[A-Za-z0-9])?\\\\.)+ (?:(?:[A-Za-z0-9]*[A-Za-z][A-Za-z0-9]*)(?:[A-Za-z0-9-]*[A-Za-z0-9])?))\u0026#34;; 最后附上一些测试用的邮件地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // =========TRUE EMAIL========== final String email = \u0026#34;Abc\\\\@def@example.com\u0026#34;; //true // final String email = \u0026#34;Fred\\\\ Bloggs@example.com\u0026#34;; //true // final String email = \u0026#34;Joe.\\\\\\\\Bloggs@example.com\u0026#34;; //true // final String email = \u0026#34;\\\u0026#34;Abc@def\\\u0026#34;@example.com\u0026#34;; //true // final String email = \u0026#34;\\\u0026#34;Fred Bloggs\\\u0026#34;@example.com\u0026#34;; //true // final String email = \u0026#34;user+mailbox@example.com\u0026#34;; //true // final String email = \u0026#34;customer/department=shipping@example.com\u0026#34;; //true // final String email = \u0026#34;$A12345@example.com\u0026#34;; //true // final String email = \u0026#34;!def!xyz%abc@example.com\u0026#34;; //true // final String email = \u0026#34;_somename@example.com\u0026#34;; //true // final String email = \u0026#34;Natasha.O\u0026#39;neill@thewarehouse.com\u0026#34;; //true // final String email = \u0026#34;ab.c@exam-ple.c--om\u0026#34;; // true // final String email = \u0026#34;------ab.c@example.12.com\u0026#34;; // true // final String email = \u0026#34;------ab.c@example.12.com \u0026#34;; // true // ==========FALSE EMAIL========== // final String email = \u0026#34;abc[@example.com\u0026#34;; //false // final String email = \u0026#34;.abc@example.com\u0026#34;; //false // final String email = \u0026#34;ab..c@example.com\u0026#34;; // false // final String email = \u0026#34;ab.c@example.com.\u0026#34;; // false // final String email = \u0026#34;ab.c@example.com-\u0026#34;; // false // final String email = \u0026#34;------ab.c.@example.com\u0026#34;; // false // final String email = \u0026#34;------ab.c@-example-.com\u0026#34;; // false // final String email = \u0026#34;------ab.c@com\u0026#34;; // false // final String email = \u0026#34;------ab.c@example.12\u0026#34;; // false ","permalink":"https://lewky.cn/posts/6c2d7772.html/","tags":["Java","正则表达式","工作记录"],"title":"验证邮件地址的Java正则表达式"},{"categories":["生活"],"contents":"2018-03-31 《Ready Player One》 ReadyPlayerOne\r这部电影国内译名又叫头号玩家、玩家一号，讲述的是在未来人们为了躲避一团糟的现实而沉迷于一个名为绿洲的现实虚拟游戏。\n虽然这部电影并没有直接传达什么正能量的道理之类的，但是这部3D电影所展现出来的绿洲的奇妙与各种彩蛋却是令人看得目不暇接、直呼过瘾。这绝对是一部值得去电影院大饱眼福的爽快作品！\n2018-03-17 《小萝莉的猴神大叔》 小萝莉的猴神大叔\r今天去看了这部评分高达9.6分的印度电影，确实是挺好看的。这是讲述一个印度摩罗神信徒在没有护照和签证的情况下，不惜越过边境也要坚持将一个异国走失的哑巴小女孩送回巴基斯坦的父母家里的故事。印巴两国之间的仇恨，迥异的宗教信仰、森严的种姓制度都令我印象深刻。\n就算是宗教信仰不同，也不应当局限于各自的神明教义，神明传播于世间的是爱，而不是仇恨，不同的宗教信仰，也是有着共通的点。而上一代人的仇恨，也不应归结到下一代的孩子身上。仇恨的故事固然吸引眼球，但是爱的故事更应该被关注传颂。\n对于印巴两国的大人来说，对方即是邪恶，但是战争本就如此，不存在绝对的正义与邪恶，只有恪守信仰、遵从心中那杆爱与公正的天秤的一方，才是真正无愧于心的正义者。\n","permalink":"https://lewky.cn/posts/23475.html/","tags":["影评"],"title":"影评汇总"},{"categories":["PostgreSQL"],"contents":"重命名数据库 1 ALTER DATABASE db_1 RENAME TO db_2; 也可以用下面的SQL：\n1 UPDATE pg_database SET datname = \u0026#39;db_2\u0026#39; WHERE datname = \u0026#39;db_1\u0026#39;; 注意在重命名数据库的时候，不能在被重命名的数据库里执行以上SQL，也不能有其他用户连接该数据库。\n查询表结构和索引信息 PostgreSQL的表一般都是建立在public这个schema下的，假如现在有个数据表t_student，可以用以下几种方式来查询表结构和索引信息。\n使用\\d元命令查看表字段信息和索引信息 在cmd界面使用psql连接db后，输入\\d加上表名即可：\n1 \\d t_student 通过系统数据字典查询表结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 select col.table_schema, col.table_name, col.ordinal_position, col.column_name, col.data_type, col.character_maximum_length, col.numeric_precision, col.numeric_scale, col.is_nullable, col.column_default, des.description from information_schema.columns col left join pg_description des on col.table_name::regclass = des.objoid and col.ordinal_position = des.objsubid where table_schema = \u0026#39;public\u0026#39; and table_name = \u0026#39;t_student\u0026#39; order by ordinal_position; 或者简单点：\n1 2 select * from information_schema.columns where table_schema=\u0026#39;public\u0026#39; and table_name=\u0026#39;t_student\u0026#39;; 通过系统数据字典查询索引信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 select A.SCHEMANAME, A.TABLENAME, A.INDEXNAME, A.TABLESPACE, A.INDEXDEF, B.AMNAME, C.INDEXRELID, C.INDNATTS, C.INDISUNIQUE, C.INDISPRIMARY, C.INDISCLUSTERED, D.DESCRIPTION from PG_AM B left join PG_CLASS F on B.OID = F.RELAM left join PG_STAT_ALL_INDEXES E on F.OID = E.INDEXRELID left join PG_INDEX C on E.INDEXRELID = C.INDEXRELID left outer join PG_DESCRIPTION D on C.INDEXRELID = D.OBJOID, PG_INDEXES A where A.SCHEMANAME = E.SCHEMANAME and A.TABLENAME = E.RELNAME and A.INDEXNAME = E.INDEXRELNAME and E.SCHEMANAME = \u0026#39;public\u0026#39; and E.RELNAME = \u0026#39;t_student\u0026#39;; 查询所有的表名 1 2 3 4 5 6 7 8 9 10 11 12 select n.nspname, relname from pg_class c, pg_namespace n where c.relnamespace = n.oid and nspname = \u0026#39;public\u0026#39; and relkind = \u0026#39;r\u0026#39; order by relname; 可视化工具DBeaver 对于上述的sql语句只需要修改要查询的table name，可以根据需要自行修改想要查询的column。如果是通过DBeaver来连接数据库，还可以直接在当前的数据库实例下打开schema里的public选项，接着选中table，选中你想查看的表，可以很直观地看到该表的各种信息：column、index等等。\n查看表的主外键等约束关系 1 2 3 4 5 6 7 8 9 10 SELECT tc.constraint_name, tc.table_name, kcu.column_name, ccu.table_name AS foreign_table_name, ccu.column_name AS foreign_column_name, tc.is_deferrable,tc.initially_deferred FROM information_schema.table_constraints AS tc JOIN information_schema.key_column_usage AS kcu ON tc.constraint_name = kcu.constraint_name JOIN information_schema.constraint_column_usage AS ccu ON ccu.constraint_name = tc.constraint_name WHERE constraint_type = \u0026#39;FOREIGN KEY\u0026#39; AND tc.table_name = \u0026#39;your table name\u0026#39;; constraint_type有四种：UNIQUE、PRIMARY KEY、CHECK、FOREIGN KEY\n通过修改上边sql语句的table_name和constraint_type来进行相应的查询。\n参考链接 Tips - 重命名PostgreSQL数据库 Postgresql10数据库之更改数据库的名称 PostgreSQL：如何查询表的字段信息？ ","permalink":"https://lewky.cn/posts/postgresql-ddl.html/","tags":["工作记录"],"title":"PostgreSQL - DDL操作汇总"},{"categories":["工作记录"],"contents":"问题与分析 最近遇到个问题，在页面的搜索框输入带有空格的字符串时，总是无法从db中搜索出来对应的数据，于是将db里的空格复制出来，发现其ASCII码值为160，这才知道，原来ASCII码中除了32之外还有160这个特殊的空格。下边是查看字符对应ASCII值的逻辑：\n1 2 3 4 final char c1 = \u0026#39; \u0026#39;; //db里的空格 final char c2 = \u0026#39; \u0026#39;; //手动输入的空格 System.out.println((int)c1); //160 System.out.println((int)c2); //32 平时我们用键盘输入的空格的ASCII值是32，而这个ASCII值为160的空格，其实是不间断空格(non-breaking space)，是不是从来没听说过这东东？其实你平时一定也用过很多次的，就是页面上的\u0026amp;nbsp;所产生的空格。\n不间断空格non-breaking space的缩写正是nbsp。这中空格的作用就是在页面换行时不被打断，如下：\n1 页面某一行的末尾是一个人名Zhang Xiaoming 我们希望在换行时人名不会被打断，导致Zhang 在第一行末尾，而Xiaoming跑到第二行开头，而是保持完整的人名在同一行的末尾，于是就有了不间断空格。(在word中也有这种空格的使用)\n如果使用了平常的空格，就会被页面压缩，变成下边这样\n1 2 页面某一行的末尾是一个人名Zhang Xiaoming 不间断空格的去除 但是不间断空格有个问题，就是它无法被trim()所裁剪，也无法被正则表达式的\\s所匹配，也无法被StringUtils的isBlank()所识别，也就是说，无法像裁剪寻常空格那样移除这个不间断空格。\n我们可以利用不间断空格的Unicode编码来移除它，其编码为\\u00A0。\n解决办法如下：\n1 2 3 4 5 6 replace(\u0026#34;\\u00A0\u0026#34;, \u0026#34;\u0026#34;) replaceAll(\u0026#34;\\\\u00A0+\u0026#34;, \u0026#34;\u0026#34;) //这是正则表达式的写法 String str = \u0026#34;aacsdfe \u0026#34;; //包含了不间断空格的字符串 str = str.replace(\u0026#34;\\u00A0\u0026#34;, \u0026#34;\u0026#34;); str = str.replaceAll(\u0026#34;\\\\u00A0+\u0026#34;, \u0026#34;\u0026#34;); ","permalink":"https://lewky.cn/posts/b226c16f.html/","tags":["工作记录","不间断空格"],"title":"特殊的空格-ASCII码值160"},{"categories":["PostgreSQL"],"contents":"和聚合函数的区别 开窗函数，也叫窗口函数，一般可以用开窗函数来做一些排行之类的统计操作。开窗函数必须搭配over()子句作为查询的条件，否则会报错。over()子句可以用partition by进行分组，以及用order by排序。\n聚合函数是将多条记录聚合为一条；而开窗函数是每条记录都会执行，有几条记录执行完还是几条，聚合函数也可以用于开窗函数中。\nrank() 对数据进行排名，对于并列的数据会占据之后空余的名次数目，比如第一名有两个数据，即前两条数据排名都为1，第三条数据的名次则为3。\n1 2 3 -- 查询一个商品的版本排行（一个商品在数据库中保存了多条记录，用以版本控制） -- 这里是按照商品的序号分组，然后同一个分组内用版本号逆序排序 select ref_no,\u0026#34;version\u0026#34;,rank() over(partition by ref_no order by \u0026#34;version\u0026#34; desc nulls last) from tb_item where updated_on \u0026gt; \u0026#39;2022-01-01\u0026#39;; 查询结果如下：\nref_no version rank ITM2111-000070 18 1 ITM2111-000070 17 2 ITM2111-000070 16 3 ITM2111-000072 10 1 1 2 -- 不分组，直接按照所有商品的版本号逆序排序（其实就相当于按版本号分组） select ref_no,\u0026#34;version\u0026#34;,rank() over(order by \u0026#34;version\u0026#34; desc nulls last) from tb_item where updated_on \u0026gt; \u0026#39;2022-01-01\u0026#39;; 查询结果如下：\nref_no version rank ITM2112-000015 23 1 ITM2111-000089 23 1 ITM2111-000070 18 3 ITM2112-000091 11 4 ITM2203-000002 11 4 ITM2201-000014 11 4 ITM2201-000060 10 7 dense_rank() dense是稠密的意思，因此这个函数效果很rank()差不多，区别在于它不会空出所占的名次，比如第一名有两个数据，即前两条数据排名都为1，第三条数据的名次则为2。\n1 2 -- 不分组，直接按照所有商品的版本号逆序排序（其实就相当于按版本号分组） select ref_no,\u0026#34;version\u0026#34;,dense_rank() over(order by \u0026#34;version\u0026#34; desc nulls last) from tb_item where updated_on \u0026gt; \u0026#39;2022-01-01\u0026#39;; 查询结果如下：\nref_no version dense_rank ITM2112-000015 23 1 ITM2111-000089 23 1 ITM2111-000070 18 2 ITM2112-000091 11 3 ITM2203-000002 11 3 ITM2201-000014 11 3 ITM2201-000060 10 4 row_number() 单纯按照行数排行，不会考虑并列行。\n1 2 -- 不分组，直接按照所有商品的版本号逆序排序（其实就相当于按版本号分组） select ref_no,\u0026#34;version\u0026#34;,row_number() over(order by \u0026#34;version\u0026#34; desc nulls last) from tb_item where updated_on \u0026gt; \u0026#39;2022-01-01\u0026#39;; 查询结果如下：\nref_no version row_number ITM2112-000015 23 1 ITM2111-000089 23 2 ITM2111-000070 18 3 ITM2112-000091 11 4 ITM2203-000002 11 5 ITM2201-000014 11 6 ITM2201-000060 10 7 参考链接 rank() over,dense_rank() over,row_number() over的区别 ","permalink":"https://lewky.cn/posts/postgresql-window-function/","tags":["工作记录"],"title":"PostgreSQL - 开窗函数汇总"},{"categories":["工作记录"],"contents":"代码实现 最近使用到JavaMail，写了个简单的工具类，记录一下。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 import java.util.Date; import java.util.Properties; import javax.mail.MessagingException; import javax.mail.Session; import javax.mail.Transport; import javax.mail.internet.AddressException; import javax.mail.internet.InternetAddress; import javax.mail.internet.MimeBodyPart; import javax.mail.internet.MimeMessage; import javax.mail.internet.MimeMessage.RecipientType; import javax.mail.internet.MimeMultipart; public class JavaMailUtils { //连接SMTP服务器的主机名，这里以qq邮箱为例 private static final String SMTP_HOST = \u0026#34;smtp.qq.com\u0026#34;; //连接的端口号，587为ssl端口，默认为25端口 private static final String SMTP_PORT = \u0026#34;587\u0026#34;; //发件人 private static final String MAIL_FROM = \u0026#34;XXX@qq.com\u0026#34;; //连接邮件服务器的用户名（邮箱地址去除了@qq.com的部分） private static final String USER = \u0026#34;XXX\u0026#34;; /** * 授权码，就是你在邮件服务器上注册的密码，不是你的qq密码 * 在邮箱里开启smtp/imap服务时需要发送短信，成功后会得到一个授权码 */ private static final String PASSWORD = \u0026#34;授权码\u0026#34;; private JavaMailUtils() { } /** * send mail without attachments * * @param mailTo * @param mailCc * @param subject * @param content * @throws AddressException * @throws MessagingException */ public static void sendMail(final String mailTo, final String mailCc, final String subject, final String content) throws Exception { // get the session final Session session = getSession(); // create a mail final MimeMessage message = createMail(session, mailTo, mailCc, subject, content); // get the transport final Transport transport = session.getTransport(); transport.connect(USER, PASSWORD); transport.sendMessage(message, message.getAllRecipients()); transport.close(); } public static void sendMail(final String mailTo, final String mailCc, final String subject, final String content, final String[] attachments) throws Exception { // get the session final Session session = getSession(); // create a mail final MimeMessage message = createMail(session, mailTo, mailCc, subject, content, attachments); // get the transport final Transport transport = session.getTransport(); transport.connect(USER, PASSWORD); transport.sendMessage(message, message.getAllRecipients()); transport.close(); } /** * create a mail without attachments * * @param session * @param mailTo * @param mailCc * @param subject * @param content * @return * @throws Exception */ private static MimeMessage createMail(final Session session, final String mailTo, final String mailCc, final String subject, final String content) throws Exception { final MimeMessage message = new MimeMessage(session); message.setFrom(new InternetAddress(MAIL_FROM)); message.setRecipients(RecipientType.TO, InternetAddress.parse(mailTo)); message.setRecipients(RecipientType.CC, InternetAddress.parse(mailCc)); message.setSubject(subject); message.setContent(content, \u0026#34;text/html;charset=UTF-8\u0026#34;); message.setSentDate(new Date()); message.saveChanges(); return message; } /** * create a mail with attachments * * @param session * @param mailTo * @param mailCc * @param subject * @param content * @param attachments * @return */ private static MimeMessage createMail(final Session session, final String mailTo, final String mailCc, final String subject, final String content, final String[] attachments) throws Exception { final MimeMessage message = new MimeMessage(session); message.setFrom(new InternetAddress(MAIL_FROM)); message.setRecipients(RecipientType.TO, InternetAddress.parse(mailTo)); message.setRecipients(RecipientType.CC, InternetAddress.parse(mailCc)); message.setSubject(subject); // set the multipart of the mail final MimeMultipart multipart = new MimeMultipart(); // set content part of the mail final MimeBodyPart contentPart = new MimeBodyPart(); contentPart.setContent(content, \u0026#34;text/html;charset=UTF-8\u0026#34;); multipart.addBodyPart(contentPart); // set attachment part of the mail final MimeBodyPart attach1 = new MimeBodyPart(); final MimeBodyPart attach2 = new MimeBodyPart(); if (attachments != null \u0026amp;\u0026amp; attachments.length != 0) { final int length = attachments.length; if (length == 1) { attach1.attachFile(attachments[0]); multipart.addBodyPart(attach1); } if (length == 2) { attach1.attachFile(attachments[0]); attach2.attachFile(attachments[1]); multipart.addBodyPart(attach1); multipart.addBodyPart(attach2); } } message.setContent(multipart); message.setSentDate(new Date()); message.saveChanges(); return message; } /** * get the session to transport mails */ private static Session getSession() { // set the properties for connecting the mail server final Properties props = new Properties(); props.setProperty(\u0026#34;mail.debug\u0026#34;, \u0026#34;true\u0026#34;); props.setProperty(\u0026#34;mail.transport.protocol\u0026#34;, \u0026#34;smtp\u0026#34;); props.setProperty(\u0026#34;mail.host\u0026#34;, SMTP_HOST); props.setProperty(\u0026#34;mail.smtp.auth\u0026#34;, \u0026#34;true\u0026#34;); props.setProperty(\u0026#34;mail.smtp.port\u0026#34;, SMTP_PORT); // ssl props.setProperty(\u0026#34;mail.imap.ssl.enable\u0026#34;, \u0026#34;true\u0026#34;); props.setProperty(\u0026#34;mail.imap.ssl.socketFactory.class\u0026#34;, \u0026#34;DummySSLSocketFactory\u0026#34;); props.setProperty(\u0026#34;mail.imap.ssl.socketFactory.fallback\u0026#34;, \u0026#34;false\u0026#34;); // create the session final Session session = Session.getDefaultInstance(props); return session; } } 以上的工具类有个进行了重载的方法，因为对于没有附件的邮件和有附件的邮件，在构造邮件对象时是不一样的，有附件的邮件会稍微复杂一点。接着是测试类。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public class Test { //收件人，多人的话要用英文的\u0026#34;,\u0026#34;来隔开 private static final String MAIL_TO = \u0026#34;XXX@qq.com\u0026#34;; //抄送人，多人的话要用英文的\u0026#34;,\u0026#34;来隔开 private static final String MAIL_CC = \u0026#34;XXX@qq.com\u0026#34;; //邮件的主题（因为只是测试用，所以写成静态常量了） private static final String SUBJECT = \u0026#34;It\u0026#39;s a test mail\u0026#34;; //邮件的内容（因为只是测试用，所以写成静态常量了） private static final String CONTENT = \u0026#34;Hello World!\u0026lt;br\u0026gt;Bye!\u0026#34;; private static final String FILE_1 = \u0026#34;附件1的路径\u0026#34;; private static final String FILE_2 = \u0026#34;附件2的路径\u0026#34;; public static void main(final String[] args) { final String[] attachments = {}; // final String[] attachments = {FILE_1, FILE_2}; try { // JavaMailUtils.sendMail(MAIL_TO, MAIL_CC, SUBJECT, CONTENT); JavaMailUtils.sendMail(MAIL_TO, MAIL_CC, SUBJECT, CONTENT, attachments); } catch (final Exception e) { e.printStackTrace(); } } } 最后是导入的jar包：\njavax.mail-1.6.0.jar\n补充 JavaMail提供了多个属性，这些属性的值都必须是字符串，否则设置无效，如下：\nmail.smtp.sendpartial设置为\u0026quot;true\u0026quot;，当一次发送多个地址时就不会因为某个地址无效而全部发送失败。 mail.smtp.auth设置为\u0026quot;false\u0026quot;时，则无需验证账号密码即可发送邮件。SMTP只是个简单的邮件发送协议，如果不设置校验，可能会造成垃圾邮件泛滥的问题。不过我发现公司项目在发送邮件时并没有设置验证，可能是图方便。 参考链接 [疑问]JavaMail的mail.smtp.sendpartial不起作用？ ","permalink":"https://lewky.cn/posts/javamail.html/","tags":["工作记录"],"title":"JavaMail-发送一封简单邮件（附带附件）"},{"categories":["cmd"],"contents":"情景一：两个bat文件在同一个目录下 有时候我们需要在一个bat文件中调用另一个bat文件，比如我们想在a.bat中调用b.bat，如下。\na.bat\n1 2 3 4 5 @echo off echo I am a.bat... echo now run the b.bat call b.bat echo over b.bat\n1 2 @echo off echo I am b.bat... 在cmd窗口中执行a.bat，结果如下：\n1 2 3 4 I am a.bat... now run the b.bat I am b.bat... over 通过call命令，我们可以调用另一个bat文件，执行完会再返回到原本的bat文件中继续执行。但是这里有个问题，就是两个bat文件必须在同一个目录下，否则会找不到要call的bat文件。\n情景二：两个bat文件不在同一个目录下 假如要call的bat文件在其他目录，我们可以在call之前，先使用cd /d 目录来进入相应的目录，接着再call就行了，如下：\na.bat\n1 2 3 4 5 6 @echo off echo I am a.bat... echo now run the b.bat cd /d D:\\test call b.bat echo over b.bat\n1 2 @echo off echo I am b.bat... 执行后得到结果如下：\n1 2 3 4 I am a.bat... now run the b.bat I am b.bat... over 不过，这里需要注意的是，此时执行完命令的cmd窗口的当前目录是b.bat所在的目录了，而不是a.bat的目录。\n情景三：开启一个新的cmd窗口来运行另一个bat文件 假如我们希望另外启动一个新的cmd窗口来运行b.bat，可以通过start cmd命令来实现，如下：\na.bat\n1 2 3 4 5 6 @echo off echo I am a.bat... echo now run the b.bat cd /d D:\\test start \u0026#34;\u0026#34; cmd /k call b.bat echo over b.bat\n1 2 @echo off echo I am b.bat... 执行后得到结果如下：\n原本的cmd窗口中：\n1 2 3 I am a.bat... now run the b.bat over 新的cmd窗口中：\n1 I am b.bat... 这里简单解释下该命令的参数：\n1 start \u0026#34;\u0026#34; cmd /k call b.bat \u0026quot;\u0026quot;是一段字符串，代表新打开的cmd窗口的名字，可以随便起名。 /k是表示新打开的cmd窗口在执行完命令后保存打开状态，如果希望执行完就关闭窗口就使用/c call b.bat表示call命令，即调用b.bat文件；该命令可以用\u0026quot;\u0026quot;括起来，即：\u0026quot;call b.bat\u0026quot;\n","permalink":"https://lewky.cn/posts/39f5b6b2.html/","tags":["cmd"],"title":"cmd - 如何在bat文件中调用另一个bat文件"},{"categories":["cmd"],"contents":"echo命令 bat文件是dos下的批处理文件，可以一次性执行多条dos命令，其扩展名为.bat或.cmd，通过双击该文件或者在cmd窗口中输入该文件名可以在cmd窗口中按文件中的顺序执行多条dos命令。\necho是回显命令，会将echo后的内容输出到cmd窗口中，比如在一个Test.bat文件中输入如下命令：\n1 echo hello! 执行该文件后，会在cmd窗口中输出：\n1 2 \u0026gt;C:\\Users\\123\\Desktop\u0026gt;echo hello! hello! 以上第一行是输出执行的echo命令，第二行是输出执行后的结果。\n我们将Test.bat文件的内容改成：\n1 2 echo hello! echo bye! 将得到如下的结果：\n1 2 3 4 5 \u0026gt;C:\\Users\\123\\Desktop\u0026gt;echo hello! hello! \u0026gt;C:\\Users\\123\\Desktop\u0026gt;echo bye! bye! 我们可以发现，cmd窗口中将每条命令都给一起打印了出来，我们希望只输出要回显的内容，而不会包括命令本身，可以在命令的最前边加上@，如下：\n1 2 @echo hello! @echo bye! 接着执行该bat文件，可以得到：\n1 2 \u0026gt;hello! bye! 如果一个bat文件中有着几十条上百条命令，我们就需要一个个加上@，这样就太累了，我们可以通过echo off命令来实现，将bat文件改成如下：\n1 2 3 echo off echo hello! echo bye! 执行该bat文件，将得到如下结果：\n1 2 3 \u0026gt;C:\\Users\\123\\Desktop\u0026gt;echo off hello! bye! 我们发现，虽然第二行和第三行关闭了命令回显，可是第一行的echo off命令被打印出来了，我们只需要在第一行加上@就可以了，如下：\n1 2 3 @echo off echo hello! echo bye! 现在再执行该bat文件，就可以关闭回显了：\n1 2 \u0026gt;hello! bye! 这就是为什么很多bat文件一开始总是以这样的形式开头：\n1 2 @echo off echo XXXXXX 对于被关闭的回显，可以通过echo on来恢复回显。\n","permalink":"https://lewky.cn/posts/cmd-echo.html/","tags":["cmd"],"title":"cmd - bat文件如何关闭回显"},{"categories":["MySQL"],"contents":"问题与分析 最近发现之前部署在阿里云的一个web项目，每过一段时间就会报错，但是刷新下页面就会显示正常；在过了比较长的一段时间后，又会报同样的错误，如下：\n1 2 3 4 5 6 7 8 com.mysql.jdbc.exceptions.jdbc4.CommunicationsException: Communications link failure The last packet sent successfully to the server was *,*** milliseconds ago. The driver has not received any packets from the server. at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method) at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:57) at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45) at java.lang.reflect.Constructor.newInstance(Constructor.java:526) at com.mysql.jdbc.Util.handleNewInstance(Util.java:408) at com.mysql.jdbc.SQLError.createCommunicationsException(SQLError.java:1137) 在网上查了下资料，原来是因为项目中使用了连接池，由于连接池里的连接长时间闲置着，而MySQL默认的非交互式连接的闲置时间是8小时；也就是说，当连接池里的连接闲置超过8小时后就会被MySQL数据库自动断开而失效。\n由于连接池并不知道连接已经失效了，依然保持着这些失效的连接，这导致web项目在一段时间后访问页面时报错，而在刷新页面后连接池重新获取了有效的连接，所以项目又可以正常访问了。\n这里涉及到MySQL关于交互式连接和非交互式连接的概念。\n交互式连接 通俗的说，在cmd里直接和MySQL进行各种sql操作的连接方式就是交互式连接，这里走的是TCP协议。\n非交互式连接 而直接在项目中对MySQL进行sql操作的方式则是非交互式连接，我们的应用服务器通过Hibernate或者JDBC来实现和数据库的通信。\n怎么解决连接闲置超时的问题？ 这两种连接方式都有各自对应的一个超时时间属性，交互式连接是interactive_timeout；非交互式连接是wait_timeout。\n既然是闲置超时，那么解决的办法也很简单，就是直接将这个时间设置得更长些；在MySQL中最多可以设置到365天(即31536000，默认单位是s)，有两种设置的方法。\n第一种设置方式：修改配置文件my.ini文件 该配置文件在MySQL的安装目录下，如果没有此文件，可以复制my-default.ini文件，将生成的复件重命名成my.ini；然后在文件中添加如下语句：\n1 2 wait_timeout=31536000 interactive_timeout=31536000 如果没有这两个语句则表示默认值是8小时(60608=28800)；需要注意的是，wait_timeout的最大值分别是24天/365天(Windows/Linux)。\n第二种设置方式：使用mysql命令进行修改 1 2 set global interactive_timeout=设置值 set global wait_timeout=设置值 不过闲置时间设置得过大并不好，MySQL里大量的SLEEP连接无法及时释放，拖累系统性能；设置得过小又容易产生如上所述的错误；由于我们的web项目中经常会使用到连接池技术，所以我们有更好的解决方法，那就是在项目中设置连接池的属性。\n在项目中设置连接池的属性 我的项目是使用的c3p0，所以这里只介绍c3p0的设置方法，如下：\n方法一：减少连接池内连接的生存周期 既然MySQL连接的默认闲置时间是8小时，那么只要将连接池内连接的生产周期设置得比8小时短就行了。\n1 2 3 4 \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt; \u0026lt;!-- 连接的最大空闲时间，若超过该时间还没被使用过则会自动断开，单位为s，默认为0(即永远不会断开) --\u0026gt; \u0026lt;property name=\u0026#34;maxIdleTime\u0026#34; value=\u0026#34;1800\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 方法二：定期使用连接池内的连接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt; \u0026lt;!-- 定义所有连接测试都执行的测试语句。在使用连接测试的情况下这个可以显著提高测试速度。 注意：测试的表必须在初始数据源的时候就存在。Default:null --\u0026gt; \u0026lt;property name=\u0026#34;preferredTestQuery\u0026#34; value=\u0026#34;SELECT 1\u0026#34;/\u0026gt; \u0026lt;!-- 每1800秒检查所有连接池中的空闲连接 --\u0026gt; \u0026lt;property name=\u0026#34;idleConnectionTestPeriod\u0026#34; value=\u0026#34;1800\u0026#34;/\u0026gt; \u0026lt;!-- 如果设置为true，则每次从池中取一个连接就做一下测试，使用automaticTestTable或者preferredTestQuery来做一条查询语句。 看看连接好不好用，如果不好用就关闭它，接着重新从池中拿一个。 --\u0026gt; \u0026lt;property name=\u0026#34;testConnectionOnCheckout\u0026#34; value=\u0026#34;true\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; ","permalink":"https://lewky.cn/posts/1a76cb2d.html/","tags":["MySQL"],"title":"MySQL - 8小时连接闲置超时"},{"categories":["工作记录"],"contents":"问题与解决方案 key文件的格式有很多种，而putty的ppk文件是不能直接导入到xshell中来使用的，需要用puttygen将ppk文件转换成xshell支持的OPENSSH格式，操作如下：\n打开puttygen，打开菜单栏里的Conversions -\u0026gt; Import key，然后导入ppk文件，接着打开Conversions里的Export OpenSSH key，为这个要导出的文件起一个名字，该文件默认没有后缀名。可以选择设置密码，也可以不设置，如果不设置密码导出文件时会提示你，选是。这个key文件会被导出到和ppk文件相同的目录下。\n打开xshell，新建一个Session或修改已有的Session配置(Properties)，找到Connection -\u0026gt; Authentication，Method选择Public Key，User Name填写要登录的用户名，点击Browse按钮，然后Import刚才Putty导出的文件，由于这个文件我们刚才没有设置密码，所以Passphrase不用填，完成后如下。这样就由使用Putty登录转成使用自己熟悉的Xshell登录了。\n参考链接 Putty的ppk文件转成Xshell使用的key文件 ","permalink":"https://lewky.cn/posts/ppk-to-ssh-key.html/","tags":["Putty","Xshell"],"title":"Putty的ppk文件转成Xshell使用的key文件"},{"categories":["seckill"],"contents":"1. 高并发优化分析 关于并发\n并发性上不去是因为当多个线程同时访问一行数据时，产生了事务，因此产生写锁，每当一个获取了事务的线程把锁释放，另一个排队线程才能拿到写锁，QPS(Query Per Second每秒查询率)和事务执行的时间有密切关系，事务执行时间越短，并发性越高，这也是要将费时的I/O操作移出事务的原因。\n在本项目中高并发发生在哪？\n高并发发生的地方\r在上图中，红色的部分就表示会发生高并发的地方，绿色部分表示对于高并发没有影响。\n为什么需要单独获取系统时间？\n这是为了我们的秒杀系统的优化做铺垫。比如在秒杀还未开始的时候，用户大量刷新秒杀商品详情页面是很正常的情况，这时候秒杀还未开始，大量的请求发送到服务器会造成不必要的负担。\n我们将这个详情页放置到CDN中，这样用户在访问该页面时就不需要访问我们的服务器了，起到了降低服务器压力的作用。而CDN中存储的是静态化的详情页和一些静态资源（css，js等），这样我们就拿不到系统的时间来进行秒杀时段的控制，所以我们需要单独设计一个请求来获取我们服务器的系统时间。\n详情页\rCDN（Content Delivery Network）的理解\nCDN\r获取系统时间不需要优化\n因为Java访问一次内存（Cacheline）大约10ns，1s=10亿ns，也就是如果不考虑GC，这个操作1s可以做1亿次。\n秒杀地址接口分析\n无法使用CDN缓存，因为CDN适合请求对应的资源不变化的，比如静态资源、JavaScript；秒杀地址返回的数据是变化的，不适合放在CDN缓存； 适合服务端缓存：Redis等，1秒钟可以承受10万qps。多个Redis组成集群，可以到100w个qps. 所以后端缓存可以用业务系统控制。 秒杀地址接口优化\n秒杀地址接口优化\r秒杀操作优化分析\n无法使用cdn缓存 后端缓存困难： 库存问题 一行数据竞争：热点商品 大部分写的操作和核心操作无法使用CDN，也不可能在缓存中减库存。你在Redis中减库存，那么用户也可能通过缓存来减库存，这样库存会不一致，所以要通过mysql的事务来保证一致性。\n比如一个热点商品所有人都在抢，那么会在同一时间对数据表中的一行数据进行大量的update set操作。\n行级锁在commit之后才释放，所以优化方向是减少行级锁的持有时间。\n延迟问题很关键\n同城机房网络（0.5ms~2ms），最高并发性是1000qps。 Update后JVM -GC(垃圾回收机制)大约50ms，最高并发性是20qps。并发性越高，GC就越可能发生，虽然不一定每次都会发生，但一定会发生。 异地机房，比如北京到上海之间的网络延迟，进过计算大概13~20ms。 网络延迟计算\r如何判断update更新库存成功？\n有两个条件：\nupdate自身没报错； 客户端确认update影响记录数 优化思路：\n把客户端逻辑放到MySQL服务端，避免网络延迟和GC影响 如何把客户端逻辑放到MySQL服务端\n有两种方案：\n定制SQL方案，在每次update后都会自动提交，但需要修改MySQL源码，成本很高，不是大公司（BAT等）一般不会使用这种方法。 使用存储过程：整个事务在MySQL端完成，用存储过程写业务逻辑，服务端负责调用。 接下来先分析第一种方案\n秒杀方案1\r秒杀方案1成本分析\r根据上图的成本分析，我们的秒杀系统采用第二种方案，即使用存储过程。\n优化总结\n前端控制 暴露接口，按钮防重复（点击一次按钮后就变成灰色，禁止重复点击按钮）\n动静态数据分离 CDN缓存，后端缓存\n事务竞争优化 减少事务行级锁的持有时间\n2. Redis后端缓存优化编码 关于CDN的说明\n由于不同公司提供的CDN的接口暴露不同，不同的公司租用的机房调用的API也不相同，所以慕课网的视频中并没有对CDN的使用过程进行讲解。\n2.1 下载安装Redis 前往官网下载安装Stable版本的Redis，安装后可以将安装目录添加到系统变量Path里以方便使用，我使用的是Windows系统的Redis，懒得去官网下载的可以点这里下载。\n安装后，运行redis-server.exe启动服务器成功，接着运行redis-cli.exe启动客户端连接服务器成功，说明Redis已经安装成功了。\n为什么使用Redis\nRedis属于NoSQL，即非关系型数据库，它是key-value型数据库，是直接在内存中进行存取数据的，所以有着很高的性能。\n利用Redis可以减轻MySQL服务器的压力，减少了跟数据库服务器的通信次数。秒杀的瓶颈就在于跟数据库服务器的通信速度（MySQL本身的主键查询非常快）\n2.2 在pom.xml中配置Redis客户端 1 2 3 4 5 6 \u0026lt;!--添加Redis依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;redis.clients\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jedis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Jedis\nRedis有很多客户端，我们的项目是用Java语言写的，自然选择对应Java语言的客户端，而官网最推荐我们的Java客户端是Jedis，在pom.xml里配置了Jedis依赖就可以使用它了，记得要先开启Redis的服务器，Jedis才能连接到服务器。\n由于Jedis并没有实现内部序列化操作，而Java内置的序列化机制性能又不高，我们是一个秒杀系统，需要考虑高并发优化，在这里我们采用开源社区提供的更高性能的自定义序列化工具protostuff。\n2.3 在pom.xml中配置protostuff依赖 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;!--prostuff序列化依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.dyuproject.protostuff\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;protostuff-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.dyuproject.protostuff\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;protostuff-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 关于序列化和反序列化\n序列化是处理对象流的机制，就是将对象的内容进行流化，可以对流化后的对象进行读写操作，也可以将流化后的对象在网络间传输。反序列化就是将流化后的对象重新转化成原来的对象。\n在Java中内置了序列化机制，通过implements Serializable来标识一个对象实现了序列化接口，不过其性能并不高。\n2.4 使用Redis优化地址暴露接口 原本查询秒杀商品时是通过主键直接去数据库查询的，选择将数据缓存在Redis，在查询秒杀商品时先去Redis缓存中查询，以此降低数据库的压力。如果在缓存中查询不到数据再去数据库中查询，再将查询到的数据放入Redis缓存中，这样下次就可以直接去缓存中直接查询到。\n以上属于数据访问层的逻辑（DAO层），所以我们需要在dao包下新建一个cache目录，在该目录下新建RedisDao.java，用来存取缓存。\nRedisDao\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 public class RedisDao { private final JedisPool jedisPool; public RedisDao(String ip, int port) { jedisPool = new JedisPool(ip, port); } private RuntimeSchema\u0026lt;Seckill\u0026gt; schema = RuntimeSchema.createFrom(Seckill.class); public Seckill getSeckill(long seckillId) { // redis操作逻辑 try { Jedis jedis = jedisPool.getResource(); try { String key = \u0026#34;seckill:\u0026#34; + seckillId; // 并没有实现哪部序列化操作 // 采用自定义序列化 // protostuff: pojo. byte[] bytes = jedis.get(key.getBytes()); // 缓存重获取到 if (bytes != null) { Seckill seckill = schema.newMessage(); ProtostuffIOUtil.mergeFrom(bytes, seckill, schema); // seckill被反序列化 return seckill; } } finally { jedis.close(); } } catch (Exception e) { } return null; } public String putSeckill(Seckill seckill) { try { Jedis jedis = jedisPool.getResource(); try { String key = \u0026#34;seckill:\u0026#34; + seckill.getSeckillId(); byte[] bytes = ProtostuffIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE)); // 超时缓存 int timeout = 60 * 60;// 1小时 String result = jedis.setex(key.getBytes(), timeout, bytes); return result; } finally { jedis.close(); } } catch (Exception e) { } return null; } } 注意\n使用protostuff序列化工具时，被序列化的对象必须是pojo对象（具备setter/getter）\n在spring-dao.xml中手动注入RedisDao\n由于RedisDao和MyBatis的DAO没有关系，MyBatis不会帮我们自动实现该接口，所以我们需要在spring-dao.xml中手动注入RedisDao。由于我们在RedisDao是通过构造方法来注入ip和port两个参数的，所以需要配置，如果不配置这个标签，我们需要为ip和port提供各自的setter和getter（注入时可以没有getter）。\n在这里我们直接把value的值写死在标签里边了，实际开发中需要把ip和port参数的值写到配置文件里，通过读取配置文件的方式读取它们的值。\n1 2 3 4 5 \u0026lt;!--redisDao --\u0026gt; \u0026lt;bean id=\u0026#34;redisDao\u0026#34; class=\u0026#34;com.lewis.dao.cache.RedisDao\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;localhost\u0026#34; /\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; value=\u0026#34;6379\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; 修改SeckillServiceImpl\n使用注解注入RedisDao属性\n1 2 @Autowired private RedisDao redisDao; 修改exportSeckillURI()\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public Exposer exportSeckillUrl(long seckillId) { // 优化点:缓存优化:超时的基础上维护一致性 // 1.访问redis Seckill seckill = redisDao.getSeckill(seckillId); if (seckill == null) { // 2.访问数据库 seckill = seckillDao.queryById(seckillId); if (seckill == null) {// 说明查不到这个秒杀产品的记录 return new Exposer(false, seckillId); } else { // 3.放入redis redisDao.putSeckill(seckill); } } // 若是秒杀未开启 Date startTime = seckill.getStartTime(); Date endTime = seckill.getEndTime(); // 系统当前时间 Date nowTime = new Date(); if (startTime.getTime() \u0026gt; nowTime.getTime() || endTime.getTime() \u0026lt; nowTime.getTime()) { return new Exposer(false, seckillId, nowTime.getTime(), startTime.getTime(), endTime.getTime()); } // 秒杀开启，返回秒杀商品的id、用给接口加密的md5 String md5 = getMD5(seckillId); return new Exposer(true, md5, seckillId); } 2.5 测试类RedisDaoTest 通过IDE工具快速生成测试类RedisDaoTest，新写一个testSeckill()，对getSeckill和putSeckill方法进行全局测试。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @RunWith(SpringJUnit4ClassRunner.class) // 告诉junit spring的配置文件 @ContextConfiguration({ \u0026#34;classpath:spring/spring-dao.xml\u0026#34; }) public class RedisDaoTest { private final Logger logger = LoggerFactory.getLogger(this.getClass()); private long id = 1001; @Autowired private RedisDao redisDao; @Autowired private SeckillDao seckillDao; @Test public void testSeckill() { Seckill seckill = redisDao.getSeckill(id); if (seckill == null) { seckill = seckillDao.queryById(id); if (seckill != null) { String result = redisDao.putSeckill(seckill); logger.info(\u0026#34;result={}\u0026#34;, result); seckill = redisDao.getSeckill(id); logger.info(\u0026#34;seckill={}\u0026#34;, seckill); } } } } 如果测试通过了，会输出result={}OK以及id为1001的商品信息，如果输出的都是null，那说明你没有开启Redis服务器，所以在内存中没有存取到缓存。\n为什么不用Redis的hash来存储对象？\n第一：通过Jedis储存对象的方式有大概三种\n本项目采用的方式：将对象序列化成byte字节，最终存byte字节； 对象转hashmap，也就是你想表达的hash的形式，最终存map； 对象转json，最终存json，其实也就是字符串 第二：其实如果你是平常的项目，并发不高，三个选择都可以，这种情况下以hash的形式更加灵活，可以对象的单个属性，但是问题来了，在秒杀的场景下，三者的效率差别很大。\n第三：结果如下\n10w数据 时间 内存占用 存json 10s 14M 存byte 6s 6M 存jsonMap 10s 20M 存byteMap 4s 4M 取json 7s 取byte 4s 取jsonmap 7s 取bytemap 4s 第四：你该说了，bytemap最快啊，为啥不用啊，因为项目用了超级强悍的序列化工具啊，以上测试是基于java的序列化，如果改了序列化工具，你可以测试下。\n以上问答源自慕课网的一道问答\n教学视频中张老师对于Redis暴露接口地址的补充\nredis事务与RDBMS事务有本质区别，详情见http://redis.io/topics/transactions 关于spring整合redis。原生Jedis API已经足够清晰。笔者所在的团队不使用任何spring-data整合API，而是直接对接原生Client并做二次开发调优，如Jedis,Hbase等。 这里使用redis缓存方法用于暴露秒杀地址场景，该方法存在瞬时压力，为了降低DB的primary key QPS，且没有使用库存字段所以不做一致性维护。 跨数据源的严格一致性需要2PC支持，性能不尽如人意。线上产品一般使用最终一致性去解决，这块相关知识较多，所以没有讲。 本课程的重点其实不是SSM，只是一个快速开发的方式。重点根据业务场景分析通信成本，瓶颈点的过程和优化思路。 初学者不要纠结于事务。事务可以降低一致性维护难度，但扩展性灵活性存在不足。技术是死的，人是活的。比如京东抢购使用Redis+LUA+MQ方案，就是一种技术反思。 3. 秒杀操作——并发优化 3.1 简单优化 回顾事务执行\n回顾事务执行\rsql语句的简单优化\n简单优化\r优化SeckillServiceImpl的executeSeckill()\n用户的秒杀操作分为两步：减库存、插入购买明细，我们在这里进行简单的优化，就是将原本先update（减库存）再进行insert（插入购买明细）的步骤改成：先insert再update。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException { if (md5 == null || !md5.equals(getMD5(seckillId))) { throw new SeckillException(\u0026#34;seckill data rewrite\u0026#34;);// 秒杀数据被重写了 } // 执行秒杀逻辑:减库存+增加购买明细 Date nowTime = new Date(); try { // 否则更新了库存，秒杀成功,增加明细 int insertCount = successKilledDao.insertSuccessKilled(seckillId, userPhone); // 看是否该明细被重复插入，即用户是否重复秒杀 if (insertCount \u0026lt;= 0) { throw new RepeatKillException(\u0026#34;seckill repeated\u0026#34;); } else { // 减库存,热点商品竞争 int updateCount = seckillDao.reduceNumber(seckillId, nowTime); if (updateCount \u0026lt;= 0) { // 没有更新库存记录，说明秒杀结束 rollback throw new SeckillCloseException(\u0026#34;seckill is closed\u0026#34;); } else { // 秒杀成功,得到成功插入的明细记录,并返回成功秒杀的信息 commit SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS, successKilled); } } } catch (SeckillCloseException e1) { throw e1; } catch (RepeatKillException e2) { throw e2; } catch (Exception e) { logger.error(e.getMessage(), e); // 将编译期异常转化为运行期异常 throw new SeckillException(\u0026#34;seckill inner error :\u0026#34; + e.getMessage()); } } 为什么要先insert再update\n首先是在更新操作的时候给行加锁，插入并不会加锁，如果更新操作在前，那么就需要执行完更新和插入以后事务提交或回滚才释放锁。而如果插入在前，更新在后，那么只有在更新时才会加行锁，之后在更新完以后事务提交或回滚释放锁。\n在这里，插入是可以并行的，而更新由于会加行级锁是串行的。\n也就是说是更新在前加锁和释放锁之间两次的网络延迟和GC，如果插入在前则加锁和释放锁之间只有一次的网络延迟和GC，也就是减少的持有锁的时间。\n这里先insert并不是忽略了库存不足的情况，而是因为insert和update是在同一个事务里，光是insert并不一定会提交，只有在update成功才会提交，所以并不会造成过量插入秒杀成功记录。\n3.2 深度优化 前边通过调整insert和update的执行顺序来实现简单优化，但依然存在着Java客户端和服务器通信时的网络延迟和GC影响，我们可以将执行秒杀操作时的insert和update放到MySQL服务端的存储过程里，而Java客户端直接调用这个存储过程，这样就可以避免网络延迟和可能发生的GC影响。另外，由于我们使用了存储过程，也就使用不到Spring的事务管理了，因为在存储过程里我们会直接启用一个事务。\n3.2.1 写一个存储过程procedure，然后在MySQL控制台里执行它 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 -- 秒杀执行储存过程 DELIMITER $$ -- 将定界符从;转换为$$ -- 定义储存过程 -- 参数： in输入参数 out输出参数 -- row_count() 返回上一条修改类型sql(delete,insert,update)的影响行数 -- row_count:0:未修改数据 ; \u0026gt;0:表示修改的行数； \u0026lt;0:sql错误 CREATE PROCEDURE `seckill`.`execute_seckill` (IN v_seckill_id BIGINT, IN v_phone BIGINT, IN v_kill_time TIMESTAMP, OUT r_result INT) BEGIN DECLARE insert_count INT DEFAULT 0; START TRANSACTION; INSERT IGNORE INTO success_killed (seckill_id, user_phone, state) VALUES (v_seckill_id, v_phone, 0); SELECT row_count() INTO insert_count; IF (insert_count = 0) THEN ROLLBACK; SET r_result = -1; ELSEIF (insert_count \u0026lt; 0) THEN ROLLBACK; SET r_result = -2; ELSE UPDATE seckill SET number = number - 1 WHERE seckill_id = v_seckill_id AND end_time \u0026gt; v_kill_time AND start_time \u0026lt; v_kill_time AND number \u0026gt; 0; SELECT row_count() INTO insert_count; IF (insert_count = 0) THEN ROLLBACK; SET r_result = 0; ELSEIF (insert_count \u0026lt; 0) THEN ROLLBACK; SET r_result = -2; ELSE COMMIT; SET r_result = 1; END IF; END IF; END; $$ -- 储存过程定义结束 -- 将定界符重新改为; DELIMITER ; -- 定义一个用户变量r_result SET @r_result = -3; -- 执行储存过程 CALL execute_seckill(1003, 13502178891, now(), @r_result); -- 获取结果 SELECT @r_result; 注意点\n1 CREATE PROCEDURE `seckill`.`execute_seckill` 上边这句语句的意思是为一个名为seckill的数据库定义一个名为execute_seckill的存储过程，如果你在连接数据库后使用了这个数据库（即use seckill;），那么这里的定义句子就不能这样写了，会报错（因为存储过程是依赖于数据库的），改成下边这样：\n1 CREATE PROCEDURE `execute_seckill` row_count()\n存储过程中，row_count()函数用来返回上一条sql（delete,insert,update）影响的行数。\n根据row_count()返回值，可以进行接下来的流程判断：\n0：未修改数据；\n\u0026gt;0: 表示修改的行数；\n\u0026lt;0: 表示SQL错误或未执行修改SQL\n3.2.2 修改源码以调用存储过程 在SeckillDao里添加调用存储过程的方法声明\n1 2 3 4 5 /** * 使用储存过程执行秒杀 * @param paramMap */ void killByProcedure(Map\u0026lt;String,Object\u0026gt; paramMap); 接着在SeckillDao.xml里添加该方法对应的sql语句\n1 2 3 4 5 6 7 8 9 \u0026lt;!--调用储存过程 --\u0026gt; \u0026lt;select id=\u0026#34;killByProcedure\u0026#34; statementType=\u0026#34;CALLABLE\u0026#34;\u0026gt; CALL execute_seckill( #{seckillId,jdbcType=BIGINT,mode=IN}, #{phone,jdbcType=BIGINT,mode=IN}, #{killTime,jdbcType=TIMESTAMP,mode=IN}, #{result,jdbcType=INTEGER,mode=OUT} ) \u0026lt;/select\u0026gt; 在SeckillService接口里添加一个方法声明\n1 2 3 4 5 6 7 8 9 /** * 调用存储过程来执行秒杀操作，不需要抛出异常 * * @param seckillId 秒杀的商品ID * @param userPhone 手机号码 * @param md5 md5加密值 * @return 根据不同的结果返回不同的实体信息 */ SeckillExecution executeSeckillProcedure(long seckillId,long userPhone,String md5); 为什么这个方法不需要抛出异常？\n原本没有调用存储过程的执行秒杀操作之所以要抛出RuntimException，是为了让Spring事务管理器能够在秒杀不成功的时候进行回滚操作。而现在我们使用了存储过程，有关事务的提交或回滚已经在procedure里完成了，前面也解释了不需要再使用到Spring的事务了，既然如此，我们也就不需要在这个方法里抛出异常来让Spring帮我们回滚了。\n在SeckillServiceImpl里实现这个方法\n我们需要使用到第三方工具类，所以在pom.xml里导入commons-collections工具类\n1 2 3 4 5 6 \u0026lt;!--导入apache工具类--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-collections\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-collections\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.2.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 在接口的实现类里对executeSeckillProcedure进行实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 @Override public SeckillExecution executeSeckillProcedure(long seckillId, long userPhone, String md5) { if (md5 == null || !md5.equals(getMD5(seckillId))) { return new SeckillExecution(seckillId, SeckillStatEnum.DATE_REWRITE); } Date killTime = new Date(); Map\u0026lt;String, Object\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(\u0026#34;seckillId\u0026#34;, seckillId); map.put(\u0026#34;phone\u0026#34;, userPhone); map.put(\u0026#34;killTime\u0026#34;, killTime); map.put(\u0026#34;result\u0026#34;, null); // 执行储存过程,result被复制 seckillDao.killByProcedure(map); // 获取result int result = MapUtils.getInteger(map, \u0026#34;result\u0026#34;, -2); if (result == 1) { SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS, successKilled); } else { return new SeckillExecution(seckillId, SeckillStatEnum.stateOf(result)); } } 接着对该方法进行测试，在原本的SeckillServiceTest测试类里添加测试方法\n1 2 3 4 5 6 7 8 9 10 11 @Test public void executeSeckillProcedure(){ long seckillId = 1001; long phone = 13680115101L; Exposer exposer = seckillService.exportSeckillUrl(seckillId); if (exposer.isExposed()) { String md5 = exposer.getMd5(); SeckillExecution execution = seckillService.executeSeckillProcedure(seckillId, phone, md5); logger.info(\u0026#34;execution={}\u0026#34;, execution); } } 经过测试，发现没有问题，测试通过。然后我们需要把Controller里的执行秒杀操作改成调用存储过程的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @RequestMapping(value = \u0026#34;/{seckillId}/{md5}/execution\u0026#34;, method = RequestMethod.POST, produces = {\u0026#34;application/json;charset=UTF-8\u0026#34;}) @ResponseBody public SeckillResult\u0026lt;SeckillExecution\u0026gt; execute(@PathVariable(\u0026#34;seckillId\u0026#34;) Long seckillId, @PathVariable(\u0026#34;md5\u0026#34;) String md5, @CookieValue(value = \u0026#34;userPhone\u0026#34;,required = false) Long userPhone) { if (userPhone==null) { return new SeckillResult\u0026lt;SeckillExecution\u0026gt;(false,\u0026#34;未注册\u0026#34;); } try { //这里改为调用存储过程 // SeckillExecution execution = seckillService.executeSeckill(seckillId, userPhone, md5); SeckillExecution execution = seckillService.executeSeckillProcedure(seckillId, userPhone, md5); return new SeckillResult\u0026lt;SeckillExecution\u0026gt;(true, execution); }catch (RepeatKillException e1) { SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.REPEAT_KILL); return new SeckillResult\u0026lt;SeckillExecution\u0026gt;(true,execution); }catch (SeckillCloseException e2) { SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.END); return new SeckillResult\u0026lt;SeckillExecution\u0026gt;(true,execution); } catch (Exception e) { SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.INNER_ERROR); return new SeckillResult\u0026lt;SeckillExecution\u0026gt;(true,execution); } } 存储过程优化总结\n存储过程优化:事务行级锁持有的时间 不要过度依赖存储过程 简单的逻辑依赖存储过程 QPS:一个秒杀单6000/qps 经过简单优化和深度优化之后，本项目大概能达到一个秒杀单6000qps（慕课网视频中张老师说的），这个数据对于一个秒杀商品来说其实已经挺ok了，注意这里是指同一个秒杀商品6000qps，如果是不同商品不存在行级锁竞争的问题。\n3.3 系统部署架构 系统可能用到的服务\rCDN：放置一些静态化资源，或者可以将动态数据分离。一些js依赖直接用公网的CDN，自己开发的一些页面也做静态化处理推送到CDN。用户在CDN获取到的数据不需要再访问我们的服务器，动静态分离可以降低服务器请求量。比如秒杀详情页，做成HTML放在cdn上，动态数据可以通过ajax请求后台获取。\nNginx：作为http服务器，响应客户请求，为后端的servlet容器做反向代理，以达到负载均衡的效果。\nRedis：用来做服务器端的缓存，通过Jedis提供的API来达到热点数据的一个快速存取的过程，减少数据库的请求量。\nMySQL：保证秒杀过程的数据一致性与完整性。\n智能DNS解析+智能CDN加速+Nginx并发+Redis缓存+MySQL分库分表\n大型系统部署架构\r大型系统部署架构，逻辑集群就是开发的部分。\nNginx做负载均衡 分库分表：在秒杀系统中，一般通过关键的秒杀商品id取模进行分库分表，以512为一张表，1024为一张表。分库分表一般采用开源架构，如阿里巴巴的tddl分库分表框架。 统计分析：一般使用hadoop等架构进行分析 在这样一个架构中，可能参与的角色如下：\n项目角色\r本节结语\n至此，关于该SSM实战项目——Java高并发秒杀API已经全部完成，感谢观看本文。\n项目笔记相关链接\nJava高并发秒杀API(一)之业务分析与DAO层 Java高并发秒杀API(二)之Service层 Java高并发秒杀API(三)之Web层 Java高并发秒杀API(四)之高并发优化 项目源码\n源码下载 GitHub地址 项目视频教程链接\n这是慕课网上的一个免费项目教学视频，名为Java高并发秒杀API，一共有如下四节课程，附带视频传送门（在视频中老师是用IDEA，本文用的是Eclipse）\nJava高并发秒杀API之业务分析与DAO层 Java高并发秒杀API之Service层 Java高并发秒杀API之Web层 Java高并发秒杀API之高并发优化 ","permalink":"https://lewky.cn/posts/43941.html/","tags":["项目笔记","SSM实战项目","秒杀"],"title":"Java高并发秒杀API(四)之高并发优化"},{"categories":["seckill"],"contents":"1. 设计前的分析 Web层内容相关\n前端交互设计 Restful规范 SpringMVC Bootstrap + jQuery 前端页面流程\n前端页面流程\r详情页流程逻辑\n详情页流程逻辑\r为什么要获取标准系统时间（服务器的时间）\n用户可能处在不同时区，用户的电脑的系统时间可能不同。\nRestful规范\nRestful规范是一种优雅的URI表达方式：/模块/资源/{标识}/集合1/···\nGET -\u0026gt; 查询操作\nPOST -\u0026gt; 添加/修改操作（用于非幂等操作）\nPUT -\u0026gt; 修改操作（用于幂等操作）\nDELETE -\u0026gt; 删除操作\n怎么实现Restful接口\n@RequestMapping(value = \u0026ldquo;/path\u0026rdquo;,method = RequestMethod.GET) @RequestMapping(value = \u0026ldquo;/path\u0026rdquo;,method = RequestMethod.POST) @RequestMapping(value = \u0026ldquo;/path\u0026rdquo;,method = RequestMethod.PUT) @RequestMapping(value = \u0026ldquo;/path\u0026rdquo;,method = RequestMethod.DELETE) 非幂等操作和幂等操作\n幂等性（idempotency）意味着对同一URL的多个请求应该返回同样的结果。在Restful规范中，GET、PUT、DELETE是幂等操作，只有POST是非幂等操作。\nPOST和PUT都可以用来创建和更新资源，二者的区别就是前者用于非幂等操作，后者用于幂等操作。\n简单来说，使用POST方法请求创建一个资源，如果将这条请求重复发送N次，就会创建出N个资源；而如果用GET方法请求创建一个资源，就算重复发送该请求N次，也只会创建一个资源（就算第一次请求创建出来的资源）。\n附：《幂等和高并发在电商系统中的使用》\n秒杀API的URL设计\n秒杀API的URL设计\r@RequestMapping的映射技巧\n注解映射技巧\r请求方法细节处理\n请求参数绑定 请求方法限制 请求转发和重定向 数据模型赋值 返回json数据 Cookie访问 2. 整合配置SpringMVC框架 2.1 配置web.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 \u0026lt;web-app xmlns=\u0026#34;http://java.sun.com/xml/ns/javaee\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\u0026#34; version=\u0026#34;3.0\u0026#34; metadata-complete=\u0026#34;true\u0026#34;\u0026gt; \u0026lt;!--用maven创建的web-app需要修改servlet的版本为3.0 --\u0026gt; \u0026lt;!--配置DispatcherServlet --\u0026gt; \u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;seckill-dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt;org.springframework.web.servlet.DispatcherServlet\u0026lt;/servlet-class\u0026gt; \u0026lt;!-- 配置SpringMVC 需要配置的文件 spring-dao.xml，spring-service.xml,spring-web.xml MyBatis -\u0026gt; Spring -\u0026gt; SpringMVC --\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;classpath:spring/spring-*.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;/servlet\u0026gt; \u0026lt;servlet-mapping\u0026gt; \u0026lt;servlet-name\u0026gt;seckill-dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;!--默认匹配所有请求 --\u0026gt; \u0026lt;url-pattern\u0026gt;/\u0026lt;/url-pattern\u0026gt; \u0026lt;/servlet-mapping\u0026gt; \u0026lt;/web-app\u0026gt; 注意\n这里的Servlet版本是3.0，对应Tomcat7.0版本 由于我们的配置文件都是以spring-开头命名的，所以可以用通配符*一次性全部加载 url-pattern设置为/，这是使用了Restful的规范；在使用Struts框架时我们配置的是*.do之类的，这是一种比较丑陋的表达方式 2.2 在src/main/resources/spring包下建立spring-web.xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:mvc=\u0026#34;http://www.springframework.org/schema/mvc\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\u0026#34;\u0026gt; \u0026lt;!--配置spring mvc--\u0026gt; \u0026lt;!--1,开启springmvc注解模式 a.自动注册DefaultAnnotationHandlerMapping,AnnotationMethodHandlerAdapter b.默认提供一系列的功能:数据绑定，数字和日期的format@NumberFormat,@DateTimeFormat c:xml,json的默认读写支持--\u0026gt; \u0026lt;mvc:annotation-driven/\u0026gt; \u0026lt;!--2.静态资源默认servlet配置--\u0026gt; \u0026lt;!-- 1).加入对静态资源处理：js,gif,png 2).允许使用 \u0026#34;/\u0026#34; 做整体映射 --\u0026gt; \u0026lt;mvc:default-servlet-handler/\u0026gt; \u0026lt;!--3：配置JSP 显示ViewResolver--\u0026gt; \u0026lt;bean class=\u0026#34;org.springframework.web.servlet.view.InternalResourceViewResolver\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;viewClass\u0026#34; value=\u0026#34;org.springframework.web.servlet.view.JstlView\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;prefix\u0026#34; value=\u0026#34;/WEB-INF/jsp/\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;suffix\u0026#34; value=\u0026#34;.jsp\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--4:扫描web相关的controller--\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.lewis.web\u0026#34;/\u0026gt; \u0026lt;/beans\u0026gt; 3. Controller设计 Controller中的每一个方法都对应我们系统中的一个资源URL，其设计应该遵循Restful接口的设计风格。\n3.1 在java包下新建com.lewis.web包，在该包下新建SeckillController.java 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 @Controller @RequestMapping(\u0026#34;/seckill\u0026#34;)//url:模块/资源/{}/细分 public class SeckillController { @Autowired private SeckillService seckillService; @RequestMapping(value = \u0026#34;/list\u0026#34;,method = RequestMethod.GET) public String list(Model model) { //list.jsp+mode=ModelAndView //获取列表页 List\u0026lt;Seckill\u0026gt; list=seckillService.getSeckillList(); model.addAttribute(\u0026#34;list\u0026#34;,list); return \u0026#34;list\u0026#34;; } @RequestMapping(value = \u0026#34;/{seckillId}/detail\u0026#34;,method = RequestMethod.GET) public String detail(@PathVariable(\u0026#34;seckillId\u0026#34;) Long seckillId, Model model) { if (seckillId == null) { return \u0026#34;redirect:/seckill/list\u0026#34;; } Seckill seckill=seckillService.getById(seckillId); if (seckill==null) { return \u0026#34;forward:/seckill/list\u0026#34;; } model.addAttribute(\u0026#34;seckill\u0026#34;,seckill); return \u0026#34;detail\u0026#34;; } //ajax ,json暴露秒杀接口的方法 @RequestMapping(value = \u0026#34;/{seckillId}/exposer\u0026#34;, method = RequestMethod.GET, produces = {\u0026#34;application/json;charset=UTF-8\u0026#34;}) @ResponseBody public SeckillResult\u0026lt;Exposer\u0026gt; exposer(@PathVariable(\u0026#34;seckillId\u0026#34;) Long seckillId) { SeckillResult\u0026lt;Exposer\u0026gt; result; try{ Exposer exposer=seckillService.exportSeckillUrl(seckillId); result=new SeckillResult\u0026lt;Exposer\u0026gt;(true,exposer); }catch (Exception e) { e.printStackTrace(); result=new SeckillResult\u0026lt;Exposer\u0026gt;(false,e.getMessage()); } return result; } @RequestMapping(value = \u0026#34;/{seckillId}/{md5}/execution\u0026#34;, method = RequestMethod.POST, produces = {\u0026#34;application/json;charset=UTF-8\u0026#34;}) @ResponseBody public SeckillResult\u0026lt;SeckillExecution\u0026gt; execute(@PathVariable(\u0026#34;seckillId\u0026#34;) Long seckillId, @PathVariable(\u0026#34;md5\u0026#34;) String md5, @CookieValue(value = \u0026#34;userPhone\u0026#34;,required = false) Long userPhone) { if (userPhone==null) { return new SeckillResult\u0026lt;SeckillExecution\u0026gt;(false,\u0026#34;未注册\u0026#34;); } try { SeckillExecution execution = seckillService.executeSeckill(seckillId, userPhone, md5); return new SeckillResult\u0026lt;SeckillExecution\u0026gt;(true, execution); }catch (RepeatKillException e1) { SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.REPEAT_KILL); return new SeckillResult\u0026lt;SeckillExecution\u0026gt;(true,execution); }catch (SeckillCloseException e2) { SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.END); return new SeckillResult\u0026lt;SeckillExecution\u0026gt;(true,execution); } catch (Exception e) { SeckillExecution execution=new SeckillExecution(seckillId, SeckillStatEnum.INNER_ERROR); return new SeckillResult\u0026lt;SeckillExecution\u0026gt;(true,execution); } } //获取系统时间 @RequestMapping(value = \u0026#34;/time/now\u0026#34;,method = RequestMethod.GET) @ResponseBody public SeckillResult\u0026lt;Long\u0026gt; time() { Date now=new Date(); return new SeckillResult\u0026lt;Long\u0026gt;(true,now.getTime()); } } 注意\nSpringMVC在处理Cookie时有个小问题：如果找不到对应的Cookie会报错，所以设置为required=false，将Cookie是否存在的逻辑判断放到代码中来判断。\n关于异常的捕捉\nService层中的抛出异常是为了让Spring能够回滚，Controller层中捕获异常是为了将异常转换为对应的Json供前台使用，缺一不可。\n3.2 在dto包下新建一个SeckillResult 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 //将所有的ajax请求返回类型，全部封装成json数据 public class SeckillResult\u0026lt;T\u0026gt; { //请求是否成功 private boolean success; private T data; private String error; public SeckillResult(boolean success, T data) { this.success = success; this.data = data; } public SeckillResult(boolean success, String error) { this.success = success; this.error = error; } public boolean isSuccess() { return success; } public void setSuccess(boolean success) { this.success = success; } public T getData() { return data; } public void setData(T data) { this.data = data; } public String getError() { return error; } public void setError(String error) { this.error = error; } } 注意\nSeckillResult是一个VO类(View Object)，属于DTO层，用来封装json结果，方便页面取值；在这里，将其设计成泛型，就可以和灵活地往里边封装各种类型的对象。\n这里的success属性不是指秒杀执行的结果，而是指页面是否发送请求成功，至于秒杀之后是否成功的这个结果则是封装到了data属性里。\n4. 基于Bootstrap开发页面 由于项目的前端页面都是由Bootstrap开发的,所以需要先去下载Bootstrap或者是使用在线的CDN服务。而Bootstrap又是依赖于jQuery的，所以需要先引入jQuery。\n4.1 在webapp下建立resources目录，接着建立script目录，建立seckill.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 //存放主要交互逻辑的js代码 // javascript 模块化(package.类.方法) var seckill = { //封装秒杀相关ajax的url URL: { now: function () { return \u0026#39;/seckill/seckill/time/now\u0026#39;; }, exposer: function (seckillId) { return \u0026#39;/seckill/seckill/\u0026#39; + seckillId + \u0026#39;/exposer\u0026#39;; }, execution: function (seckillId, md5) { return \u0026#39;/seckill/seckill/\u0026#39; + seckillId + \u0026#39;/\u0026#39; + md5 + \u0026#39;/execution\u0026#39;; } }, //验证手机号 validatePhone: function (phone) { if (phone \u0026amp;\u0026amp; phone.length == 11 \u0026amp;\u0026amp; !isNaN(phone)) { return true;//直接判断对象会看对象是否为空,空就是undefine就是false; isNaN 非数字返回true } else { return false; } }, //详情页秒杀逻辑 detail: { //详情页初始化 init: function (params) { //手机验证和登录,计时交互 //规划我们的交互流程 //在cookie中查找手机号 var userPhone = $.cookie(\u0026#39;userPhone\u0026#39;); //验证手机号 if (!seckill.validatePhone(userPhone)) { //绑定手机 控制输出 var killPhoneModal = $(\u0026#39;#killPhoneModal\u0026#39;); killPhoneModal.modal({ show: true,//显示弹出层 backdrop: \u0026#39;static\u0026#39;,//禁止位置关闭 keyboard: false//关闭键盘事件 }); $(\u0026#39;#killPhoneBtn\u0026#39;).click(function () { var inputPhone = $(\u0026#39;#killPhoneKey\u0026#39;).val(); console.log(\u0026#34;inputPhone: \u0026#34; + inputPhone); if (seckill.validatePhone(inputPhone)) { //电话写入cookie(7天过期) $.cookie(\u0026#39;userPhone\u0026#39;, inputPhone, {expires: 7, path: \u0026#39;/seckill\u0026#39;}); //验证通过　刷新页面 window.location.reload(); } else { //todo 错误文案信息抽取到前端字典里 $(\u0026#39;#killPhoneMessage\u0026#39;).hide().html(\u0026#39;\u0026lt;label class=\u0026#34;label label-danger\u0026#34;\u0026gt;手机号错误!\u0026lt;/label\u0026gt;\u0026#39;).show(300); } }); } //已经登录 //计时交互 var startTime = params[\u0026#39;startTime\u0026#39;]; var endTime = params[\u0026#39;endTime\u0026#39;]; var seckillId = params[\u0026#39;seckillId\u0026#39;]; $.get(seckill.URL.now(), {}, function (result) { if (result \u0026amp;\u0026amp; result[\u0026#39;success\u0026#39;]) { var nowTime = result[\u0026#39;data\u0026#39;]; //时间判断 计时交互 seckill.countDown(seckillId, nowTime, startTime, endTime); } else { console.log(\u0026#39;result: \u0026#39; + result); alert(\u0026#39;result: \u0026#39; + result); } }); } }, handlerSeckill: function (seckillId, node) { //获取秒杀地址,控制显示器,执行秒杀 node.hide().html(\u0026#39;\u0026lt;button class=\u0026#34;btn btn-primary btn-lg\u0026#34; id=\u0026#34;killBtn\u0026#34;\u0026gt;开始秒杀\u0026lt;/button\u0026gt;\u0026#39;); $.get(seckill.URL.exposer(seckillId), {}, function (result) { //在回调函数种执行交互流程 if (result \u0026amp;\u0026amp; result[\u0026#39;success\u0026#39;]) { var exposer = result[\u0026#39;data\u0026#39;]; if (exposer[\u0026#39;exposed\u0026#39;]) { //开启秒杀 //获取秒杀地址 var md5 = exposer[\u0026#39;md5\u0026#39;]; var killUrl = seckill.URL.execution(seckillId, md5); console.log(\u0026#34;killUrl: \u0026#34; + killUrl); //绑定一次点击事件 $(\u0026#39;#killBtn\u0026#39;).one(\u0026#39;click\u0026#39;, function () { //执行秒杀请求 //1.先禁用按钮 $(this).addClass(\u0026#39;disabled\u0026#39;);//,\u0026lt;-$(this)===(\u0026#39;#killBtn\u0026#39;)-\u0026gt; //2.发送秒杀请求执行秒杀 $.post(killUrl, {}, function (result) { if (result \u0026amp;\u0026amp; result[\u0026#39;success\u0026#39;]) { var killResult = result[\u0026#39;data\u0026#39;]; var state = killResult[\u0026#39;state\u0026#39;]; var stateInfo = killResult[\u0026#39;stateInfo\u0026#39;]; //显示秒杀结果 node.html(\u0026#39;\u0026lt;span class=\u0026#34;label label-success\u0026#34;\u0026gt;\u0026#39; + stateInfo + \u0026#39;\u0026lt;/span\u0026gt;\u0026#39;); } }); }); node.show(); } else { //未开启秒杀(浏览器计时偏差) var now = exposer[\u0026#39;now\u0026#39;]; var start = exposer[\u0026#39;start\u0026#39;]; var end = exposer[\u0026#39;end\u0026#39;]; seckill.countDown(seckillId, now, start, end); } } else { console.log(\u0026#39;result: \u0026#39; + result); } }); }, countDown: function (seckillId, nowTime, startTime, endTime) { console.log(seckillId + \u0026#39;_\u0026#39; + nowTime + \u0026#39;_\u0026#39; + startTime + \u0026#39;_\u0026#39; + endTime); var seckillBox = $(\u0026#39;#seckill-box\u0026#39;); if (nowTime \u0026gt; endTime) { //秒杀结束 seckillBox.html(\u0026#39;秒杀结束!\u0026#39;); } else if (nowTime \u0026lt; startTime) { //秒杀未开始,计时事件绑定 var killTime = new Date(startTime + 1000);//todo 防止时间偏移 seckillBox.countdown(killTime, function (event) { //时间格式 var format = event.strftime(\u0026#39;秒杀倒计时: %D天 %H时 %M分 %S秒 \u0026#39;); seckillBox.html(format); }).on(\u0026#39;finish.countdown\u0026#39;, function () { //时间完成后回调事件 //获取秒杀地址,控制现实逻辑,执行秒杀 console.log(\u0026#39;______fininsh.countdown\u0026#39;); seckill.handlerSeckill(seckillId, seckillBox); }); } else { //秒杀开始 seckill.handlerSeckill(seckillId, seckillBox); } } }; 脚本文件的技巧\n使用Json来讲JavaScript模块化（类似于Java的package），不要将js都写成一堆，不易维护，页不方便阅读。\n特殊说明\n由于本人的Eclipse内嵌的Tomcat设置的原因，我需要在URL里的所有路径前加上/seckill（我的项目名）才可以正常映射到Controller里对应的方法，如下\n1 2 3 4 5 6 7 8 9 10 11 12 //封装秒杀相关ajax的url URL: { now: function () { return \u0026#39;/seckill/seckill/time/now\u0026#39;; }, exposer: function (seckillId) { return \u0026#39;/seckill/seckill/\u0026#39; + seckillId + \u0026#39;/exposer\u0026#39;; }, execution: function (seckillId, md5) { return \u0026#39;/seckill/seckill/\u0026#39; + seckillId + \u0026#39;/\u0026#39; + md5 + \u0026#39;/execution\u0026#39;; } }, 如果有同学在后边测试页面时找不到路径，可以将这里的路径里的/seckill删掉\n4.2 编写页面 在WEB-INF目录下新建一个jsp目录，在这里存放我们的jsp页面，为了减少工作量，也为了方便，将每个页面都会使用到的头部文件和标签库分离出来，放到common目录下，在jsp页面中静态包含这两个公共页面就行了。\n关于jsp页面请从源码中拷贝，实际开发中前端页面由前端工程师完成，但是后端工程师也应该了解jQuery和ajax，想要了解本项目的页面是如何实现的请观看慕课网的Java高并发秒杀API之Web层。\n静态包含和动态包含的区别\n静态包含会直接将页面包含进来，最终只生成一个Servlet；而动态包含会先将要包含进来的页面生成Servlet后再包含进来，最终会生成多个Servlet。\n存在的坑\n在页面里不要写成\u0026lt;script/\u0026gt;，这样写会导致后边的js加载不了，所以要写成\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;。\nEL表达式\nstartTime是Date类型的，通过${startTime.time}来将Date转换成long类型的毫秒值。\n4.3 测试页面 先clean下Maven项目，接着编译Maven项目（-X compile命令），然后启动Tomcat，在浏览器输入http://localhost:8080/seckill/seckill/list，成功进入秒杀商品页面；输入http://localhost:8080/seckill/seckill/1000/detail成功进入详情页面。\n配置使用jquery countdown插件\n1.pom.xml\n1 2 3 4 5 6 7 8 9 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.webjars.bower\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jquery.countdown\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 2.页面\n1 \u0026lt;script src=\u0026#34;${pageContext.request.contextPath}/webjars/jquery.countdown/2.1.0/dist/jquery.countdown.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 其他问题\n关于显示NaN天 NaN时 NaN分 NaN秒的问题，原因是new Date(startTime + 1000)，startTime 被解释成一个字符串了。\n解决办法：\nnew Date(startTime-0 + 1000); new Date(Number(startTime) + 1000); 关于分布式环境下的几个问题以及慕课网张老师的回答\n根据系统标准时间判断，如果分布式环境下各机器时间不同步怎么办？同时发起的两次请求，可能一个活动开始，另一个提示没开始。 后端服务器需要做NTP时间同步，如每5分钟与NTP服务同步保证时间误差在微妙级以下。时间同步在业务需要或者活性检查场景很常见(如hbase的RegionServer)\n如果判断逻辑都放到后端，遇到有刷子，后端处理这些请求扛不住了怎么办？可能活动没开始，服务器已经挂掉了。 秒杀开启判断在前端和后端都有，后端的判断比较简单取秒杀单做判断，这块的IO请求是DB主键查询很快，单DB就可以抗住几万QPS,后面也会加入redis缓存为DB减负。\n负载均衡问题，比如根据地域在nginx哈希，怎样能较好的保证各机器秒杀成功的尽量分布均匀呢。 负载均衡包括nginx入口端和后端upstream服务，在入口端一般采用智能DNS解析请求就近进入nginx服务器。后端upstgream不建议采用一致性hash，防止请求不均匀。后端服务无状态可以简单使用轮训机制。nginx负载均衡本身过于简单，可以使用openresty自己实现或者nginx之后单独架设负载均衡服务如Netflix的Zuul等。\n对于流量爆增的造成后端不可用情况，这门课程(Java高并发秒杀API)并没有做动态降级和弹性伸缩架构上的处理，后面受慕课邀请会做一个独立的实战课，讲解分布式架构，弹性容错，微服务相关的内容，到时会加入这方面的内容。\n本节结语\n至此，关于Java高并发秒杀API的Web层的开发与测试已经完成，接下来进行对该秒杀系统进行高并发优化，详情可以参考下一篇文章。\n上一篇文章：Java高并发秒杀API(二)之Service层\n下一篇文章：Java高并发秒杀API(四)之高并发优化\n","permalink":"https://lewky.cn/posts/33818.html/","tags":["项目笔记","SSM实战项目","秒杀"],"title":"Java高并发秒杀API(三)之Web层"},{"categories":["seckill"],"contents":"1. 设计前的分析 分层的必要性\nDAO层工作演变为:接口设计+SQL编写（不需要其他杂七杂八的功能） 代码和SQL的分离,方便review（浏览） DAO拼接等逻辑在Service层完成（DAO只需负责SQL语句，其他都由Service层完成） 一些初学者容易出现的错误，就是喜欢在DAO层进行逻辑的编写，其实DAO就是数据访问的缩写，它只进行数据的访问操作。\n业务接口的编写\n初学者总是关注细节，关注接口如何去实现，这样设计出来的接口往往比较冗余。业务接口的编写要站在“使用者”的角度定义，三个方面：方法定义的粒度、参数、返回值。\n方法定义粒度：关注接口的功能本身，至于这个功能需要包含哪些步骤那是具体的实现，也就是说，功能明确而且单一。 参数：方法所需要的数据，供使用者传入，明确方法所需要的数据，而且尽可能友好，简练。 返回值：一般情况下，entity数据不够，需要自定义DTO,也有可能抛出异常，需要自定义异常，不管是DTO还是异常，尽可能将接口调用的信息返回给使用者，哪怕是失败信息。 DTO与entity的区别\nDTO数据传输层：用于Web层和Service层之间传递的数据封装。\nentity：用于业务数据的封装，比如数据库中的数据。\n关于秒杀地址的暴露\n需要有专门一个方法实现秒杀地址输出，避免人为因素提前知道秒杀地址而出现漏洞。 获取秒杀url时，如果不合法，则返回当前时间和秒杀项目的时间；如果合法，才返回md5加密后url，以避免url被提前获知。 使用md5将url加密、校验，防止秒杀的url被篡改。 MD5加密\nSpring提供了MD5生成工具。代码如下：\n1 DigestUtils.md5DigestAsHex(); MD5盐值字符串（salt），用于混淆MD5，添加MD5反编译难度\n2. Service层的接口设计 在src/main/java包下建立com.lewis.service包，用来存放Service接口；在src/main/java包下建立com.lewis.exception包，用来存放Service层出现的异常类：比如重复秒杀异常、秒杀已关闭异常；在src/main/java包下建立com.lewis.dto包，用来封装Web层和Service层之间传递的数据。\n定义SeckillService接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 /** * 业务接口:站在使用者(程序员)的角度设计接口 三个方面:1.方法定义粒度，方法定义的要非常清楚2.参数，要越简练越好 3.返回类型(return * 类型一定要友好/或者return异常，我们允许的异常) */ public interface SeckillService { /** * 查询全部的秒杀记录 * * @return */ List\u0026lt;Seckill\u0026gt; getSeckillList(); /** * 查询单个秒杀记录 * * @param seckillId * @return */ Seckill getById(long seckillId); // 再往下，是我们最重要的行为的一些接口 /** * 在秒杀开启时输出秒杀接口的地址，否则输出系统时间和秒杀时间 * * @param seckillId 秒杀商品Id * @return 根据对应的状态返回对应的状态实体 */ Exposer exportSeckillUrl(long seckillId); /** * 执行秒杀操作，有可能失败，有可能成功，所以要抛出我们允许的异常 * * @param seckillId 秒杀的商品ID * @param userPhone 手机号码 * @param md5 md5加密值 * @return 根据不同的结果返回不同的实体信息 */ SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException; } 在dto包中创建Exposer.java，用于封装秒杀的地址信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 /** * 暴露秒杀地址(接口)DTO */ public class Exposer { // 是否开启秒杀 private boolean exposed; // 加密措施 private String md5; //id为seckillId的商品的秒杀地址 private long seckillId; // 系统当前时间(毫秒) private long now; // 秒杀的开启时间 private long start; // 秒杀的结束时间 private long end; public Exposer(boolean exposed, String md5, long seckillId) { this.exposed = exposed; this.md5 = md5; this.seckillId = seckillId; } public Exposer(boolean exposed, long seckillId, long now, long start, long end) { this.exposed = exposed; this.seckillId = seckillId; this.now = now; this.start = start; this.end = end; } public Exposer(boolean exposed, long seckillId) { this.exposed = exposed; this.seckillId = seckillId; } public boolean isExposed() { return exposed; } public void setExposed(boolean exposed) { this.exposed = exposed; } public String getMd5() { return md5; } public void setMd5(String md5) { this.md5 = md5; } public long getSeckillId() { return seckillId; } public void setSeckillId(long seckillId) { this.seckillId = seckillId; } public long getNow() { return now; } public void setNow(long now) { this.now = now; } public long getStart() { return start; } public void setStart(long start) { this.start = start; } public long getEnd() { return end; } public void setEnd(long end) { this.end = end; } @Override public String toString() { return \u0026#34;Exposer{\u0026#34; + \u0026#34;exposed=\u0026#34; + exposed + \u0026#34;, md5=\u0026#39;\u0026#34; + md5 + \u0026#39;\\\u0026#39;\u0026#39; + \u0026#34;, seckillId=\u0026#34; + seckillId + \u0026#34;, now=\u0026#34; + now + \u0026#34;, start=\u0026#34; + start + \u0026#34;, end=\u0026#34; + end + \u0026#39;}\u0026#39;; } } 在dto包中创建SeckillExecution.java，用于封装秒杀是否成功的结果（该对象用来返回给页面）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /** * 封装执行秒杀后的结果:是否秒杀成功 */ public class SeckillExecution { private long seckillId; //秒杀执行结果的状态 private int state; //状态的明文标识 private String stateInfo; //当秒杀成功时，需要传递秒杀成功的对象回去 private SuccessKilled successKilled; //秒杀成功返回所有信息 public SeckillExecution(long seckillId, int state, String stateInfo, SuccessKilled successKilled) { this.seckillId = seckillId; this.state = state; this.stateInfo = stateInfo; this.successKilled = successKilled; } //秒杀失败 public SeckillExecution(long seckillId, int state, String stateInfo) { this.seckillId = seckillId; this.state = state; this.stateInfo = stateInfo; } public long getSeckillId() { return seckillId; } public void setSeckillId(long seckillId) { this.seckillId = seckillId; } public int getState() { return state; } public void setState(int state) { this.state = state; } public String getStateInfo() { return stateInfo; } public void setStateInfo(String stateInfo) { this.stateInfo = stateInfo; } public SuccessKilled getSuccessKilled() { return successKilled; } public void setSuccessKilled(SuccessKilled successKilled) { this.successKilled = successKilled; } } 在exception包中创建秒杀过程中可能出现的异常类\n定义一个基础的异常类SeckillException，继承自RuntimeException\n1 2 3 4 5 6 7 8 9 10 11 12 /** * 秒杀相关的所有业务异常 */ public class SeckillException extends RuntimeException { public SeckillException(String message) { super(message); } public SeckillException(String message, Throwable cause) { super(message, cause); } } 重复秒杀异常，继承自SeckillException\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /** * 重复秒杀异常，是一个运行期异常，不需要我们手动try catch * Mysql只支持运行期异常的回滚操作 */ public class RepeatKillException extends SeckillException { public RepeatKillException(String message) { super(message); } public RepeatKillException(String message, Throwable cause) { super(message, cause); } } 秒杀已关闭异常，继承自SeckillException\n1 2 3 4 5 6 7 8 9 10 11 12 /** * 秒杀关闭异常，当秒杀结束时用户还要进行秒杀就会出现这个异常 */ public class SeckillCloseException extends SeckillException{ public SeckillCloseException(String message) { super(message); } public SeckillCloseException(String message, Throwable cause) { super(message, cause); } } 3. Service层接口的实现 在com.lewis.service包下再建立impl包，用来存放接口的实现类SeckillServiceImpl\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 public class SeckillServiceImpl implements SeckillService { //日志对象 private Logger logger= LoggerFactory.getLogger(this.getClass()); //加入一个混淆字符串(秒杀接口)的salt，为了我避免用户猜出我们的md5值，值任意给，越复杂越好 private final String salt=\u0026#34;aksehiucka24sf*\u0026amp;%\u0026amp;^^#^%$\u0026#34;; //注入Service依赖 @Autowired //@Resource private SeckillDao seckillDao; @Autowired //@Resource private SuccessKilledDao successKilledDao; public List\u0026lt;Seckill\u0026gt; getSeckillList() { return seckillDao.queryAll(0,4); } public Seckill getById(long seckillId) { return seckillDao.queryById(seckillId); } public Exposer exportSeckillUrl(long seckillId) { Seckill seckill=seckillDao.queryById(seckillId); if (seckill==null) //说明查不到这个秒杀产品的记录 { return new Exposer(false,seckillId); } //若是秒杀未开启 Date startTime=seckill.getStartTime(); Date endTime=seckill.getEndTime(); //系统当前时间 Date nowTime=new Date(); if (startTime.getTime()\u0026gt;nowTime.getTime() || endTime.getTime()\u0026lt;nowTime.getTime()) { return new Exposer(false,seckillId,nowTime.getTime(),startTime.getTime(),endTime.getTime()); } //秒杀开启，返回秒杀商品的id、用给接口加密的md5 String md5=getMD5(seckillId); return new Exposer(true,md5,seckillId); } private String getMD5(long seckillId) { String base=seckillId+\u0026#34;/\u0026#34;+salt; String md5= DigestUtils.md5DigestAsHex(base.getBytes()); return md5; } //秒杀是否成功，成功:减库存，增加明细；失败:抛出异常，事务回滚 public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException { if (md5==null||!md5.equals(getMD5(seckillId))) { throw new SeckillException(\u0026#34;seckill data rewrite\u0026#34;);//秒杀数据被重写了 } //执行秒杀逻辑:减库存+增加购买明细 Date nowTime=new Date(); try{ //减库存 int updateCount=seckillDao.reduceNumber(seckillId,nowTime); if (updateCount\u0026lt;=0) { //没有更新库存记录，说明秒杀结束 throw new SeckillCloseException(\u0026#34;seckill is closed\u0026#34;); }else { //否则更新了库存，秒杀成功,增加明细 int insertCount=successKilledDao.insertSuccessKilled(seckillId,userPhone); //看是否该明细被重复插入，即用户是否重复秒杀 if (insertCount\u0026lt;=0) { throw new RepeatKillException(\u0026#34;seckill repeated\u0026#34;); }else { //秒杀成功,得到成功插入的明细记录,并返回成功秒杀的信息 SuccessKilled successKilled=successKilledDao.queryByIdWithSeckill(seckillId,userPhone); return new SeckillExecution(seckillId,1,\u0026#34;秒杀成功\u0026#34;,successKilled); } } }catch (SeckillCloseException e1) { throw e1; }catch (RepeatKillException e2) { throw e2; }catch (Exception e) { logger.error(e.getMessage(),e); //将编译期异常转化为运行期异常 throw new SeckillException(\u0026#34;seckill inner error :\u0026#34;+e.getMessage()); } } } 在以上代码中，我们捕获了运行时异常，原因是Spring的事务默认是发生了RuntimeException才会回滚，发生了其他异常不会回滚，所以在最后的catch块里通过throw new SeckillException(\u0026quot;seckill inner error :\u0026quot;+e.getMessage());将编译期异常转化为运行期异常。\n另外，在代码里还存在着硬编码的情况，比如秒杀结果返回的state和stateInfo参数信息是输出给前端的，这些字符串应该考虑用常量枚举类封装起来，方便重复利用，也易于维护。\n在src/main/java包下新建一个枚举包com.lewis.enums包，在该包下创建一个枚举类型SeckillStatEnum\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public enum SeckillStatEnum { SUCCESS(1,\u0026#34;秒杀成功\u0026#34;), END(0,\u0026#34;秒杀结束\u0026#34;), REPEAT_KILL(-1,\u0026#34;重复秒杀\u0026#34;), INNER_ERROR(-2,\u0026#34;系统异常\u0026#34;), DATE_REWRITE(-3,\u0026#34;数据篡改\u0026#34;); private int state; private String info; SeckillStatEnum(int state, String info) { this.state = state; this.info = info; } public int getState() { return state; } public String getInfo() { return info; } public static SeckillStatEnum stateOf(int index) { for (SeckillStatEnum state : values()) { if (state.getState()==index) { return state; } } return null; } } 创建了枚举类型后，就需要修改之前硬编码的地方，修改SeckillExecution涉及到state和stateInfo参数的构造方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 //秒杀成功返回所有信息 public SeckillExecution(long seckillId, SeckillStatEnum statEnum, SuccessKilled successKilled) { this.seckillId = seckillId; this.state = statEnum.getState(); this.stateInfo = statEnum.getInfo(); this.successKilled = successKilled; } //秒杀失败 public SeckillExecution(long seckillId, SeckillStatEnum statEnum) { this.seckillId = seckillId; this.state = statEnum.getState(); this.stateInfo = statEnum.getInfo(); } 接着把SeckillServiceImpl里返回的秒杀成功信息的return new SeckillExecution(seckillId,1,\u0026quot;秒杀成功\u0026quot;,successKilled);改成return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS,successKilled);\n4. 使用Spring进行Service层的配置 在之前创建的spring包下创建spring-service.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xmlns:tx=\u0026#34;http://www.springframework.org/schema/tx\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd\u0026#34;\u0026gt; \u0026lt;!--扫描service包下所有使用注解的类型 --\u0026gt; \u0026lt;context:component-scan base-package=\u0026#34;com.lewis.service\u0026#34; /\u0026gt; \u0026lt;!--配置事务管理器 --\u0026gt; \u0026lt;bean id=\u0026#34;transactionManager\u0026#34; class=\u0026#34;org.springframework.jdbc.datasource.DataSourceTransactionManager\u0026#34;\u0026gt; \u0026lt;!--注入数据库连接池 --\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34; /\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--配置基于注解的声明式事务 默认使用注解来管理事务行为 --\u0026gt; \u0026lt;tx:annotation-driven transaction-manager=\u0026#34;transactionManager\u0026#34; /\u0026gt; \u0026lt;/beans\u0026gt; 事务管理器\nMyBatis采用的是JDBC的事务管理器\nHibernate采用的是Hibernate的事务管理器\n通过注解的方式将Service的实现类（注意，不是Service接口）加入到Spring IoC容器中\n1 2 @Service public class SeckillServiceImpl implements SeckillService; 在需要进行事务声明的方法上加上事务的注解@Transactional\n1 2 3 @Transactional public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException {} Spring的声明式事务管理\n异常捕获机制 Java异常分编译期异常和运行期异常，运行期异常不需要手工try-catch，Spring的的声明式事务只接收运行期异常回滚策略，非运行期异常不会帮我们回滚。\n事务传播行为 Spring一共有7个事务传播行为，默认的事务传播行为是PROPAGATION_REQUIRED，详情可以参考这篇文章\n使用注解控制事务方法的优点（对于秒杀这种对事务延迟要求高的业务场景尤为重要）\n1.开发团队达成一致约定，明确标注事务方法的编程风格 2.保证事务方法的执行时间尽可能短，不要穿插其他网络操作RPC/HTTP请求或者剥离到事务方法外部（保证事务方法里面是很干净的/效率的） 3.不是所有的方法都需要事务，如只有一条修改操作、只读操作不要事务控制（MYSQL 表级锁、行级锁） 为什么使用IoC（控制反转）\n对象创建统一托管。 规范的生命周期管理。 灵活的依赖注入。 一致的对象获取方式。 Spring基于注解的事务操作\n在Spring早期版本中是使用ProxyFactoryBean+XMl方式来配置事务。 在Spring配置文件使用tx:advice+aop命名空间，好处就是一次配置永久生效，你无须去关心中间出的问题，不过出错了你很难找出来在哪里出了问题。 注解@Transactional的方式，注解可以在方法定义、接口定义、类定义、public方法上，但是不能注解在private、final、static等方法上，因为Spring的事务管理默认是使用Cglib动态代理的： private方法因为访问权限限制，无法被子类覆盖 final方法无法被子类覆盖 static是类级别的方法，无法被子类覆盖 protected方法可以被子类覆盖，因此可以被动态字节码增强 不能被Spring AOP事务增强的方法\n序号 动态代理策略 不能被事务增强的方法 1 基于接口的动态代理 除了public以外的所有方法，并且public static的方法也不能被增强 2 基于Cglib的动态代理 private、static、final的方法 关于Spring的组件注解、注入注解\n@Component：标识一个组件，当不知道是什么组件，或者该组件不好归类时使用该注解 @Service：标识业务层组件 @Repository：标识DAO层组件 @Controller：标识控制层组件 通过Spring提供的组件自动扫描机制，可以在类路径下寻找标注了上述注解的类，并把这些类纳入进spring容器中管理，这些注解的作用和在xml文件中使用bean节点配置组件时一样的。\n1 \u0026lt;context:component-scan base-package=”xxx.xxx.xxx”\u0026gt; component-scan标签默认情况下自动扫描指定路径下的包(含所有子包)，将带有@Component、@Repository、@Service、@Controller标签的类自动注册到spring容器。getBean的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”)这样来指定。这种bean默认是“singleton”的，如果想改变，可以使用@Scope(“prototype”)来改变。\n当使用\u0026lt;context:component-scan/\u0026gt;后，就可以将\u0026lt;context:annotation-config/\u0026gt;移除了，前者包含了后者。\n另外，@Resource，@Inject 是J2EE规范的一些注解\n@Autowired是Spring的注解，可以对类成员变量、方法及构造函数进行标注，完成自动装配的工作。通过 @Autowired的使用来消除setter/getter方法，默认按类型装配，如果想使用名称装配可以结合@Qualifier注解进行使用，如下：\n1 2 @Autowired() @Qualifier(\u0026#34;baseDao\u0026#34;) private BaseDao baseDao; 与@Autowired类似的是@Resource，@Resource属于J2EE规范，默认安照名称进行装配，名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名进行按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。\n1 2 @Resource(name=\u0026#34;baseDao\u0026#34;) private BaseDao baseDao; 而@Inject与@Autowired类似，也是根据类型注入，也可以通过@Named注解来按照name注入，此时只会按照名称进行装配。\n1 2 @Inject @Named(\u0026#34;baseDao\u0026#34;) private BaseDao baseDao; 5. 进行Service层的集成测试 使用logback来输出日志信息，在resources包下创建logback.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;appender name=\u0026#34;STDOUT\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;!-- encoders are assigned the type ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;root level=\u0026#34;debug\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;STDOUT\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt; 通过IDE工具快速生成Junit单元测试，然后在各个方法里写测试代码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 @RunWith(SpringJUnit4ClassRunner.class) //告诉junit spring的配置文件 @ContextConfiguration({\u0026#34;classpath:spring/spring-dao.xml\u0026#34;, \u0026#34;classpath:spring/spring-service.xml\u0026#34;}) public class SeckillServiceTest { private final Logger logger= LoggerFactory.getLogger(this.getClass()); @Autowired private SeckillService seckillService; @Test public void testGetSeckillList() throws Exception { List\u0026lt;Seckill\u0026gt; list=seckillService.getSeckillList(); logger.info(\u0026#34;list={}\u0026#34;, list); } @Test public void testGetById() throws Exception { long seckillId=1000; Seckill seckill=seckillService.getById(seckillId); logger.info(\u0026#34;seckill={}\u0026#34;, seckill); } } 在测试通过了这两个方法后，开始对后两个业务逻辑方法的测试，首先测试testExportSeckillUrl()\n1 2 3 4 5 6 @Test public void testExportSeckillUrl() throws Exception { long seckillId=1000; Exposer exposer=seckillService.exportSeckillUrl(seckillId); logger.info(\u0026#34;exposer={}\u0026#34;, exposer); } 会发现没有返回商品的秒杀地址，因为我们数据库的秒杀时间和结束秒杀时间没有修改，所以判断当前商品的秒杀已结束。将数据库中的秒杀时间和结束秒杀时间修改成满足我们当前的时间的范围，重新测试该方法，可以获取到该商品的秒杀地址。而第四个方法的测试需要使用到该地址（md5），将该值传入到testExecuteSeckill()中进行测试：\n1 2 3 4 5 6 7 8 9 @Test public void testExecuteSeckill() throws Exception { long seckillId=1000; long userPhone=13476191876L; String md5=\u0026#34;70b9564762568e9ff29a4a949f8f6de4\u0026#34;; SeckillExecution execution=seckillService.executeSeckill(seckillId,userPhone,md5); logger.info(\u0026#34;result={}\u0026#34;, execution); } 需要注意的是，该方法是会产生异常的，比如我们重复运行该方法，会报错，因为用户进行了重复秒杀，所以我们需要手动try-catch，将程序允许的异常包起来而不去向上抛给junit，更改测试代码如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Test public void testExecuteSeckill() throws Exception { long seckillId=1000; long userPhone=13476191876L; String md5=\u0026#34;70b9564762568e9ff29a4a949f8f6de4\u0026#34;; try { SeckillExecution execution = seckillService.executeSeckill(seckillId, userPhone, md5); logger.info(\u0026#34;result={}\u0026#34;, execution); }catch (RepeatKillException e) { logger.error(e.getMessage()); }catch (SeckillCloseException e1) { logger.error(e1.getMessage()); } } 在测试过程中，第四个方法使用到了第三个方法返回的秒杀地址，在实际开发中，我们需要将第三个和第四个方法合并成一个完整逻辑的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 //集成测试代码完整逻辑，注意可重复执行 @Test public void testSeckillLogic() throws Exception { long seckillId=1000; Exposer exposer=seckillService.exportSeckillUrl(seckillId); if (exposer.isExposed()) { logger.info(\u0026#34;exposer={}\u0026#34;, exposer); long userPhone=13476191876L; String md5=exposer.getMd5(); try { SeckillExecution execution = seckillService.executeSeckill(seckillId, userPhone, md5); logger.info(\u0026#34;result={}\u0026#34;, execution); }catch (RepeatKillException e) { logger.error(e.getMessage()); }catch (SeckillCloseException e1) { logger.error(e1.getMessage()); } }else { //秒杀未开启 logger.warn(\u0026#34;exposer={}\u0026#34;, exposer); } } 我们可以在SeckillServiceTest类里面加上@Transational注解，原因是：\n@Transactional注解是表明此测试类的事务启用，这样所有的测试方案都会自动的 rollback，即不用自己清除自己所做的任何对数据库的变更了。\n日志无法打印的问题\n在pom.xml中加上\n1 2 3 4 5 6 7 8 9 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.9\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 存在的坑\n关于同类中调用事务方法的时候有个坑，同学们需要注意下AOP切不到调用事务方法。事务不会生效，解决办法有几种，可以搜一下，找一下适合自己的方案。本质问题是类内部调用时AOP不会用代理调用内部方法。 没有引入AOP的xsd会报错 1 2 3 4 5 xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance http://www.springmodules.org/schema/cache/springmodules-cache.xsd http://www.springmodules.org/schema/cache/springmodules-ehcache.xsd\u0026#34; 相关链接\nSpring事务异常回滚，捕获异常不抛出就不会回滚\n本节结语\n至此，关于Java高并发秒杀API的Service层的开发与测试已经完成，接下来进行Web层的开发，详情请参考下一篇文章。\n上一篇文章：Java高并发秒杀API(一)之业务分析与DAO层\n下一篇文章：Java高并发秒杀API(三)之Web层\n","permalink":"https://lewky.cn/posts/18357.html/","tags":["项目笔记","SSM实战项目","秒杀"],"title":"Java高并发秒杀API(二)之Service层"},{"categories":["seckill"],"contents":" 本SSM实战项目使用了Maven进行依赖管理，如果有不清楚Maven是什么的可以参考这篇文章\n1. 创建Maven项目和依赖 1.1 创建项目前需要先安装Maven，并设置好环境变量 Maven下载 设置环境变量 新建变量MAVEN_HOME，值为Maven的目录X:\\XXX\\apache-maven-XXX 将%MAVEN_HOME%\\bin添加到Path变量下 运行CMD，输入mvn -v后可以看到Maven的版本信息等则表示安装成功 1.2 创建Maven项目有两种方式，如下 第一种创建方式：使用命令行手动创建\n1 mvn archetype:generate -DgroupId=com.lewis.seckill -DartifactId=seckill -Dpackage=com.lewis.seckill -Dversion=1.0-SNAPSHOT -DarchetypeArtifactId=maven-archetype-webapp 在视频中使用的是archetype:create，该方法已被废弃，请使用archetype:generate来创建。命令行执行后会创建一个maven-archetype-webapp骨架的Maven项目，其中groupId是项目组织唯一的标识符，实际对应JAVA的包的结构；artifactId是项目的唯一的标识符，实际对应项目的名称；package一般是groupId+artifactId，是自动生成的，可以修改\n第二种创建方式：借助IDE工具的Maven插件来创建项目\nEclipse安装Maven插件\n不知道怎么Maven插件的请参考该博文，推荐使用link方式手工安装的方式 如果是手工安装Maven插件的，可能会缺少pom.xml 图形化编辑工具，请另外添加进去，具体情况请参考该博文 已经安装了Maven插件的请走下一个步骤 File→New→Other...→Maven Project→Next,进入如下界面 Maven1\r点击Next，选择要构建的骨架maven-archetype-webapp，如下图 Maven2\r点击Next，填写groupId=com.lewis.seckill，DartifactId=seckill，package=com.lewis.seckill（根据实际情况填写），然后Finish 如果是第一次使用Eclipse的Maven插件来创建Maven项目的可能会遇到一些问题，可以参考该博文\n1.3 修改pom.xml文件 当创建完Maven项目后会在根目录下有一个pom.xml文件，Maven项目通过pom.xml进行项目依赖的管理，如果没有该xml文件，Eclipse不会将该项目当作一个Maven项目\n添加项目需要的jar包依赖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.lewis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;seckill\u0026lt;/artifactId\u0026gt; \u0026lt;packaging\u0026gt;war\u0026lt;/packaging\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;name\u0026gt;seckill Maven Webapp\u0026lt;/name\u0026gt; \u0026lt;url\u0026gt;http://maven.apache.org\u0026lt;/url\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.11\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--补全项目依赖 --\u0026gt; \u0026lt;!--1.日志 java日志有:slf4j,log4j,logback,commons-logging slf4j,commons-logging:是规范/接口 日志实现:log4j,logback 使用:slf4j+logback --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.12\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--实现slf4j接口并整合 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-classic\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--2.数据库相关依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.35\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;c3p0\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;c3p0\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.9.1.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--3.dao框架:MyBatis依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--mybatis自身实现的spring整合依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--4.Servlet web相关依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;taglibs\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;standard\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jstl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax.servlet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.servlet-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--5:spring依赖 --\u0026gt; \u0026lt;!--1)spring核心依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.7.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-beans\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.7.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-context\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.7.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--2)spring dao层依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.7.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-tx\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.7.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--3)springweb相关依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.7.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webmvc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.7.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--4)spring test相关依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-test\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.1.7.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--添加redis依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;redis.clients\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jedis\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--prostuff序列化依赖 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.dyuproject.protostuff\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;protostuff-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.dyuproject.protostuff\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;protostuff-runtime\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;seckill\u0026lt;/finalName\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;!--打包时包含源代码包下的资源文件 默认情况下只会打包src/main/java下的源代码 --\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 关于maven依赖的简化写法\n教学视频中老师写了很多的依赖，但其实这里面有一些是可以省略不写的，因为有些包会自动依赖其它的包（Maven的传递性依赖）。这里面可以省略的依赖有：spring-core;spring-beans（上面这两个spring-context会自动依赖）;spring-context，spring-jdbc（mybatis-spring会依赖）；spring-web（spring-webmvc会依赖）；logback-core（logback-classic会依赖）\n有想要了解Maven的依赖范围与传递性依赖的请参考该博文\n2. 秒杀业务分析 2.1 业务分析 秒杀业务的核心是对库存的处理，其业务流程如下图\n1.png\r用户针对库存业务分析\n当用户执行秒杀成功时，应该发生以下两个操作：\n减库存 记录购买明细 这两个操作属于一个完整事务，通过事务来实现数据落地\n为什么需要事务？\n减库存却没有记录购买明细，会导致商品少卖 记录购买明细却没有减库存，会导致商品超卖 在实际中，以上都是很严重的事故，会给商家或买家带来损失，这是不能被允许的。一旦发生这种事故，事故责任很自然的就会去找设计实现业务的程序员\n如何实现数据落地？\n有MySQL与NoSQL两种数据落地的方案\nMySQL属于关系型数据库，而MySQL内置的事务机制来可以准确的帮我们完成减库存和记录购买明细的过程。MySQL有多种存储引擎，但只有InnoDB存储引擎支持事务。InnoDB支持行级锁和表级锁，默认使用行级锁 NoSQL属于非关系型数据库，近些年来在数据存储方面承担了很大的职责，但是对于事务的支持做的并不是很好，更多追求的是性能、高复用、分布式。 事务机制依然是目前最可靠的数据落地方案。\n数据落地与不数据落地\n落地数据：就是被持久化的数据，这种数据一般放在硬盘或是其他的持久化存储设备里，例如：图片、系统日志、在页面上显示的数据以及保存在关系数据库里的数据等等，落地数据一定会有一个固定的载体，他们不会瞬时消失的。 不落地数据：一般指存储在内存或者是网络传输里的数据，这些数据是瞬时，使用完毕就会消失，例如：我们在浏览器发送给服务器的请求；从数据库读取出来的一直到页面展示前的数据等等。 “不落地”传输能够满足用户在性能上的要求。 2.2 使用MySQL实现秒杀的难点分析 难点问题：如何高效地处理竞争？\n当一个用户在执行秒杀某件商品时，其他也想要秒杀该商品的用户就只能等待，直到上一个用户提交或回滚了事务，他才能够得到该商品的锁执行秒杀操作。这里就涉及到了锁的竞争。\n2.jpg\r对于MySQL来说，竞争反应到背后的技术是就是事务+行级锁：\nstart transaction（开启事务）→ update库存数量 → insert购买明细 → commit（提交事务）\n在秒杀系统中，在同一时刻会有很多用户在秒杀同一件商品，那么如何高效低处理这些竞争？如何高效地提交事务？这些将在Java高并发秒杀API(四)之高并发优化进行分析总结。\n实现哪些秒杀功能？\n下面先以天猫的秒杀库存系统为例，如下图\n3.jpg\r可以看到，天猫的秒杀库存系统是很复杂的，需要很多工程师共同开发。在这里，我们只实现秒杀相关的功能\n秒杀接口暴露 执行秒杀 相关查询 为什么要进行秒杀接口暴露的操作？\n现实中有的用户回通过浏览器插件提前知道秒杀接口，填入参数和地址来实现自动秒杀，这对于其他用户来说是不公平的，我们也不希望看到这种情况\n3. DAO层设计 3.1 创建数据库 源码里有个sql文件夹，可以给出了sql语句；也可以选择自己手写。数据库一共就两个表：秒杀库存表、秒杀成功明细表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 -- 数据库初始化脚本 -- 创建数据库 CREATE DATABASE seckill; -- 使用数据库 use seckill; CREATE TABLE seckill( `seckill_id` BIGINT NOT NUll AUTO_INCREMENT COMMENT \u0026#39;商品库存ID\u0026#39;, `name` VARCHAR(120) NOT NULL COMMENT \u0026#39;商品名称\u0026#39;, `number` int NOT NULL COMMENT \u0026#39;库存数量\u0026#39;, `create_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \u0026#39;创建时间\u0026#39;, `start_time` TIMESTAMP NOT NULL COMMENT \u0026#39;秒杀开始时间\u0026#39;, `end_time` TIMESTAMP NOT NULL COMMENT \u0026#39;秒杀结束时间\u0026#39;, PRIMARY KEY (seckill_id), key idx_start_time(start_time), key idx_end_time(end_time), key idx_create_time(create_time) )ENGINE=INNODB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8 COMMENT=\u0026#39;秒杀库存表\u0026#39;; -- 初始化数据 INSERT into seckill(name,number,start_time,end_time) VALUES (\u0026#39;1000元秒杀iphone6\u0026#39;,100,\u0026#39;2016-01-01 00:00:00\u0026#39;,\u0026#39;2016-01-02 00:00:00\u0026#39;), (\u0026#39;800元秒杀ipad\u0026#39;,200,\u0026#39;2016-01-01 00:00:00\u0026#39;,\u0026#39;2016-01-02 00:00:00\u0026#39;), (\u0026#39;6600元秒杀mac book pro\u0026#39;,300,\u0026#39;2016-01-01 00:00:00\u0026#39;,\u0026#39;2016-01-02 00:00:00\u0026#39;), (\u0026#39;7000元秒杀iMac\u0026#39;,400,\u0026#39;2016-01-01 00:00:00\u0026#39;,\u0026#39;2016-01-02 00:00:00\u0026#39;); -- 秒杀成功明细表 -- 用户登录认证相关信息(简化为手机号) CREATE TABLE success_killed( `seckill_id` BIGINT NOT NULL COMMENT \u0026#39;秒杀商品ID\u0026#39;, `user_phone` BIGINT NOT NULL COMMENT \u0026#39;用户手机号\u0026#39;, `state` TINYINT NOT NULL DEFAULT -1 COMMENT \u0026#39;状态标识👎无效 0:成功 1:已付款 2:已发货\u0026#39;, `create_time` TIMESTAMP NOT NULL COMMENT \u0026#39;创建时间\u0026#39;, PRIMARY KEY(seckill_id,user_phone),/*联合主键*/ KEY idx_create_time(create_time) )ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT=\u0026#39;秒杀成功明细表\u0026#39;; 秒杀成功明细表为何使用联合主键\n之所以使用联合主键，是为了能够过滤重复插入，可以通过insert ignore into语句来避免用户重复秒杀同一件商品。这样当有重复记录就会忽略，语句执行后返回数字0。\n可能存在的问题\n安装视频里的建表过程，可能会出现建表失败的情况。原因是当你给一个timestamp设置为on update current_timestamp的时候，其他的timestamp字段需要显式设定default值。\n但是如果你有两个timestamp字段，但是只把第一个设定为current_timestamp而第二个没有设定默认值，MySQL也能成功建表,但是反过来就不行。这是mysql5.5版本对timestamp的处理。\n为了解决这个问题，将create_time放到start_time和end_time的前面，还有的mysql版本需要将三个时间戳都设置默认值。\n3.2 创建数据表对应的实体类 在src/main/java包下创建com.lewis.entity包，接着建立Seckill实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 public class Seckill { private Long seckillId; private String name; private Integer number; private Date createTime; private Date startTime; private Date endTime; public Long getSeckillId() { return seckillId; } public void setSeckillId(Long seckillId) { this.seckillId = seckillId; } public String getName() { return name; } public void setName(String name) { this.name = name == null ? null : name.trim(); } public Integer getNumber() { return number; } public void setNumber(Integer number) { this.number = number; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } public Date getStartTime() { return startTime; } public void setStartTime(Date startTime) { this.startTime = startTime; } public Date getEndTime() { return endTime; } public void setEndTime(Date endTime) { this.endTime = endTime; } @Override public String toString() { return \u0026#34;Seckill [seckillId=\u0026#34; + seckillId + \u0026#34;, name=\u0026#34; + name + \u0026#34;, number=\u0026#34; + number + \u0026#34;, createTime=\u0026#34; + createTime + \u0026#34;, startTime=\u0026#34; + startTime + \u0026#34;, endTime=\u0026#34; + endTime + \u0026#34;]\u0026#34;; } } 在com.lewis.entity包下，接着建立SuccessKilled实体类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class SuccessKilled { private Byte state; private Date createTime; private Long seckillId; private Long userPhone; // 多对一,因为一件商品在库存中有很多数量，对应的购买明细也有很多。 private Seckill seckill; public Seckill getSeckill() { return seckill; } public void setSeckill(Seckill seckill) { this.seckill = seckill; } public Long getSeckillId() { return seckillId; } public void setSeckillId(Long seckillId) { this.seckillId = seckillId; } public Long getUserPhone() { return userPhone; } public void setUserPhone(Long userPhone) { this.userPhone = userPhone; } public Byte getState() { return state; } public void setState(Byte state) { this.state = state; } public Date getCreateTime() { return createTime; } public void setCreateTime(Date createTime) { this.createTime = createTime; } @Override public String toString() { return \u0026#34;SuccessKilled [state=\u0026#34; + state + \u0026#34;, createTime=\u0026#34; + createTime + \u0026#34;, seckillId=\u0026#34; + seckillId + \u0026#34;, userPhone=\u0026#34; + userPhone + \u0026#34;]\u0026#34;; } } 3.3 创建实体类对应的DAO层接口（也就是Mapper接口，DAO针对的是具体实体来操作的“实体的增删改查”） 在src/main/java下建立com.lewis.dao包，在包下建立SeckillDao接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 public interface SeckillDao { /** * 减库存 * * @param seckillId * @param killTime * @return 更新的记录行数，如果返回值\u0026lt;1则表示更新失败 */ int reduceNumber(@Param(\u0026#34;seckillId\u0026#34;) long seckillId, @Param(\u0026#34;killTime\u0026#34;) Date killTime); /** * 根据id查询秒杀商品 * * @param seckillId * @return */ Seckill queryById(long seckillId); /** * 根据偏移量查询秒杀商品列表 * * @param offset * @param limit * @return */ List\u0026lt;Seckill\u0026gt; queryAll(@Param(\u0026#34;offset\u0026#34;) int offset, @Param(\u0026#34;limit\u0026#34;) int limit); } 在com.lewis.dao包下建立SuccessKilledDao接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public interface SuccessKilledDao { /** * 插入购买明细，可过滤重复 * * @param seckillId * @param userphone * @return 插入的行数，如果返回值\u0026lt;1则表示插入失败 */ int insertSuccessKilled(@Param(\u0026#34;seckillId\u0026#34;) long seckillId, @Param(\u0026#34;userPhone\u0026#34;) long userPhone); /** * 根据id查询SuccessKilled并携带秒杀商品对象实体 * * @param seckillId * @return */ SuccessKilled queryByIdWithSeckill(@Param(\u0026#34;seckillId\u0026#34;) long seckillId, @Param(\u0026#34;userPhone\u0026#34;) long userPhone); } 为什么有的方法形参前有@Param，有的却没有？\n从上面的代码可以发现，当方法的形参在两个及两个以上时，需要在参数前加上@Param，如果不加上该注解会在之后的测试运行时报错。这是Sun提供的默认编译器（javac）在编译后的Class文件中会丢失参数的实际名称，方法中的形参会变成无意义的arg0、arg1等，在只有一个参数时就无所谓，但当参数在两个和两个以上时，传入方法的参数就会找不到对应的形参。因为Java形参的问题，所以在多个基本类型参数时需要用@Param注解区分开来。\n3.4 基于MyBatis实现DAO接口 MyBatis怎么用？SQL写在哪里？\nMybatis有两种提供SQL的方式：XML提供SQL、注解提供SQL（注解是java5.0之后提供的一个新特性）。\n对于实际的使用中建议使用XML文件的方式提供SQL。如果通过注解的方式提供SQL，由于注解本身还是java源码，这对于修改和调整SQL其实是非常不方便的，一样需要重新编译类，当我们写复杂的SQL尤其拼接逻辑时，注解处理起来就会非常繁琐。而XML提供了很多的SQL拼接和处理逻辑的标签，可以非常方便的帮我们去做封装。\n如何去实现DAO接口？\nMapper自动实现DAO（也就是DAO只需要设计接口，不需要去写实现类，MyBatis知道我们的参数、返回类型是什么，同时也有SQL文件，它可以自动帮我们生成接口的实现类来帮我们执行参数的封装，执行SQL，把我们的返回结果集封装成我们想要的类型） 。\n第二种是通过API编程方式实现DAO接口（MyBatis通过给我们提供了非常多的API，跟其他的ORM和JDBC很像）\n在实际开发中建议使用Mapper自动实现DAO，这样可以直接只关注SQL如何编写，如何去设计DAO接口，帮我们节省了很多的维护程序，所有的实现都是MyBatis自动完成。\n创建一个目录存放Mybatis的SQL映射\n按照Maven的规范，SQL映射文件应该放在src/main/resources包下，在该包下建立mapper目录，用来存放映射DAO接口的XML文件。这样Maven在编译时就会自动将src/main/resources下的这些配置文件编译进来。\n我们也可以按照原本的习惯，在src/main/java下建立com.lewis.mapper包，将这些SQL映射存放到这里。由于Maven默认不会编译src/main/java下除源码以外的文件，所以需要在pom.xml中进行额外的配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;build\u0026gt; \u0026lt;finalName\u0026gt;seckill\u0026lt;/finalName\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;!--打包时包含源代码包下的资源文件，默认情况下只会打包src/main/java下的源代码 --\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/java\u0026lt;/directory\u0026gt; \u0026lt;includes\u0026gt; \u0026lt;include\u0026gt;**/*.xml\u0026lt;/include\u0026gt; \u0026lt;/includes\u0026gt; \u0026lt;filtering\u0026gt;false\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;/build\u0026gt; 在本项目中，我是采用的第二种方式存放Mybatis的SQL映射。（只是将映射DAO的mapper文件放在java包下，其他的关于Spring、MyBatis等的配置文件还是放在resources包下）\n在src/main/resources目录下配置mybatis-config.xml（配置MyBatis的全局属性）\n打开MyBatis的官方文档（MyBatis的官方文档做的非常友好，提供了非常多版本的国际化支持），选择\r入门，找到MyBatis全局配置，里面有XML的规范（XML的标签约束dtd文件），拷入到项目的MyBatis全局配置文件中，开始配置MyBatis，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;!--配置全局属性 --\u0026gt; \u0026lt;settings\u0026gt; \u0026lt;!--使用jdbc的getGeneratekeys获取自增主键值，默认是false 当inert一条记录时我们是不插入id的，id是通过自增去赋值的 当插入完后想得到该插入记录的id时可以调用jdbc的getGeneratekeys --\u0026gt; \u0026lt;setting name=\u0026#34;useGeneratedKeys\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!--使用列别名替换列名 默认值为true（可以不用写出来，这里写出来只是为了讲解该配置的作用） select name as title(实体中的属性名是title) form table; 开启后mybatis会自动帮我们把表中name的值赋到对应实体的title属性中 --\u0026gt; \u0026lt;setting name=\u0026#34;useColumnLabel\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;!--开启驼峰命名转换Table:create_time到 Entity(createTime) --\u0026gt; \u0026lt;setting name=\u0026#34;mapUnderscoreToCamelCase\u0026#34; value=\u0026#34;true\u0026#34; /\u0026gt; \u0026lt;/settings\u0026gt; \u0026lt;/configuration\u0026gt; 在src/main/java目录下的com.lewis.mapper包里创建SeckillDao.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;!-- namespace:指定为哪个接口提供配置 --\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.lewis.dao.SeckillDao\u0026#34;\u0026gt; \u0026lt;!--目的:为dao接口方法提供sql语句配置， 即针对dao接口中的方法编写我们的sql语句 --\u0026gt; \u0026lt;!-- int reduceNumber(long seckillId, Date killTime);--\u0026gt; \u0026lt;!-- 这里id必须和对应的DAO接口的方法名一样 --\u0026gt; \u0026lt;update id=\u0026#34;reduceNumber\u0026#34;\u0026gt; UPDATE seckill SET number = number-1 WHERE seckill_id=#{seckillId} AND start_time \u0026lt;![CDATA[ \u0026lt;= ]]\u0026gt; #{killTime} AND end_time \u0026gt;= #{killTime} AND number \u0026gt; 0; \u0026lt;/update\u0026gt; \u0026lt;!-- parameterType:使用到的参数类型 正常情况java表示一个类型的包名+类名，这直接写类名，因为后面有一个配置可以简化写包名的过程 --\u0026gt; \u0026lt;select id=\u0026#34;queryById\u0026#34; resultType=\u0026#34;Seckill\u0026#34; parameterType=\u0026#34;long\u0026#34;\u0026gt; \u0026lt;!-- 可以通过别名的方式列明到java名的转换，如果开启了驼峰命名法就可以不用这么写了 select seckill_id as seckillId --\u0026gt; SELECT seckill_id,name,number,create_time,start_time,end_time FROM seckill WHERE seckill_id=#{seckillId} \u0026lt;/select\u0026gt; \u0026lt;select id=\u0026#34;queryAll\u0026#34; resultType=\u0026#34;Seckill\u0026#34;\u0026gt; SELECT * FROM seckill ORDER BY create_time DESC limit #{offset},#{limit} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 在src/main/java目录下的com.lewis.mapper包里创建SuccessKilledDao.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 \u0026lt;!DOCTYPE mapper PUBLIC \u0026#34;-//mybatis.org//DTD Mapper 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd\u0026#34;\u0026gt; \u0026lt;mapper namespace=\u0026#34;com.lewis.dao.SuccessKilledDao\u0026#34;\u0026gt; \u0026lt;insert id=\u0026#34;insertSuccessKilled\u0026#34;\u0026gt; \u0026lt;!--当出现主键冲突时(即重复秒杀时)，会报错;不想让程序报错，加入ignore--\u0026gt; INSERT ignore INTO success_killed(seckill_id,user_phone,state) VALUES (#{seckillId},#{userPhone},0) \u0026lt;/insert\u0026gt; \u0026lt;select id=\u0026#34;queryByIdWithSeckill\u0026#34; resultType=\u0026#34;SuccessKilled\u0026#34;\u0026gt; \u0026lt;!--根据seckillId查询SuccessKilled对象，并携带Seckill对象--\u0026gt; \u0026lt;!--如何告诉mybatis把结果映射到SuccessKill属性同时映射到Seckill属性--\u0026gt; \u0026lt;!--可以自由控制SQL语句--\u0026gt; SELECT sk.seckill_id, sk.user_phone, sk.create_time, sk.state, s.seckill_id \u0026#34;seckill.seckill_id\u0026#34;, s.name \u0026#34;seckill.name\u0026#34;, s.number \u0026#34;seckill.number\u0026#34;, s.start_time \u0026#34;seckill.start_time\u0026#34;, s.end_time \u0026#34;seckill.end_time\u0026#34;, s.create_time \u0026#34;seckill.create_time\u0026#34; FROM success_killed sk INNER JOIN seckill s ON sk.seckill_id=s.seckill_id WHERE sk.seckill_id=#{seckillId} and sk.user_phone=#{userPhone} \u0026lt;/select\u0026gt; \u0026lt;/mapper\u0026gt; 注：上面的s.seckill_id “seckill.seckill_id”表示s.seckill_id这一列的数据是Success_killed实体类里的seckill属性里的seckill_id属性，是一个级联的过程，使用的就是别名只是忽略了as关键字，别名要加上双引号。\n为什么要用\u0026lt;![CDATA[]]\u0026gt;把\u0026lt;=给包起来\nCDATA指的是不应由 XML 解析器进行解析的文本数据，在XML元素中，\u0026lt;和\u0026amp;是非法的：\n\u0026lt;会产生错误，因为解析器会把该字符解释为新元素的开始。 \u0026amp;也会产生错误，因为解析器会把该字符解释为字符实体的开始。（字符实体：比如\u0026amp;nbsp;表示一个空格） 所以在这里我们需要使用\u0026lt;![CDATA[ \u0026lt;= ]]\u0026gt;来告诉XML\u0026lt;=不是XML的语言。\n3.5 整合Spring和MyBatis 在resources目录下创建一个新的目录spring(存放所有Spring相关的配置)\n在resources包下创建jdbc.properties，用于配置数据库的连接信息\n1 2 3 4 driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/seckill?useUnicode=true\u0026amp;characterEncoding=utf-8 jdbc.username=root password=123 在resources/spring目录下创建Spring关于DAO层的配置文件spring-dao.xml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;beans xmlns=\u0026#34;http://www.springframework.org/schema/beans\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xmlns:context=\u0026#34;http://www.springframework.org/schema/context\u0026#34; xsi:schemaLocation=\u0026#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\u0026#34;\u0026gt; \u0026lt;!--配置整合mybatis过程 1.配置数据库相关参数--\u0026gt; \u0026lt;context:property-placeholder location=\u0026#34;classpath:jdbc.properties\u0026#34;/\u0026gt; \u0026lt;!--2.数据库连接池--\u0026gt; \u0026lt;bean id=\u0026#34;dataSource\u0026#34; class=\u0026#34;com.mchange.v2.c3p0.ComboPooledDataSource\u0026#34;\u0026gt; \u0026lt;!--配置连接池属性--\u0026gt; \u0026lt;property name=\u0026#34;driverClass\u0026#34; value=\u0026#34;${driver}\u0026#34; /\u0026gt; \u0026lt;!-- 基本属性 url、user、password --\u0026gt; \u0026lt;property name=\u0026#34;jdbcUrl\u0026#34; value=\u0026#34;${url}\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;user\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${password}\u0026#34; /\u0026gt; \u0026lt;!--c3p0私有属性--\u0026gt; \u0026lt;property name=\u0026#34;maxPoolSize\u0026#34; value=\u0026#34;30\u0026#34;/\u0026gt; \u0026lt;property name=\u0026#34;minPoolSize\u0026#34; value=\u0026#34;10\u0026#34;/\u0026gt; \u0026lt;!--关闭连接后不自动commit--\u0026gt; \u0026lt;property name=\u0026#34;autoCommitOnClose\u0026#34; value=\u0026#34;false\u0026#34;/\u0026gt; \u0026lt;!--获取连接超时时间--\u0026gt; \u0026lt;property name=\u0026#34;checkoutTimeout\u0026#34; value=\u0026#34;1000\u0026#34;/\u0026gt; \u0026lt;!--当获取连接失败重试次数--\u0026gt; \u0026lt;property name=\u0026#34;acquireRetryAttempts\u0026#34; value=\u0026#34;2\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--约定大于配置--\u0026gt; \u0026lt;!--３.配置SqlSessionFactory对象--\u0026gt; \u0026lt;bean id=\u0026#34;sqlSessionFactory\u0026#34; class=\u0026#34;org.mybatis.spring.SqlSessionFactoryBean\u0026#34;\u0026gt; \u0026lt;!--往下才是mybatis和spring真正整合的配置--\u0026gt; \u0026lt;!--注入数据库连接池--\u0026gt; \u0026lt;property name=\u0026#34;dataSource\u0026#34; ref=\u0026#34;dataSource\u0026#34;/\u0026gt; \u0026lt;!--配置mybatis全局配置文件:mybatis-config.xml--\u0026gt; \u0026lt;property name=\u0026#34;configLocation\u0026#34; value=\u0026#34;classpath:mybatis-config.xml\u0026#34;/\u0026gt; \u0026lt;!--扫描entity包,使用别名,多个用;隔开--\u0026gt; \u0026lt;property name=\u0026#34;typeAliasesPackage\u0026#34; value=\u0026#34;com.lewis.entity\u0026#34;/\u0026gt; \u0026lt;!--扫描sql配置文件:mapper需要的xml文件--\u0026gt; \u0026lt;property name=\u0026#34;mapperLocations\u0026#34; value=\u0026#34;classpath:com/lewis/mapper/*.xml\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--４:配置扫描Dao接口包,动态实现DAO接口,注入到spring容器--\u0026gt; \u0026lt;bean class=\u0026#34;org.mybatis.spring.mapper.MapperScannerConfigurer\u0026#34;\u0026gt; \u0026lt;!--注入SqlSessionFactory--\u0026gt; \u0026lt;property name=\u0026#34;sqlSessionFactoryBeanName\u0026#34; value=\u0026#34;sqlSessionFactory\u0026#34;/\u0026gt; \u0026lt;!-- 给出需要扫描的Dao接口--\u0026gt; \u0026lt;property name=\u0026#34;basePackage\u0026#34; value=\u0026#34;com.lewis.dao\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; \u0026lt;!--redisDao--\u0026gt; \u0026lt;!-- \u0026lt;bean id=\u0026#34;redisDao\u0026#34; class=\u0026#34;com.lewis.dao.cache.RedisDao\u0026#34;\u0026gt; \u0026lt;constructor-arg index=\u0026#34;0\u0026#34; value=\u0026#34;localhost\u0026#34;/\u0026gt; \u0026lt;constructor-arg index=\u0026#34;1\u0026#34; value=\u0026#34;6379\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; --\u0026gt; \u0026lt;/beans\u0026gt; 关于数据库连接池的配置可能出现的问题\n在jdbc.properties里使用的是jdbc.username，而不是username或者name，这是因为后两个属性名可能会与全局变量冲突，导致连接的数据库用户名变成了电脑的用户名，所以使用了jdbc.username。\n相关链接\n关于Spring的XML配置文件的头部文件的说明可以参考这篇文章\n3.6 DAO层单元测试 有不知道Eclipse如何直接进行生成快速的测试单元的，可以看看这篇文章\n使用Eclipse工具直接生成测试单元，这些测试代码按照Maven规范放到src/test/java包下。在生成的测试代码里测试我们的方法，测试的具体代码如下：\nSeckillDaoTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 package com.lewis.dao; import static org.junit.Assert.*; import java.util.Date; import java.util.List; import javax.annotation.Resource; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.lewis.entity.Seckill; /** * 配置Spring和Junit整合,junit启动时加载springIOC容器 spring-test,junit */ @RunWith(SpringJUnit4ClassRunner.class) // 告诉junit spring的配置文件 @ContextConfiguration({ \u0026#34;classpath:spring/spring-dao.xml\u0026#34; }) public class SeckillDaoTest { // 注入Dao实现类依赖 @Resource private SeckillDao seckillDao; @Test public void testQueryById() { long seckillId = 1000; Seckill seckill = seckillDao.queryById(seckillId); System.out.println(seckill.getName()); System.out.println(seckill); } @Test public void testQueryAll() { List\u0026lt;Seckill\u0026gt; seckills = seckillDao.queryAll(0, 100); for (Seckill seckill : seckills) { System.out.println(seckill); } } @Test public void testReduceNumber() { long seckillId = 1000; Date date = new Date(); int updateCount = seckillDao.reduceNumber(seckillId, date); System.out.println(updateCount); } } 测试说明\n先左键单击要测试的那个方法名，再右键点击选择Debug As可以单独对该方法进行单元测试。三个方法都测试通过，但是对于最后一个方法会发现数据库中该商品数量并没有减少，这是因为我们设置了秒杀时间，当前时间不满足秒杀时间，所以不会秒杀成功减少数量。\n如果之前没有在DAO接口的多参数方法里在形参前加上@Param注解，那么在这里进行单元测试时，MyBatis会报绑定参数失败的错误，因为无法找到参数。这是因为Java没有保存行参的记录，Java在运行的时候会把queryAll(int offset,int limit)中的参数变成这样queryAll(int arg0,int arg1)，导致MyBatis无法识别这两个参数。\nSuccessKilledDaoTest.java\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 package com.lewis.dao; import static org.junit.Assert.*; import javax.annotation.Resource; import org.junit.Test; import org.junit.runner.RunWith; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit4.SpringJUnit4ClassRunner; import com.lewis.entity.SuccessKilled; @RunWith(SpringJUnit4ClassRunner.class) // 告诉junit spring的配置文件 @ContextConfiguration({ \u0026#34;classpath:spring/spring-dao.xml\u0026#34; }) public class SuccessKilledDaoTest { @Resource private SuccessKilledDao successKilledDao; @Test public void testInsertSuccessKilled() { long seckillId = 1000L; long userPhone = 13476191877L; int insertCount = successKilledDao.insertSuccessKilled(seckillId, userPhone); System.out.println(\u0026#34;insertCount=\u0026#34; + insertCount); } @Test public void testQueryByIdWithSeckill() { long seckillId = 1000L; long userPhone = 13476191877L; SuccessKilled successKilled = successKilledDao.queryByIdWithSeckill(seckillId, userPhone); System.out.println(successKilled); System.out.println(successKilled.getSeckill()); } } 测试说明\n测试方法同上，测试结果通过，另外由于我们使用了联合主键，在insert时使用了ignore关键字，所以对于testInsertSuccessKilled()重复插入同一条数据是无效的，会被过滤掉，确保了一个用户不能重复秒杀同一件商品。\n本节结语\n至此，关于Java高并发秒杀API的DAO层的开发与测试已经完成，接下来进行Service层的开发、测试，详情可以参考Java高并发秒杀API(二)之Service层。\n","permalink":"https://lewky.cn/posts/56225.html/","tags":["项目笔记","SSM实战项目","秒杀"],"title":"Java高并发秒杀API(一)之业务分析与DAO层"},{"categories":["seckill"],"contents":"前言 本文包括了项目的完整流程+开发过程中遇到的各种坑的总结+学习笔记和问题扩展\n项目截图 秒杀列表 秒杀列表\r秒杀详情页 秒杀详情页\r错误提示 错误提示\r开始秒杀 开始秒杀\r秒杀成功 秒杀成功\r重复秒杀 重复秒杀\r秒杀倒计时 秒杀倒计时\r秒杀结束 秒杀结束\r项目介绍 何为秒杀？\n所谓“秒杀”，就是网络卖家发布一些超低价格的商品，所有买家在同一时间网上抢购的一种销售方式。由于商品价格低廉，往往一上架就被抢购一空，有时只用一秒钟。\n为何选择Java高并发秒杀作为实战项目？\n秒杀业务场景具有典型事务特性 秒杀/红包类需求越来越常见 为何使用SpringMVC+Spring+MyBatis框架\n框架易于使用和轻量级 低代码侵入性 成熟的社区和用户群 能从该项目得到什么收获？\n框架的使用和整合技巧 秒杀分析过程与优化思路 项目来源\n这是慕课网上的一个免费项目教学视频，名为Java高并发秒杀API，一共有如下四节课程，附带视频传送门（在视频中老师是用IDEA，本文用的是Eclipse）\nJava高并发秒杀API之业务分析与DAO层 Java高并发秒杀API之Service层 Java高并发秒杀API之Web层 Java高并发秒杀API之高并发优化 相关技术介绍 MySQL\n表设计 SQL技巧 事务和行级锁 MyBatis\nDAO层设计与开发 MyBatis合理使用 与Spring整合 Spring\nSpring IOC整合Service 声明式事务运用 SpringMVC\nRestful借口设计和使用 框架运作流程 Controller开发技巧 前端\n交互设计 Bootstrap jQuery 高并发\n高并发点和高并发分析 优化思路并实现 开发环境 操作系统：Windows 8 IDE工具：Eclipse JDK：JDK1.7 中间件：Tomcat 7.0 数据库：MySQL 5.0 构建工具：Maven 框架：SSM 项目总结 本文根据慕课网的视频教学进行了相应的学习总结，全文较长，分为四节，附带CSDN传送门\nJava高并发秒杀API(一)之业务分析与DAO层 Java高并发秒杀API(二)之Service层 Java高并发秒杀API(三)之Web层 Java高并发秒杀API(四)之高并发优化 项目源码\n源码下载 GitHub地址 ","permalink":"https://lewky.cn/posts/65067.html/","tags":["项目笔记","SSM实战项目","秒杀"],"title":"SSM实战项目 - Java高并发秒杀API"},{"categories":["Maven"],"contents":"Maven的依赖范围 在pom.xml文件中，有个节点是scope，用来表示依赖的范围。之所以会有依赖范围，是因为Maven在编译、测试和运行项目时会各自使用一套classpath，依赖范围就是用来控制这三种classpath的。\n简单来说，就是通过scope节点来控制项目的依赖是在编译时导入，还是在测试或运行项目时才导入。\nscope的值 compile 编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-core，在编译，测试和运行的时候都需要使用该依赖。\nprovided 已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。典型的例子是servlet-api，编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器已经提供，就不需要Maven重复地引入一遍。\nruntime 运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。\ntest 测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效，在编译、运行时无效。典型的例子就是JUnit，它只有在编译测试代码及运行测试的时候才需要。\nsystem 系统依赖范围。该依赖范围与provided所表示的依赖范围一致，对于编译和测试classpath有效，但在运行时无效。只是使用system范围依赖时必须通过systemPath元素显式地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能造成构建的不可移植，因此应该谨慎使用，systemPath元素可以引用环境变量。\nMaven的传递性依赖 什么是传递性依赖 有时候我们在pom.xml文件中引入的依赖，其本身就需要依赖于其他的依赖，这时候我们不需要去考虑这些依赖，Maven会解析各个直接依赖的pom，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。\n通过传递性依赖，我们可以在pom.xml文件中少写不少的依赖配置\n传递性依赖的依赖范围 假如当前项目为A，A依赖于B，B依赖于C。此时称A对于B是第一直接依赖，B对于C是第二直接依赖，而A对于C是传递性依赖。只要知道B在A项目中的scope，就可以知道C在A中的scope。其依赖范围如下：\n表格的第一列是B在A中的依赖范围，第一行是C在B中的依赖范围，交叉的格子是C在A中的依赖范围；下表中的-表示不传递依赖。\ncompile provided test runtime compile compile - - runtime provided provided provided - provided runtime runtime - - runtime test test - - test 总结 当C在B中的scope为test时，A不依赖C，C直接被丢弃 当C在B中的scope为provided时，只有当B在A中的scope也是provided时，A才会依赖C，这时候C在A的scope是provided 当C在B中的scope为compile或runtime时，A依赖C，此时C在A中的scope继承自B在A的scope。注意，如果C的scope是runtime，B的scope是compile，此时C在A的scope是runtime，而不是compile 参考链接 Maven依赖规则和依赖范围 ","permalink":"https://lewky.cn/posts/a658ba27.html/","tags":["Maven"],"title":"Maven - 依赖范围和传递性依赖"},{"categories":null,"contents":"","permalink":"https://lewky.cn/search/","tags":null,"title":"Search [需等待几秒]"}]