<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>Java - 泛型 - Yulin Lewis' Blog</title><meta name=keywords content="雨临Lewis,Java,hugo,hexo,博客"><meta name=Description content="不想当写手的码农不是好咸鱼_(xз」∠)_"><meta property="og:title" content="Java - 泛型"><meta property="og:description" content="泛型（Generic）
泛型：把类型明确的工作推迟到创建对象或调用方法时再明确的特殊类型。
参数化类型：把类型当作参数来传递，这意味着参数化类型不能是基本数据类型，需要用对应的包装类来代替。
相关概念："><meta property="og:type" content="article"><meta property="og:url" content="https://lewky.cn/posts/java-generic.html/"><meta property="og:image" content="https://lewky.cn/logo.png"><meta property="article:published_time" content="2021-05-24T23:35:36+08:00"><meta property="article:modified_time" content="2021-05-24T23:35:36+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://lewky.cn/logo.png"><meta name=twitter:title content="Java - 泛型"><meta name=twitter:description content="泛型（Generic）
泛型：把类型明确的工作推迟到创建对象或调用方法时再明确的特殊类型。
参数化类型：把类型当作参数来传递，这意味着参数化类型不能是基本数据类型，需要用对应的包装类来代替。
相关概念："><meta name=application-name content="雨临Lewis的博客"><meta name=apple-mobile-web-app-title content="雨临Lewis的博客"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://lewky.cn/posts/java-generic.html/><link rel=prev href=https://lewky.cn/posts/plantuml-class-diagram.html/><link rel=next href=https://lewky.cn/posts/hugo-3.1.html/><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Java - 泛型","inLanguage":"","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/lewky.cn\/posts\/java-generic.html\/"},"genre":"posts","keywords":"Java","wordcount":8138,"url":"https:\/\/lewky.cn\/posts\/java-generic.html\/","datePublished":"2021-05-24T23:35:36+08:00","dateModified":"2021-05-24T23:35:36+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"雨临Lewis","logo":"https:\/\/lewky.cn\/images\/avatar.jpg"},"author":{"@type":"Person","name":"雨临Lewis"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem('theme')?localStorage.getItem('theme')==='dark':('auto'==='auto'?window.matchMedia('(prefers-color-scheme: dark)').matches:'auto'==='dark'))&&document.body.setAttribute('theme','dark');</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><a href=https://github.com/lewky class=github-corner target=_blank title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="3.5rem" height="3.5rem" viewBox="0 0 250 250" style="fill:#70b7fd;color:#fff;position:absolute;top:0;border:0;left:0;transform:scale(-1,1)" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4L133.7 101.6C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><div class=header-title><a href=/ title="Yulin Lewis' Blog"><span class=header-title-pre><i class="fas fa-fw fa-atom"></i></span>雨临Lewis</a></div><div class=menu><div class=menu-inner><div class=dropdown><a href=/posts/ class="menu-item menu-more dropbtn"><i class="fas fa-fw fa-archive"></i>归档</a><div class="menu-more-content dropdown-content"><a href=/categories/><i class="fas fa-fw fa-th"></i>分类 </a><a href=/tags/><i class="fas fa-fw fa-tag"></i>标签 </a><a href=/hot/ title=文章热度Top15><i class="fas fa-fw fa-fire"></i>热度 </a><a href=/posts/d65a1577.html/ title=密码是123><i class="fas fa-fw fa-pen-nib"></i>随笔 </a><a href=/about/><i class="fas fa-fw fa-at"></i>关于</a></div></div><a class=menu-item href=/friends/><i class="fas fa-fw fa-link"></i>友链</a><div class=dropdown><a href=javascript:void(0); class="menu-item menu-more dropbtn"><i class="fas fa-fw fa-fan fa-spin"></i>趣味</a><div class="menu-more-content dropdown-content"><a href=/funny/high/ title="前方高能♂ 小心外放！" target=_blank rel=noopener><i class="fas fa-fw fa-dizzy"></i>燥起来！ </a><a href=/funny/mikutap/ title=初音未来音乐游戏 target=_blank rel=noopener><i class="fas fa-fw fa-music"></i>在线打碟 </a><a href=/funny/catch-the-cat/ title=逮住那只猫!><i class="fas fa-fw fa-cat"></i>抓住猫咪</a></div></div><div class=dropdown><a href=/ class="menu-item menu-more dropbtn" title=回到首页><i class="fas fa-fw fa-atom"></i>站点</a><div class="menu-more-content dropdown-content"><a href=/bbs/ title=来留言吧~><i class="fas fa-fw fa-comment"></i>公告留言 </a><a href=https://seo.chinaz.com target=_blank rel=noopener><i class="fas fa-fw fa-chart-line"></i>SEO查询 </a><a href=https://www.ping.cn/http/lewky.cn target=_blank rel=noopener><i class="fas fa-fw fa-bezier-curve"></i>网站测速 </a><a href=/posts/e62c38c4.html/><i class="fas fa-fw fa-cog fa-spin"></i>建站日志</a></div></div><div class=dropdown><a href=javascript:void(0); class="menu-item menu-more dropbtn"><i class="fas fa-fw fa-book"></i>文档</a><div class="menu-more-content dropdown-content"><a href=https://gohugo.io/documentation/ target=_blank rel=noopener><i class="fas fa-fw fa-star"></i>Hugo文档 </a><a href=https://javanote.doc.lewky.cn/ title=尚在完善中~ target=_blank rel=noopener><i class="fab fa-fw fa-java"></i>Java 笔记</a></div></div><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i>搜索
</a><span class="menu-item delimiter"></span><a href=https://travellings.link target=_blank class=menu-item rel=noopener title=开往-友链接力><i class="fas fa-fw fa-subway"></i></a><a href=https://rssblog.vercel.app/ class=menu-item target=_blank rel=noopener title=RSSBlog><i class="fas fa-fw fa-inbox"></i></a><a href=https://github.com/lewky class=menu-item target=_blank rel=noopener title=GitHub><i class="fab fa-fw fa-github"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Yulin Lewis' Blog"><span class=header-title-pre><i class="fas fa-fw fa-atom"></i></span>雨临Lewis</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=dropdown><a href=/posts/ class="menu-item menu-more dropbtn"><i class="fas fa-fw fa-archive"></i>归档</a><div class="menu-more-content dropdown-content"><a href=/categories/><i class="fas fa-fw fa-th"></i>分类 </a><a href=/tags/><i class="fas fa-fw fa-tag"></i>标签 </a><a href=/hot/ title=文章热度Top15><i class="fas fa-fw fa-fire"></i>热度 </a><a href=/posts/d65a1577.html/ title=密码是123><i class="fas fa-fw fa-pen-nib"></i>随笔 </a><a href=/about/><i class="fas fa-fw fa-at"></i>关于</a></div></div><a class=menu-item href=/friends/><i class="fas fa-fw fa-link"></i>友链</a><div class=dropdown><a href=javascript:void(0); class="menu-item menu-more dropbtn"><i class="fas fa-fw fa-fan fa-spin"></i>趣味</a><div class="menu-more-content dropdown-content"><a href=/funny/high/ title="前方高能♂ 小心外放！" target=_blank rel=noopener><i class="fas fa-fw fa-dizzy"></i>燥起来！ </a><a href=/funny/mikutap/ title=初音未来音乐游戏 target=_blank rel=noopener><i class="fas fa-fw fa-music"></i>在线打碟 </a><a href=/funny/catch-the-cat/ title=逮住那只猫!><i class="fas fa-fw fa-cat"></i>抓住猫咪</a></div></div><div class=dropdown><a href=/ class="menu-item menu-more dropbtn" title=回到首页><i class="fas fa-fw fa-atom"></i>站点</a><div class="menu-more-content dropdown-content"><a href=/bbs/ title=来留言吧~><i class="fas fa-fw fa-comment"></i>公告留言 </a><a href=https://seo.chinaz.com target=_blank rel=noopener><i class="fas fa-fw fa-chart-line"></i>SEO查询 </a><a href=https://www.ping.cn/http/lewky.cn target=_blank rel=noopener><i class="fas fa-fw fa-bezier-curve"></i>网站测速 </a><a href=/posts/e62c38c4.html/><i class="fas fa-fw fa-cog fa-spin"></i>建站日志</a></div></div><div class=dropdown><a href=javascript:void(0); class="menu-item menu-more dropbtn"><i class="fas fa-fw fa-book"></i>文档</a><div class="menu-more-content dropdown-content"><a href=https://gohugo.io/documentation/ target=_blank rel=noopener><i class="fas fa-fw fa-star"></i>Hugo文档 </a><a href=https://javanote.doc.lewky.cn/ title=尚在完善中~ target=_blank rel=noopener><i class="fab fa-fw fa-java"></i>Java 笔记</a></div></div><a class=menu-item href=/search/><i class="fas fa-fw fa-search"></i>搜索</a>
<a href=https://travellings.link target=_blank class=menu-item rel=noopener title=开往-友链接力><i class="fas fa-fw fa-subway"></i></a><a href=https://rssblog.vercel.app/ class=menu-item target=_blank rel=noopener title=RSSBlog><i class="fas fa-fw fa-inbox"></i></a><a href=https://github.com/lewky class=menu-item target=_blank rel=noopener title=GitHub><i class="fab fa-fw fa-github"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">Java - 泛型</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>雨临Lewis</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/java/><i class="far fa-folder fa-fw"></i>Java</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2021-05-24>2021-05-24</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 8138 字
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 17 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ol><li><a href=#泛型generic>泛型（Generic）</a></li><li><a href=#泛型的好处>泛型的好处</a></li><li><a href=#泛型类泛型方法>泛型类、泛型方法</a></li><li><a href=#泛型原理类型擦除>泛型原理：类型擦除</a></li><li><a href=#泛型擦除导致的多态冲突>泛型擦除导致的多态冲突</a></li><li><a href=#泛型与反射>泛型与反射</a></li><li><a href=#泛型集合>泛型集合</a></li><li><a href=#泛型通配符>泛型通配符</a><ol><li><a href=#无界通配符>无界通配符<code>&lt;?></code></a></li><li><a href=#上界通配符-extends-t>上界通配符<code>&lt;? extends T></code></a></li><li><a href=#下界通配符-super-t>下界通配符<code>&lt;? super T></code></a></li><li><a href=#pecs原则>PECS原则</a></li><li><a href=#泛型的多重限定>泛型的多重限定</a></li><li><a href=#t和的区别><code>&lt;T></code>和<code>&lt;?></code>的区别</a></li></ol></li><li><a href=#泛型数组>泛型数组</a></li><li><a href=#不能使用泛型的场景>不能使用泛型的场景</a><ol><li><a href=#基本类型不能使用泛型>基本类型不能使用泛型</a></li><li><a href=#泛型类型无法直接实例化>泛型类型无法直接实例化</a></li><li><a href=#泛型类的泛型参数不能作为静态变量也不能作为静态方法的返回值>泛型类的泛型参数不能作为静态变量，也不能作为静态方法的返回值</a></li><li><a href=#无法进行-instanceof-判断>无法进行 instanceof 判断</a></li><li><a href=#无法创建参数化类型的数组>无法创建参数化类型的数组</a></li><li><a href=#不能直接或者间接扩展throwable>不能直接或者间接扩展Throwable</a></li><li><a href=#泛型擦除后相同参数签名的方法不能重载>泛型擦除后相同参数签名的方法不能重载</a></li></ol></li><li><a href=#一道笔试题>一道笔试题</a></li><li><a href=#参考链接>参考链接</a></li></ol></nav></div></div><div class=content id=content><h2 id=泛型generic>泛型（Generic）</h2><p>泛型：把类型明确的工作推迟到创建对象或调用方法时再明确的特殊类型。</p><p>参数化类型：把类型当作参数来传递，这意味着参数化类型不能是基本数据类型，需要用对应的包装类来代替。</p><p>相关概念：</p><p>● <code>ArrayList&lt;E></code>中的<code>E</code>是类型参数变量（typeVariable，也叫泛型参数），除了E之外，也可以是任意标识符。其实就是一个变量名，常用的一般有<code>E（Element）、T（Type）、K（Key）、V（Value）</code>等。<br>● <code>ArrayList&lt;Integer></code>中的<code>Integer</code>称为实际类型参数（ActualTypeArgument），上面的<code>E</code>相当于形参，这里的<code>Integer</code>相当于实参<br>● <code>ArrayList&lt;E></code>整个被称为泛型类型（泛型类，GenericType）<br>● <code>ArrayList&lt;Integer></code>整个被称为参数化的类型（ParameterizedType）<br>● <code>ArrayList</code>被称为原生类型（RawType）<br>● 泛型类中允许定义泛型内部类，那么外部泛型类的原生类型，被称为内部泛型类的拥有者类型（OwnerType)</p><h2 id=泛型的好处>泛型的好处</h2><p>● 泛型的本质是为了参数化类型，在不创建新类型的情况下，通过泛型指定的不同类型来限制形参的具体类型，以此提高代码的复用性。<br>● 安全性。泛型可以在编译时检查类型安全，避免在运行时发生类转换异常ClassCastException。<br>● 可读性，代码更加简洁。泛型会进行隐式类型转换，比如在使用集合时，无需进行强制类型转换。比如遍历一个指定了泛型的集合时，就可以用增强for来进行遍历。</p><h2 id=泛型类泛型方法>泛型类、泛型方法</h2><p>只有声明了泛型参数的类才是泛型类（泛型接口同理），只有声明了泛型参数的方法才是泛型方法。也就是说，泛型类中使用了泛型的方法并不是泛型方法，<strong>泛型类声明的泛型参数和泛型方法声明的泛型参数可以重名，但是二者并不存在任何关系。</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 泛型类
</span><span class=c1></span><span class=kd>class</span> <span class=nc>TestGeneric</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=c1>// 不是泛型方法
</span><span class=c1></span>    <span class=kd>public</span> <span class=n>T</span> <span class=nf>getT1</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>
    
    <span class=c1>// 泛型方法，这里的T和泛型类的T完全没有关系
</span><span class=c1></span>    <span class=kd>public</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>T</span> <span class=nf>getT2</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>

<span class=o>}</span>

<span class=c1>// 不是泛型类
</span><span class=c1></span><span class=kd>class</span> <span class=nc>TestGeneric2</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=c1>// 不是泛型方法
</span><span class=c1></span>    <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>getT1</span><span class=o>(</span><span class=n>Integer</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>
    
	<span class=c1>// 泛型方法
</span><span class=c1></span>    <span class=kd>public</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>T</span> <span class=nf>getT2</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>

<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>泛型是在类实例化或者方法调用时才明确类型的：</p><p>● 对于泛型类的泛型参数，需要在类实例化时才能明确类型；<br>● 对于泛型方法的泛型参数，需要在方法调用时才能明确类型。</p><p>如果要继承泛型类，写法如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 定义一个泛型类
</span><span class=c1></span><span class=kd>class</span> <span class=nc>TestGeneric</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>

<span class=o>}</span>

<span class=c1>// 定义一个参数化类型
</span><span class=c1></span><span class=kd>class</span> <span class=nc>TestChild</span> <span class=kd>extends</span> <span class=n>TestGeneric</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>

<span class=o>}</span>

<span class=c1>// 定义一个泛型类子类，子类必须声明泛型参数，否则编译报错
</span><span class=c1></span><span class=kd>class</span> <span class=nc>TestChild2</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>TestGeneric</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>

<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>实现泛型接口的写法也是同理。</p><h2 id=泛型原理类型擦除>泛型原理：类型擦除</h2><p>Java的泛型是伪泛型。泛型是提供给javac编译器使用的，在编译期间，泛型信息会被擦除掉，生成的class文件中将不再带有泛型信息。但是泛型擦除并不是完全擦除掉所有的泛型信息，参数化类型的泛型信息（相当于元数据）会被保留下来，可以通过反射获取到。</p><ul><li><a href=https://blog.csdn.net/huluwaaaa/article/details/102699494 target=_blank rel="noopener noreffer">Java的泛型擦除留下了什么？</a></li></ul><p>Java是向前兼容的，泛型在Java5引入，需要兼容Java5之前的版本，这也是Java泛型需要类型擦除的原因之一。</p><p>在编译期，<code>ArrayList&lt;Integer></code>和<code>ArrayList</code>对于编译器是两个不同的类型；但是经过了泛型擦除后，在运行期，对于JVM来说就是一样的类型。此外，编译期会在使用泛型的地方自动生成类型转换的字节码，所以在使用泛型时无需进行强制类型转换。</p><h2 id=泛型擦除导致的多态冲突>泛型擦除导致的多态冲突</h2><p>由于泛型擦除，会导致运行期的多态冲突。如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>TestGeneric</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=kd>public</span> <span class=n>T</span> <span class=nf>test</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>

<span class=kd>class</span> <span class=nc>TestChild</span> <span class=kd>extends</span> <span class=n>TestGeneric</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>test</span><span class=o>(</span><span class=n>Integer</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p><code>@Override</code>表明子类重写了父类的方法，但实际上，经过泛型擦除之后，父类的<code>test方法</code>变成如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=n>Object</span> <span class=nf>test</span><span class=o>(</span><span class=n>Object</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
    <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>如果是在非泛型类的继承关系中，其实这样并不是子类重写了父类的方法，而是子类重载了这个<code>test方法</code>。如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>Animal</span> <span class=o>{</span>
    
    <span class=kd>public</span> <span class=n>Object</span> <span class=nf>test</span><span class=o>(</span><span class=n>Object</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>

<span class=o>}</span>

<span class=kd>class</span> <span class=nc>Cat</span> <span class=kd>extends</span> <span class=n>Animal</span> <span class=o>{</span>
    
    <span class=c1>// 编译出错，编译器认为这是方法重载而非重写，不能使用@Override
</span><span class=c1></span>    <span class=nd>@Override</span>
    <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>test</span><span class=o>(</span><span class=n>Integer</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>    <span class=c1>// The method test(Integer) of type Cat must override or implement a supertype method
</span><span class=c1></span>        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>本意是想要重写父类方法，结果经过泛型擦除后实际上是方法重载。为了解决这个泛型擦除在继承关系中带来的多态冲突，编译器在生成泛型类子类的字节码时会生成桥方法（Bridge Method），用以桥接原来的方法。如果去看泛型类的子类字节码文件，会发现每一个使用了泛型的被重写的父类方法都多出来一个对应的被<code>bridge</code>修饰的桥方法。</p><p>对于上述的<code>TestChild</code>类，经过编译之后相当于变成如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java>
<span class=kd>class</span> <span class=nc>TestChild</span> <span class=kd>extends</span> <span class=n>TestGeneric</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>

	<span class=c1>// 原本的@Override注解被移除，实际上是方法重载
</span><span class=c1></span>    <span class=kd>public</span> <span class=n>Integer</span> <span class=nf>test</span><span class=o>(</span><span class=n>Integer</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>

	<span class=c1>// 编译器生成的桥方法，重写了父类的方法，并直接调用子类里重载的方法
</span><span class=c1></span>	<span class=c1>// 这样就可以实现泛型类在继承体系中的运行时多态
</span><span class=c1></span>	<span class=kd>public</span> <span class=n>Object</span> <span class=nf>test</span><span class=o>(</span><span class=n>Object</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>test</span><span class=o>((</span><span class=n>Integer</span><span class=o>)</span><span class=n>t</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><ul><li><a href=https://blog.csdn.net/hao_yan_bing/article/details/89447792 target=_blank rel="noopener noreffer">Java泛型中的桥方法(Bridge Method)</a></li></ul><h2 id=泛型与反射>泛型与反射</h2><p>泛型的类型检查只是在编译期生效，所以可以在运行期通过反射往一个泛型集合中加入限制类型以外的元素。</p><p>由于泛型擦除的原因，虽然无法在运行期通过反射动态获取一个泛型类的实际类型，但依然可以用反射来获取参数化类型的泛型信息。<strong>注意，泛型类和参数化类型不是一个东西。</strong></p><ul><li><a href=https://www.zhihu.com/question/346911525/answer/830285753 target=_blank rel="noopener noreffer">Java中的泛型会被类型擦除，那为什么在运行期仍然可以使用反射获取到具体的泛型类型？</a></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>TestGeneric</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=kd>public</span> <span class=n>TestInner</span> <span class=n>child</span><span class=o>;</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=kd>final</span> <span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=kd>final</span> <span class=n>TestChild</span> <span class=n>testChild</span> <span class=o>=</span> <span class=k>new</span> <span class=n>TestChild</span><span class=o>();</span>
        <span class=n>testChild</span><span class=o>.</span><span class=na>child</span> <span class=o>=</span> <span class=n>testChild</span><span class=o>.</span><span class=na>new</span> <span class=nf>TestInner</span><span class=o>();</span>
        <span class=n>testChild</span><span class=o>.</span><span class=na>getArray</span><span class=o>(</span><span class=n>testChild</span><span class=o>,</span> <span class=n>3</span><span class=o>);</span>
        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;===============================&#34;</span><span class=o>);</span>
        <span class=n>testChild</span><span class=o>.</span><span class=na>getArray</span><span class=o>(</span><span class=n>testChild</span><span class=o>.</span><span class=na>child</span><span class=o>,</span> <span class=n>3</span><span class=o>);</span>
    <span class=o>}</span>

    <span class=kd>class</span> <span class=nc>InnerGeneric</span><span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=o>}</span>

    <span class=kd>class</span> <span class=nc>TestInner</span> <span class=kd>extends</span> <span class=n>InnerGeneric</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=o>}</span>

<span class=o>}</span>

<span class=kd>class</span> <span class=nc>TestChild</span> <span class=kd>extends</span> <span class=n>TestGeneric</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=kd>public</span> <span class=n>Integer</span><span class=o>[]</span> <span class=nf>getArray</span><span class=o>(</span><span class=kd>final</span> <span class=n>Object</span> <span class=n>obj</span><span class=o>,</span> <span class=kd>final</span> <span class=kt>int</span> <span class=n>length</span><span class=o>)</span> <span class=o>{</span>
      <span class=kd>final</span> <span class=n>ParameterizedType</span> <span class=n>type</span> <span class=o>=</span> <span class=o>(</span><span class=n>ParameterizedType</span><span class=o>)</span> <span class=n>obj</span><span class=o>.</span><span class=na>getClass</span><span class=o>().</span><span class=na>getGenericSuperclass</span><span class=o>();</span>
      <span class=kd>final</span> <span class=n>Class</span> <span class=o>&lt;?&gt;</span> <span class=n>clazz</span> <span class=o>=</span> <span class=o>(</span><span class=n>Class</span> <span class=o>&lt;?&gt;)</span> <span class=n>type</span><span class=o>.</span><span class=na>getActualTypeArguments</span><span class=o>()[</span><span class=n>0</span><span class=o>];</span>
      <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;Class: &#34;</span> <span class=o>+</span> <span class=n>obj</span><span class=o>.</span><span class=na>getClass</span><span class=o>().</span><span class=na>getName</span><span class=o>());</span>
      <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;ParameterizedType: &#34;</span> <span class=o>+</span> <span class=n>type</span><span class=o>.</span><span class=na>getTypeName</span><span class=o>());</span>
      <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;RawType: &#34;</span> <span class=o>+</span> <span class=n>type</span><span class=o>.</span><span class=na>getRawType</span><span class=o>());</span>
      <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;OwnerType: &#34;</span> <span class=o>+</span> <span class=n>type</span><span class=o>.</span><span class=na>getOwnerType</span><span class=o>());</span>
      <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;ActualTypeArguments&#39; number: &#34;</span> <span class=o>+</span> <span class=n>type</span><span class=o>.</span><span class=na>getActualTypeArguments</span><span class=o>().</span><span class=na>length</span><span class=o>);</span>
      <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=s>&#34;ActualTypeArgument Class: &#34;</span> <span class=o>+</span> <span class=n>clazz</span><span class=o>.</span><span class=na>getName</span><span class=o>());</span>
      <span class=k>return</span> <span class=o>(</span><span class=n>Integer</span><span class=o>[])</span><span class=n>Array</span><span class=o>.</span><span class=na>newInstance</span><span class=o>(</span><span class=n>clazz</span><span class=o>,</span> <span class=n>length</span><span class=o>);</span>
  <span class=o>}</span>

<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>运行结果如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=nl>Class:</span> <span class=n>test</span><span class=o>.</span><span class=na>TestChild</span>
<span class=nl>ParameterizedType:</span> <span class=n>test</span><span class=o>.</span><span class=na>TestGeneric</span><span class=o>&lt;</span><span class=n>java</span><span class=o>.</span><span class=na>lang</span><span class=o>.</span><span class=na>Integer</span><span class=o>&gt;</span>
<span class=nl>RawType:</span> <span class=kd>class</span> <span class=nc>test</span><span class=o>.</span><span class=na>TestGeneric</span>
<span class=nl>OwnerType:</span> <span class=kc>null</span>
<span class=n>ActualTypeArguments</span><span class=err>&#39;</span> <span class=n>number</span><span class=o>:</span> <span class=n>1</span>
<span class=n>ActualTypeArgument</span> <span class=n>Class</span><span class=o>:</span> <span class=n>java</span><span class=o>.</span><span class=na>lang</span><span class=o>.</span><span class=na>Integer</span>
<span class=o>===============================</span>
<span class=nl>Class:</span> <span class=n>test</span><span class=o>.</span><span class=na>TestGeneric$TestInner</span>
<span class=nl>ParameterizedType:</span> <span class=n>test</span><span class=o>.</span><span class=na>TestGeneric</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;.</span><span class=na>InnerGeneric</span><span class=o>&lt;</span><span class=n>java</span><span class=o>.</span><span class=na>lang</span><span class=o>.</span><span class=na>Integer</span><span class=o>&gt;</span>
<span class=nl>RawType:</span> <span class=kd>class</span> <span class=nc>test</span><span class=o>.</span><span class=na>TestGeneric$InnerGeneric</span>
<span class=nl>OwnerType:</span> <span class=n>test</span><span class=o>.</span><span class=na>TestGeneric</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span>
<span class=n>ActualTypeArguments</span><span class=err>&#39;</span> <span class=n>number</span><span class=o>:</span> <span class=n>1</span>
<span class=n>ActualTypeArgument</span> <span class=n>Class</span><span class=o>:</span> <span class=n>java</span><span class=o>.</span><span class=na>lang</span><span class=o>.</span><span class=na>Integer</span>
</code></pre></td></tr></table></div></div><p>如果理解了前文提及的相关概念，那么自然也能理解这些泛型反射的方法。</p><h2 id=泛型集合>泛型集合</h2><p>泛型经常被用于集合，一个泛型集合不允许被加入指定类型以外的对象：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>List</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Dog</span><span class=o>());</span>

    <span class=c1>// 编译错误，不能添加指定类型以外的对象
</span><span class=c1></span>    <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Cat</span><span class=o>());</span>  <span class=c1>// The method add(Dog) in the type List&lt;Dog&gt; is not applicable for the arguments (Cat)
</span><span class=c1></span>
    <span class=n>Animal</span> <span class=n>animal</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Dog</span><span class=o>();</span>
    <span class=c1>// 编译错误，虽然Animal是Dog的父类型，但依然不能添加进去集合里，因为Animal类型不一定能安全地转型为Dog类型。
</span><span class=c1></span>    <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>animal</span><span class=o>);</span>  <span class=c1>// The method add(Dog) in the type List&lt;Dog&gt; is not applicable for the arguments (Animal)
</span><span class=c1></span>
    <span class=n>BigDog</span> <span class=n>bigDog</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BigDog</span><span class=o>();</span>
    <span class=c1>// 因为BigDog是Dog的子类型，一定可以转型为Dog类型，所以允许加入集合
</span><span class=c1></span>    <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=n>bigDog</span><span class=o>);</span>  <span class=c1>// ok
</span><span class=c1></span><span class=o>}</span>
</code></pre></td></tr></table></div></div><p>因为泛型集合在读取元素或者添加元素时，会有类型转换操作（在源码底层里进行的强制类型转换），如果不能把一个元素安全地进行类型转换，那就不能被添加到集合中。</p><p>此外，作用于编译期的类型检查是针对于引用类型的，跟引用类型指向的实际对象并无关系。如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=o>{</span>
    <span class=c1>// 指向一个泛型集合
</span><span class=c1></span>    <span class=n>List</span> <span class=n>list1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;();</span>
    <span class=n>list1</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Cat</span><span class=o>());</span>  <span class=c1>// ok
</span><span class=c1></span>
    <span class=c1>// 指向一个非泛型集合
</span><span class=c1></span>    <span class=n>List</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span> <span class=n>list2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>();</span>
    <span class=c1>// 编译错误
</span><span class=c1></span>    <span class=n>list2</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Cat</span><span class=o>());</span>  <span class=c1>// The method add(Dog) in the type List&lt;Dog&gt; is not applicable for the arguments (Cat)
</span><span class=c1></span>
    <span class=c1>// 指向一个泛型集合
</span><span class=c1></span>    <span class=n>List</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span> <span class=n>list3</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
    <span class=c1>// 编译错误
</span><span class=c1></span>    <span class=n>list3</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Cat</span><span class=o>());</span>  <span class=c1>// The method add(Dog) in the type List&lt;Dog&gt; is not applicable for the arguments (Cat)
</span><span class=c1></span><span class=o>}</span>
</code></pre></td></tr></table></div></div><h2 id=泛型通配符>泛型通配符</h2><p>泛型参数除了可以是Java标识符之外，还可以指定为<code>?</code>无界通配符，用以表示不确定的Java类型。</p><p><strong>但是<code>?</code>不可用于声明泛型，只能用于使用泛型的场合</strong>。因为<code>?</code>并不是合法的Java标识符，不可用于声明，只能作为实际类型参数来使用，效果相当于Object。通配符类型同样无法实例化。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 不能用通配符声明泛型类
</span><span class=c1></span><span class=kd>class</span> <span class=nc>TestGeneric</span><span class=o>&lt;?&gt;</span> <span class=o>{</span>  <span class=c1>// Syntax error on token &#34;?&#34;, Identifier expected
</span><span class=c1></span>
    <span class=c1>// 不能用通配符声明泛型方法
</span><span class=c1></span>    <span class=kd>public</span> <span class=o>&lt;?&gt;</span> <span class=kt>void</span> <span class=nf>test1</span><span class=o>(</span><span class=kd>final</span> <span class=o>?</span> <span class=n>test</span><span class=o>)</span> <span class=o>{</span>  <span class=c1>// Syntax error on token &#34;?&#34;, byte expected
</span><span class=c1></span>
    <span class=o>}</span>
    
    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test2</span><span class=o>(</span><span class=kd>final</span> <span class=n>List</span><span class=o>&lt;?&gt;</span> <span class=n>test</span><span class=o>)</span> <span class=o>{</span>  <span class=c1>// ok
</span><span class=c1></span>        <span class=c1>// 不能实例化
</span><span class=c1></span>        <span class=o>?</span> <span class=n>obj</span> <span class=o>=</span> <span class=k>new</span> <span class=o>?();</span>  <span class=c1>// Syntax error on token &#34;?&#34;, invalid ClassType
</span><span class=c1></span>		<span class=c1>// 不能实例化
</span><span class=c1></span>		<span class=n>List</span><span class=o>&lt;?&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;?&gt;();</span>  <span class=c1>// Cannot instantiate the type ArrayList&lt;?&gt;
</span><span class=c1></span>    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><h3 id=无界通配符>无界通配符<code>&lt;?></code></h3><p>泛型使用最多的场景是集合，然而对于泛型集合来说，每个集合之间都是完全独立的：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>Animal</span> <span class=o>{}</span>

<span class=kd>class</span> <span class=nc>Cat</span> <span class=kd>extends</span> <span class=n>Animal</span> <span class=o>{}</span>

<span class=kd>class</span> <span class=nc>Dog</span> <span class=kd>extends</span> <span class=n>Animal</span> <span class=o>{}</span>

<span class=kd>class</span> <span class=nc>BigDog</span> <span class=kd>extends</span> <span class=n>Dog</span> <span class=o>{}</span>

<span class=kd>class</span> <span class=nc>TestGeneric</span> <span class=o>{</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=kd>final</span> <span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>List</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span> <span class=n>dogs</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=n>List</span><span class=o>&lt;</span><span class=n>Animal</span><span class=o>&gt;</span> <span class=n>animals</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=c1>// 编译错误
</span><span class=c1></span>        <span class=n>dogs</span> <span class=o>=</span> <span class=n>animals</span><span class=o>;</span> <span class=c1>// Type mismatch: cannot convert from List&lt;Animal&gt; to List&lt;Dog&gt;
</span><span class=c1></span>        <span class=c1>// 编译错误
</span><span class=c1></span>        <span class=n>animals</span> <span class=o>=</span> <span class=n>dogs</span><span class=o>;</span> <span class=c1>// Type mismatch: cannot convert from List&lt;Dog&gt; to List&lt;Animal&gt;
</span><span class=c1></span>        
		<span class=c1>// 在运行期这两个泛型集合的类型是同一个类对象
</span><span class=c1></span>        <span class=n>System</span><span class=o>.</span><span class=na>out</span><span class=o>.</span><span class=na>println</span><span class=o>(</span><span class=n>dogs</span><span class=o>.</span><span class=na>getClass</span><span class=o>()</span> <span class=o>==</span> <span class=n>animals</span><span class=o>.</span><span class=na>getClass</span><span class=o>());</span>  <span class=c1>// true
</span><span class=c1></span>        
        <span class=c1>// 不能添加Animal对象
</span><span class=c1></span>        <span class=n>dogs</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Animal</span><span class=o>());</span>  <span class=c1>// The method add(Dog) in the type List&lt;Dog&gt; is not applicable for the arguments (Animal)
</span><span class=c1></span>        <span class=n>dogs</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Dog</span><span class=o>());</span>  <span class=c1>// ok
</span><span class=c1></span>        
        <span class=n>animals</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Animal</span><span class=o>());</span>  <span class=c1>// ok
</span><span class=c1></span>        <span class=n>animals</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Dog</span><span class=o>());</span>  <span class=c1>// ok
</span><span class=c1></span>    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>可以看到，虽然<code>Dog</code>是<code>Animal</code>的子类，但是<code>List&lt;Animal></code>和<code>List&lt;Dog></code>这两个集合之间并不存在任何关系，不能把一个<code>List&lt;Dog></code>对象直接赋值给一个<code>List&lt;Animal></code>引用。于是这就会引发一个问题，如果一个方法的参数是泛型集合，就很容易出现类型不匹配的情况。为了避免这种情况，也更有利于代码的复用和简洁，就有了无界通配符<code>&lt;?></code>，如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>TestGeneric</span> <span class=o>{</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>test1</span><span class=o>(</span><span class=kd>final</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>Animal</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
        
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>test2</span><span class=o>(</span><span class=kd>final</span> <span class=n>List</span><span class=o>&lt;?&gt;</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
        
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=kd>final</span> <span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>List</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span> <span class=n>dogs</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=n>List</span><span class=o>&lt;</span><span class=n>Animal</span><span class=o>&gt;</span> <span class=n>animals</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=n>List</span><span class=o>&lt;?&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>

        <span class=c1>// 编译错误，无法调用
</span><span class=c1></span>        <span class=n>test1</span><span class=o>(</span><span class=n>dogs</span><span class=o>);</span>    <span class=c1>// The method test1(List&lt;Animal&gt;) in the type TestGeneric is not applicable for the arguments (List&lt;Dog&gt;)
</span><span class=c1></span>        <span class=n>test1</span><span class=o>(</span><span class=n>animals</span><span class=o>);</span> <span class=c1>// ok
</span><span class=c1></span>        <span class=c1>// 编译错误，无法调用
</span><span class=c1></span>        <span class=n>test1</span><span class=o>(</span><span class=n>list</span><span class=o>);</span>    <span class=c1>// The method test1(List&lt;Animal&gt;) in the type TestGeneric is not applicable for the arguments (List&lt;capture#2-of ?&gt;)
</span><span class=c1></span>        
        <span class=n>test2</span><span class=o>(</span><span class=n>dogs</span><span class=o>);</span>    <span class=c1>// ok
</span><span class=c1></span>        <span class=n>test2</span><span class=o>(</span><span class=n>animals</span><span class=o>);</span> <span class=c1>// ok
</span><span class=c1></span>        <span class=n>test2</span><span class=o>(</span><span class=n>list</span><span class=o>);</span>    <span class=c1>// ok
</span><span class=c1></span>
        <span class=n>dogs</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Dog</span><span class=o>());</span>	<span class=c1>// ok
</span><span class=c1></span>        <span class=c1>// 编译错误
</span><span class=c1></span>        <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Animal</span><span class=o>());</span> <span class=c1>// The method add(capture#2-of ?) in the type List&lt;capture#2-of ?&gt; is not applicable for the arguments (Animal)
</span><span class=c1></span>        <span class=c1>// 编译错误
</span><span class=c1></span>        <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Dog</span><span class=o>());</span>   <span class=c1>// The method add(capture#3-of ?) in the type List&lt;capture#3-of ?&gt; is not applicable for the arguments (Dog)
</span><span class=c1></span>        <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=kc>null</span><span class=o>);</span> <span class=c1>// ok
</span><span class=c1></span>
        <span class=n>list</span> <span class=o>=</span> <span class=n>dogs</span><span class=o>;</span>
        <span class=c1>// 将泛型通配符集合赋值为普通的泛型集合后，依然不能添加null以外的元素
</span><span class=c1></span>        <span class=n>list</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Dog</span><span class=o>());</span>   <span class=c1>// The method add(capture#6-of ?) in the type List&lt;capture#6-of ?&gt; is not applicable for the arguments (Dog)
</span><span class=c1></span>
		<span class=c1>// 泛型通配符集合中读取的元素为Object类型
</span><span class=c1></span>        <span class=n>Object</span> <span class=n>object</span> <span class=o>=</span> <span class=n>list</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>);</span>
		<span class=c1>// 将读取的元素强转为原本的类型
</span><span class=c1></span>        <span class=n>Dog</span> <span class=n>dog</span> <span class=o>=</span> <span class=o>(</span><span class=n>Dog</span><span class=o>)</span> <span class=n>list</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>);</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>可以发现，泛型通配符集合虽然被任意的泛型集合对象所赋值，但是却不能往这个集合里添加null以外的任何元素，只能读取这个集合的元素，并且被读取的元素都是Object类型。</p><p>这是因为经过泛型擦除后，通配符被擦除成了Object类型。也就是说，可以把一个无界通配符<code>&lt;?></code>看成是上界通配符<code>&lt;? extends Object></code>。</p><h3 id=上界通配符-extends-t>上界通配符<code>&lt;? extends T></code></h3><p>使用上界通配符可以将实际类型参数限制为指定的类型或者指定类型的子类，经过泛型擦除后，上界通配符被擦除成了指定的类型，即泛型擦除会保留上界。</p><p>需要注意的是，这里的上界虽然用了<code>extends</code>关键字，但实际上和类的继承不太一样。对于泛型来说，<code>extends</code>之后的具体类型可以是类，也可以是接口。（也就是说如果上界指定的是一个接口，也必须用<code>extends</code>关键字，而不是<code>implements</code>）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>List</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>Serializable</span><span class=o>&gt;</span> <span class=n>list1</span><span class=o>;</span>  <span class=c1>// ok
</span><span class=c1></span>    <span class=c1>// 编译错误
</span><span class=c1></span>    <span class=n>List</span><span class=o>&lt;?</span> <span class=kd>implements</span> <span class=n>Serializable</span><span class=o>&gt;</span> <span class=n>list2</span><span class=o>;</span>  <span class=c1>// Incorrect number of arguments for type List&lt;E&gt;; it cannot be parameterized with arguments &lt;?, Serializable&gt;
</span><span class=c1></span><span class=o>}</span>
</code></pre></td></tr></table></div></div><p>泛型参数<code>T</code>也可以指定上界，但只能用于声明泛型的场景，这是和通配符的一个重要区别之一：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 用T声明一个有上界的泛型方法
</span><span class=c1></span><span class=kd>public</span> <span class=o>&lt;</span><span class=n>T</span> <span class=kd>extends</span> <span class=n>Serializable</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// 编译错误
</span><span class=c1></span>    <span class=n>List</span><span class=o>&lt;</span><span class=n>T</span> <span class=kd>extends</span> <span class=n>Serializable</span><span class=o>&gt;</span> <span class=n>list1</span><span class=o>;</span>  <span class=c1>// Incorrect number of arguments for type List&lt;E&gt;; it cannot be parameterized with arguments &lt;T, Serializable&gt;
</span><span class=c1></span>    
    <span class=n>List</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>Serializable</span><span class=o>&gt;</span> <span class=n>list2</span><span class=o>;</span>  <span class=c1>// ok
</span><span class=c1></span><span class=o>}</span>
</code></pre></td></tr></table></div></div><h3 id=下界通配符-super-t>下界通配符<code>&lt;? super T></code></h3><p>使用下界通配符可以将实际类型参数限制为指定的类型或者指定类型的父类，经过泛型擦除后，下界通配符会被擦除成Object类型，但是在编译期不允许传入非指定类型或其父类以外的类型。</p><p>泛型参数<code>T</code>不可以指定下界，这是和通配符的另一个区别：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 编译错误
</span><span class=c1></span><span class=kd>public</span> <span class=o>&lt;</span><span class=n>T</span> <span class=kd>super</span> <span class=n>Serializable</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>  <span class=c1>// Syntax error on token &#34;super&#34;, , expected
</span><span class=c1></span>    
<span class=o>}</span>
</code></pre></td></tr></table></div></div><h3 id=pecs原则>PECS原则</h3><p>当泛型集合使用了有边界的通配符时，存在PECS原则（Producer Extends Consumer Super），如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>TestGeneric</span> <span class=o>{</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=nf>main</span><span class=o>(</span><span class=n>String</span><span class=o>[]</span> <span class=n>args</span><span class=o>)</span> <span class=o>{</span>
        <span class=n>List</span><span class=o>&lt;</span><span class=n>Dog</span><span class=o>&gt;</span> <span class=n>dogs</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>
        <span class=n>dogs</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Dog</span><span class=o>());</span>

        <span class=c1>// 上界通配符泛型集合
</span><span class=c1></span>        <span class=n>List</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>Animal</span><span class=o>&gt;</span> <span class=n>list1</span> <span class=o>=</span> <span class=n>dogs</span><span class=o>;</span>

        <span class=cm>/* 往上界通配符泛型集合添加元素 */</span>
        <span class=c1>// 编译错误，不能加入null以外的任意类型对象
</span><span class=c1></span>        <span class=n>list1</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Dog</span><span class=o>());</span>  <span class=c1>// The method add(capture#1-of ? extends Animal) in the type List&lt;capture#1-of ? extends Animal&gt; is not applicable for the arguments (Dog)
</span><span class=c1></span>        <span class=c1>// 编译错误，不能加入null以外的任意类型对象
</span><span class=c1></span>        <span class=n>list1</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Animal</span><span class=o>());</span>  <span class=c1>// The method add(capture#2-of ? extends Animal) in the type List&lt;capture#2-of ? extends Animal&gt; is not applicable for the arguments (Animal)
</span><span class=c1></span>        <span class=n>list1</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=kc>null</span><span class=o>);</span>  <span class=c1>// ok
</span><span class=c1></span>
        <span class=cm>/* 从上界通配符泛型集合获取元素 */</span>
        <span class=c1>// 获取的元素默认是上界类型
</span><span class=c1></span>        <span class=n>Animal</span> <span class=n>animal</span> <span class=o>=</span> <span class=n>list1</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>);</span>  <span class=c1>// ok
</span><span class=c1></span>        <span class=c1>// 强转为原来的类型
</span><span class=c1></span>        <span class=n>Dog</span> <span class=n>dog</span> <span class=o>=</span> <span class=o>(</span><span class=n>Dog</span><span class=o>)</span> <span class=n>list1</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>);</span>  <span class=c1>// ok
</span><span class=c1></span>
        <span class=c1>// ----------------------------
</span><span class=c1></span>        <span class=c1>// 下界通配符泛型集合
</span><span class=c1></span>        <span class=n>List</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>Dog</span><span class=o>&gt;</span> <span class=n>list2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>

        <span class=cm>/* 往下界通配符泛型集合添加元素 */</span>
        <span class=c1>// 编译错误，只能加入下界类型及其子类型
</span><span class=c1></span>        <span class=n>list2</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Animal</span><span class=o>());</span>  <span class=c1>// The method add(capture#6-of ? super Dog) in the type List&lt;capture#6-of ? super Dog&gt; is not applicable for the arguments (Animal)
</span><span class=c1></span>        <span class=n>list2</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>Dog</span><span class=o>());</span>  <span class=c1>// ok
</span><span class=c1></span>        <span class=n>list2</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=k>new</span> <span class=n>BigDog</span><span class=o>());</span>  <span class=c1>// ok
</span><span class=c1></span>        <span class=n>list2</span><span class=o>.</span><span class=na>add</span><span class=o>(</span><span class=kc>null</span><span class=o>);</span>  <span class=c1>// ok
</span><span class=c1></span>
        <span class=cm>/* 从下界通配符泛型集合获取元素 */</span>
        <span class=c1>// 获取的元素默认是Object类型
</span><span class=c1></span>        <span class=n>Object</span> <span class=n>object</span> <span class=o>=</span> <span class=n>list2</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>);</span>  <span class=c1>// ok
</span><span class=c1></span>        <span class=c1>// 强转为原来的类型
</span><span class=c1></span>        <span class=n>dog</span> <span class=o>=</span> <span class=o>(</span><span class=n>Dog</span><span class=o>)</span> <span class=n>list2</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>0</span><span class=o>);</span>  <span class=c1>// ok
</span><span class=c1></span>        <span class=n>BigDog</span> <span class=n>bigDog</span> <span class=o>=</span> <span class=o>(</span><span class=n>BigDog</span><span class=o>)</span> <span class=n>list2</span><span class=o>.</span><span class=na>get</span><span class=o>(</span><span class=n>1</span><span class=o>);</span>  <span class=c1>// ok
</span><span class=c1></span>    <span class=o>}</span>

<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>对于上界通配符的泛型集合，不允许添加null以外的任何类型对象，因为泛型擦除导致JVM无法确定该集合究竟存放了什么类型的元素，只知道集合里的元素都是上界类型或者上界类型的子类型，这意味着无论被添加的元素是哪种类型，都无法确保安全的类型转换（比如集合里可能存的是Dog类型或者Animal类型，而被添加的类型如果是Cat类型就会发生类转型异常），所以会拒绝添加null以外的任意元素。而null是一个特殊的值，它可以转型为任意类型，因此能成功添加到上界通配符的泛型集合中。</p><p>但是这种集合可以往外读取元素，因为这些元素可以被JVM自动转型为上界类型。这种只允许读取，不允许写入的特性，被称为<code>Producer Extends</code>，相当于生产者的概念。</p><p>对于下界通配符的泛型集合，只能加入下界类型及其子类型，因为泛型擦除导致JVM只知道该集合中存放的都是下界类型或者下界类型的父类型，而下界类型及其子类型必然可以安全转型为下界类型，所以可以添加到该集合中。</p><p>但是这种集合只允许往外读取Object类型的元素，因为无法确定集合中的元素的具体类型，出于类型安全就只能作为Object类型被读取。如果将读取的元素进行强制类型转换，就要注意是否会发生类转换异常。这种只允许写入，不允许读取为原本类型的特性，被称为<code>Consumer Super</code>，相当于消费者的概念。</p><p>总结：</p><p>● 如果要从集合中读取类型<code>T</code>的数据，并且不能写入，可以使用<code>? extends T</code>通配符；(Producer Extends)<br>● 如果要从集合中写入类型<code>T</code>的数据，并且不需要读取，可以使用<code>? super T</code>通配符；(Consumer Super)<br>● 如果既要存又要取，那么就不要使用任何通配符。</p><p>在实际应用中，一般不直接对通配符泛型集合进行编辑操作，而是作为一个引用类型（可以是局部变量，或者是作为方法参数），并将另一个泛型集合对象赋值给该引用。</p><h3 id=泛型的多重限定>泛型的多重限定</h3><p>泛型允许使用<code>&</code>进行多重限定，即<code>&lt;T extends A & B></code>，此时泛型的具体类型必须是这两个限定类型的最小范围或者共同子类型。并且，<code>&</code>的右值必须是接口，左值则没有这个要求。</p><p>此外，通配符<code>&lt;?></code>不可以使用多重限定。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=o>&lt;</span><span class=n>T</span> <span class=kd>extends</span> <span class=n>List</span> <span class=o>&amp;</span> <span class=n>Collection</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=nf>test1</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>  <span class=c1>// ok
</span><span class=c1></span>    
<span class=o>}</span>

<span class=c1>// 编译错误，Animal不是接口
</span><span class=c1></span><span class=kd>public</span> <span class=o>&lt;</span><span class=n>T</span> <span class=kd>extends</span> <span class=n>Dog</span> <span class=o>&amp;</span> <span class=n>Animal</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=nf>test2</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>  <span class=c1>// The type Animal is not an interface; it cannot be specified as a bounded parameter
</span><span class=c1></span>    
<span class=o>}</span>

<span class=c1>// 编译错误
</span><span class=c1></span><span class=kd>public</span> <span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>List</span> <span class=o>&amp;</span> <span class=n>Collection</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=nf>test3</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>  <span class=c1>// Syntax error on token &#34;?&#34;, Identifier expected
</span><span class=c1></span>    
<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>经过泛型擦除后，在字节码文件中多重限定会被擦除为<code>&</code>的左值类型，但在编译期时类型检查依然限定具体类型必须是这两个限定类型的最小范围或者共同子类型。</p><h3 id=t和的区别><code>&lt;T></code>和<code>&lt;?></code>的区别</h3><p>● <code>&lt;T></code>可以用于声明泛型，也可用于使用泛型的场合；<code>&lt;?></code>不可用于声明泛型，只能用于使用泛型的场合。<br>● <code>&lt;T></code>可以指定上界，但此时只能用于声明泛型，<code>&lt;T></code>不可以指定下界；<code>&lt;?></code>可指定上下界，且只能用于使用泛型的场合。<br>● <code>&lt;T></code>用于确保泛型参数的一致性，比如一个方法的参数是多个泛型<code>T</code>，那么调用方法传参时都必须是相同的类型；但如果一个方法的参数是多个泛型通配符<code>?</code>，则调用时传参不需要保持相同的类型，因为<code>?</code>表示随机类型。<br>● <code>&lt;T></code>可以使用多重限定，而<code>&lt;?></code>不可以。<br>● <code>&lt;T></code>无法创建参数化类型的数组，但<code>&lt;?></code>可以。</p><h2 id=泛型数组>泛型数组</h2><p>跟前面的泛型集合特性一样，只是把泛型集合塞到一个数组中而已。但不同的是，无法实例化一个参数化类型的数组对象，但可以实例化一个通配符类型的数组对象。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;[]</span> <span class=n>array1</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>[</span><span class=n>10</span><span class=o>];</span>  <span class=c1>// ok
</span><span class=c1></span>    <span class=n>array1</span><span class=o>[</span><span class=n>0</span><span class=o>].</span><span class=na>add</span><span class=o>(</span><span class=s>&#34;test&#34;</span><span class=o>);</span>  <span class=c1>// ok
</span><span class=c1></span>    
    <span class=c1>// 编译错误
</span><span class=c1></span>    <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;[]</span> <span class=n>array2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;[</span><span class=n>10</span><span class=o>];</span>  <span class=c1>// Cannot create a generic array of ArrayList&lt;String&gt;
</span><span class=c1></span>    
    <span class=n>List</span><span class=o>&lt;?&gt;[]</span> <span class=n>array3</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;?&gt;[</span><span class=n>10</span><span class=o>];</span>  <span class=c1>// ok
</span><span class=c1></span>    <span class=n>array3</span><span class=o>[</span><span class=n>0</span><span class=o>]</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;();</span>  <span class=c1>// ok
</span><span class=c1></span>    <span class=c1>// 编译错误
</span><span class=c1></span>    <span class=n>array3</span><span class=o>[</span><span class=n>0</span><span class=o>].</span><span class=na>add</span><span class=o>(</span><span class=s>&#34;test&#34;</span><span class=o>);</span>  <span class=c1>// The method add(capture#2-of ?) in the type List&lt;capture#2-of ?&gt; is not applicable for the arguments (String)
</span><span class=c1></span>    <span class=n>array3</span><span class=o>[</span><span class=n>0</span><span class=o>].</span><span class=na>add</span><span class=o>(</span><span class=kc>null</span><span class=o>);</span>  <span class=c1>// ok
</span><span class=c1></span><span class=o>}</span>
</code></pre></td></tr></table></div></div><h2 id=不能使用泛型的场景>不能使用泛型的场景</h2><h3 id=基本类型不能使用泛型>基本类型不能使用泛型</h3><p>泛型的类型参数要求是Object的子类，所以不能使用基本数据类型，只能使用对应的包装类。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=n>List</span><span class=o>&lt;</span><span class=kt>int</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>  <span class=c1>// Syntax error, insert &#34;Dimensions&#34; to complete ReferenceType
</span><span class=c1></span>
<span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;&gt;();</span>  <span class=c1>// ok
</span></code></pre></td></tr></table></div></div><h3 id=泛型类型无法直接实例化>泛型类型无法直接实例化</h3><p>由于泛型擦除的原因，运行期泛型信息是不可见的，因此不能直接实例化。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 运行期不存在这个泛型E，所以无法实例化
</span><span class=c1></span><span class=kd>public</span> <span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
    <span class=n>E</span> <span class=n>e2</span> <span class=o>=</span> <span class=k>new</span> <span class=n>E</span><span class=o>();</span>  <span class=c1>// Cannot instantiate the type E
</span><span class=c1></span><span class=o>}</span>
</code></pre></td></tr></table></div></div><h3 id=泛型类的泛型参数不能作为静态变量也不能作为静态方法的返回值>泛型类的泛型参数不能作为静态变量，也不能作为静态方法的返回值</h3><p>泛型类在类实例化时才明确类型，而静态类型是在类加载时就初始化的，此时对于泛型类是无法明确泛型的具体类型的，所以泛型类的泛型参数不能作为静态变量。也就是说，泛型类的泛型参数默认就是非静态的。</p><p>但是，对于泛型方法，则可以被定义为静态的。原因是泛型方法在方法调用时明确类型，与类实例化无关，所以允许定义为静态的。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>TestGeneric</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=n>T</span> <span class=n>t1</span><span class=o>;</span>  <span class=c1>// ok
</span><span class=c1></span>    
    <span class=kd>static</span> <span class=n>T</span> <span class=n>t2</span><span class=o>;</span>  <span class=c1>// Cannot make a static reference to the non-static type T
</span><span class=c1></span>    
    <span class=kd>static</span> <span class=o>{</span>
        <span class=n>T</span> <span class=n>t3</span><span class=o>;</span>  <span class=c1>// Cannot make a static reference to the non-static type T
</span><span class=c1></span>    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=n>T</span> <span class=nf>getT</span><span class=o>(</span><span class=n>T</span> <span class=n>t</span><span class=o>)</span> <span class=o>{</span>  <span class=c1>// Cannot make a static reference to the non-static type T
</span><span class=c1></span>        <span class=k>return</span> <span class=n>t</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=kd>public</span> <span class=kd>static</span> <span class=o>&lt;</span><span class=n>E</span><span class=o>&gt;</span> <span class=n>E</span> <span class=nf>getE</span><span class=o>(</span><span class=n>E</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>  <span class=c1>// ok
</span><span class=c1></span>        <span class=k>return</span> <span class=n>e</span><span class=o>;</span>
    <span class=o>}</span>
    
<span class=o>}</span>
</code></pre></td></tr></table></div></div><h3 id=无法进行-instanceof-判断>无法进行 instanceof 判断</h3><p>Java的泛型是伪泛型，在编译期会被擦除，运行的字节码中不存在泛型，所以下面的判断条件无法进行：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>TestGeneric</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>(</span><span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>)</span> <span class=o>{</span>
        <span class=c1>// Cannot perform instanceof check against parameterized type ArrayList&lt;Integer&gt;. 
</span><span class=c1></span>        <span class=c1>// Use the form ArrayList&lt;?&gt; instead since further generic type information will be erased at runtime
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>list</span> <span class=k>instanceof</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;)</span> <span class=o>{</span>
            
        <span class=o>}</span>

		<span class=c1>// 编译报错
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>list</span> <span class=k>instanceof</span> <span class=n>ArrayList</span><span class=o>&lt;?</span> <span class=kd>super</span> <span class=n>Animal</span><span class=o>&gt;)</span> <span class=o>{</span>
            
        <span class=o>}</span>

		<span class=c1>// 编译报错
</span><span class=c1></span>        <span class=k>if</span> <span class=o>(</span><span class=n>list</span> <span class=k>instanceof</span> <span class=n>ArrayList</span><span class=o>&lt;?</span> <span class=kd>extends</span> <span class=n>Animal</span><span class=o>&gt;)</span> <span class=o>{</span>
            
        <span class=o>}</span>
    <span class=o>}</span>

<span class=o>}</span>
</code></pre></td></tr></table></div></div><p>但是泛型的无界通配符<code>&lt;?></code>可以进行<code>instanceof</code>判断，<strong>且只有无界通配符才可以用这个关键字判断，如果是有界通配符依然会编译报错</strong>。</p><p>因为无界通配符类型的集合对象意味着可以是任意类型的集合，对于JVM来说都是同一个集合类型,无需具体区分是哪一种泛型集合，所以允许无界通配符使用<code>instanceof</code>进行判断。</p><h3 id=无法创建参数化类型的数组>无法创建参数化类型的数组</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=o>{</span>
    <span class=c1>// 编译错误
</span><span class=c1></span>    <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;[]</span> <span class=n>array</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;[</span><span class=n>10</span><span class=o>];</span>  <span class=c1>// Cannot create a generic array of ArrayList&lt;String&gt;
</span><span class=c1></span><span class=o>}</span>
</code></pre></td></tr></table></div></div><p>因为在运行期泛型集合对于JVM来说都是同一种类型，这意味着对于一个泛型集合数组对象来说，无论放入的是<code>ArrayList&lt;String></code>还是<code>ArrayList&lt;Integer></code>都是一样的。这样就会和本身泛型集合数组的定义相矛盾，比如原本声明的是一个<code>List&lt;String>[]</code>。为了避免发生这种逻辑错误，所以不允许创建参数化类型的数组。</p><p>但是可以创建通配符类型的数据，因为通配符类型是一个随机的类型，不会发生上述的自相矛盾：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=o>{</span>
    <span class=n>List</span><span class=o>&lt;?&gt;[]</span> <span class=n>array</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ArrayList</span><span class=o>&lt;?&gt;[</span><span class=n>10</span><span class=o>];</span>  <span class=c1>// ok
</span><span class=c1></span><span class=o>}</span>
</code></pre></td></tr></table></div></div><h3 id=不能直接或者间接扩展throwable>不能直接或者间接扩展Throwable</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=c1>// 不能间接地扩展 Throwable   
</span><span class=c1></span><span class=kd>class</span> <span class=nc>IndirectException</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>Exception</span> <span class=o>{}</span>  <span class=c1>// The generic class IndirectException&lt;T&gt; may not subclass java.lang.Throwable
</span><span class=c1></span>
<span class=c1>// 不能直接地扩展 Throwable  
</span><span class=c1></span><span class=kd>class</span> <span class=nc>DirectException</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>Throwable</span> <span class=o>{}</span>  <span class=c1>// The generic class DirectException&lt;T&gt; may not subclass java.lang.Throwable
</span></code></pre></td></tr></table></div></div><p>因为异常类在进行捕获时需要明确类型，在运行期JVM无法获取泛型异常的类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=k>try</span> <span class=o>{</span>
    
<span class=o>}</span> <span class=k>catch</span> <span class=o>(</span><span class=n>IndirectException</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=o>|</span> <span class=n>DirectException</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span> <span class=n>e</span><span class=o>)</span> <span class=o>{</span>
    <span class=c1>// 类型不确定，无法处理具体的异常逻辑
</span><span class=c1></span><span class=o>}</span>
</code></pre></td></tr></table></div></div><p>但是可以抛出一个不确定的异常类型：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>class</span> <span class=nc>TestGeneric</span><span class=o>&lt;</span><span class=n>T</span> <span class=kd>extends</span> <span class=n>Exception</span><span class=o>&gt;</span> <span class=o>{</span>

	<span class=c1>// ok
</span><span class=c1></span>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>test1</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>T</span> <span class=o>{</span>
        
    <span class=o>}</span>
    
	<span class=c1>// ok
</span><span class=c1></span>    <span class=kd>public</span> <span class=o>&lt;</span><span class=n>E</span> <span class=kd>extends</span> <span class=n>Exception</span><span class=o>&gt;</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>()</span> <span class=kd>throws</span> <span class=n>E</span> <span class=o>{</span>
        
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><h3 id=泛型擦除后相同参数签名的方法不能重载>泛型擦除后相同参数签名的方法不能重载</h3><p>由于泛型擦除的原因，以下方法不能重载且会编译报错</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Integer</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>)</span> <span class=o>{}</span>
<span class=kd>public</span> <span class=kt>void</span> <span class=nf>test</span><span class=o>(</span><span class=n>List</span><span class=o>&lt;</span><span class=n>Long</span><span class=o>&gt;</span> <span class=n>list</span><span class=o>)</span> <span class=o>{}</span>
</code></pre></td></tr></table></div></div><h2 id=一道笔试题>一道笔试题</h2><p>如何使用泛型实现LRU缓存？</p><p>LRU就是<code>Least Recently Used</code>的缩写，即最近最少使用。JAVA提供的<code>LinkedHashMap</code>可以拿来实现LRU缓存的功能，除了可以设定排序的模式（按照访问排序还是按照插入排序），还可以重写删除最旧键值对的方法：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre class=chroma><code class=language-java data-lang=java><span class=kd>public</span> <span class=kd>class</span> <span class=nc>LRUCache</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span> <span class=n>V</span><span class=o>&gt;</span> <span class=kd>extends</span> <span class=n>LinkedHashMap</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span> <span class=n>V</span><span class=o>&gt;</span> <span class=o>{</span>

    <span class=kd>private</span> <span class=kt>int</span> <span class=n>size</span><span class=o>;</span>

    <span class=kd>public</span> <span class=nf>LRUCache</span><span class=o>(</span><span class=kt>int</span> <span class=n>size</span><span class=o>)</span> <span class=o>{</span>
		<span class=c1>// 16是初始化容量，0.75是负载因子，true表示按照访问排序
</span><span class=c1></span>        <span class=kd>super</span><span class=o>(</span><span class=n>16</span><span class=o>,</span> <span class=o>(</span><span class=kt>float</span><span class=o>)</span> <span class=n>0</span><span class=o>.</span><span class=na>75</span><span class=o>,</span> <span class=kc>true</span><span class=o>);</span>
        <span class=k>this</span><span class=o>.</span><span class=na>size</span> <span class=o>=</span> <span class=n>size</span><span class=o>;</span>
    <span class=o>}</span>

    <span class=nd>@Override</span>
    <span class=c1>// 该方法会在`put`和`putAll`插入元素之后自行调用，返回true表示应该删除最旧的元素。
</span><span class=c1></span>    <span class=kd>protected</span> <span class=kt>boolean</span> <span class=nf>removeEldestEntry</span><span class=o>(</span><span class=n>java</span><span class=o>.</span><span class=na>util</span><span class=o>.</span><span class=na>Map</span><span class=o>.</span><span class=na>Entry</span><span class=o>&lt;</span><span class=n>K</span><span class=o>,</span> <span class=n>V</span><span class=o>&gt;</span> <span class=n>eldest</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>return</span> <span class=n>size</span><span class=o>()</span> <span class=o>&gt;</span> <span class=n>size</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></td></tr></table></div></div><h2 id=参考链接>参考链接</h2><ul><li><a href="http://cyc2018.gitee.io/cs-notes/#/notes/Java%20%E5%9F%BA%E7%A1%80?id=%e4%b9%9d%e3%80%81%e6%b3%9b%e5%9e%8b" target=_blank rel="noopener noreffer">九、泛型</a></li><li><a href=https://blog.csdn.net/xx326664162/article/details/52175283 target=_blank rel="noopener noreffer">Java泛型中的PECS原则</a></li><li><a href=https://imlql.cn/post/adb2faf0.html#post-comment target=_blank rel="noopener noreffer">万字长文详解Java泛型</a></li><li><a href=https://juejin.cn/post/6844904150514286599 target=_blank rel="noopener noreffer">什么情况下不能使用 Java 泛型</a></li><li><a href=https://www.zhihu.com/question/272185241 target=_blank rel="noopener noreffer">什么叫泛型？有什么作用？</a></li><li><a href=https://blog.csdn.net/wang_muhuo/article/details/80390655 target=_blank rel="noopener noreffer">使用泛型实现（LRU）缓存</a></li></ul><div class=post-reward><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/common/wechat.png>
<span>微信打赏</span></label>
<label class=qr-code-image for=reward><img class=image src=https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/common/alipay.png>
<span>支付宝打赏</span></label></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2021-05-24</span></div><div class=post-info-license><span><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/posts/java-generic.html/index.md target=_blank>阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://lewky.cn/posts/java-generic.html/ data-title="Java - 泛型" data-hashtags=Java><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://lewky.cn/posts/java-generic.html/ data-hashtag=Java><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://lewky.cn/posts/java-generic.html/ data-title="Java - 泛型"><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title="分享到 Line" data-sharer=line data-url=https://lewky.cn/posts/java-generic.html/ data-title="Java - 泛型"><i data-svg-src=https://cdn.jsdelivr.net/npm/simple-icons@2.14.0/icons/line.svg></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://lewky.cn/posts/java-generic.html/ data-title="Java - 泛型"><i class="fab fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/java/>Java</a></section><section><span><a href=javascript:void(0); onclick=window.history.back();>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/plantuml-class-diagram.html/ class=prev rel=prev title="PlantUML - 类图"><i class="fas fa-angle-left fa-fw"></i>PlantUML - 类图</a>
<a href=/posts/hugo-3.1.html/ class=next rel=next title="Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章">Hugo系列(3.1) - LoveIt主题美化与博客功能增强 · 第二章<i class="fas fa-angle-right fa-fw"></i></a></div></div><div id=comments></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><span id=run-time></span>|
<a href=http://rssblog.vercel.app/ target=_blank rel=noopener title=RSSBlog><i class="fas fa-fw fa-inbox"></i>&nbsp;RSSBlog</a></div><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2018 - 2021</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=/ target=_blank>雨临Lewis</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span><span class=icp-splitter>&nbsp;|&nbsp;</span><br class=icp-br><span class=icp><a target=_blank href=http://www.beian.miit.gov.cn/ style=font-weight:700>粤ICP备19103822</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i></a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><div class=sidebar_wo><div id=leimu><img src=https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/b2t/leimuA.png alt=雷姆 onmouseover="this.src='https:\/\/cdn.jsdelivr.net\/gh\/lewky\/lewky.github.io@master/images/b2t/leimuB.png'" onmouseout="this.src='https:\/\/cdn.jsdelivr.net\/gh\/lewky\/lewky.github.io@master/images/b2t/leimuA.png'" title=回到顶部></div><div class=sidebar_wo id=lamu><img src=https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master/images/b2t/lamuA.png alt=雷姆 onmouseover="this.src='https:\/\/cdn.jsdelivr.net\/gh\/lewky\/lewky.github.io@master/images/b2t/lamuB.png'" onmouseout="this.src='https:\/\/cdn.jsdelivr.net\/gh\/lewky\/lewky.github.io@master/images/b2t/lamuA.png'" title=回到底部></div></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/css/lightgallery.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lightgallery.js@1.2.0/dist/js/lightgallery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-thumbnail.js@1.2.0/dist/lg-thumbnail.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lg-zoom.js@1.2.0/dist/lg-zoom.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js></script><script type=text/javascript>window.config={"code":{"copyTitle":"复制到剪贴板","maxShownLines":30},"comment":{},"lightGallery":{"actualSize":false,"exThumbImage":"data-thumbnail","hideBarsDelay":2000,"selector":".lightgallery","speed":400,"thumbContHeight":80,"thumbWidth":80,"thumbnail":true}};</script><script type=text/javascript src=/js/theme.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/jquery@2.1.3/dist/jquery.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/jquery-backstretch@2.1.18/jquery.backstretch.min.js></script><script>$(function(){$(".site-avatar-plug-bilibili").attr("src","https:\/\/cdn.jsdelivr.net\/gh\/lewky\/lewky.github.io@master/images/avatar-plug/bilibili_"+(~~(128*Math.random())+1)+".png");});var avatar_plug=0;var avatar_click=1;jQuery(document).ready(function($){var frequency=1;var plug_count=128;$("div.home-avatar a").click(function(e){if(avatar_click%frequency===0){avatar_plug++;$(".site-avatar-plug-bilibili").attr("src","https:\/\/cdn.jsdelivr.net\/gh\/lewky\/lewky.github.io@master/images/avatar-plug/bilibili_"+avatar_plug+".png");}
if(avatar_plug===plug_count){avatar_plug=0;}
$("div.home-avatar a").attr("alt","再点击"+(frequency-avatar_click%frequency)+"次头像试试看~~");avatar_click++;});});</script><script>var $cdnPrefix="https://cdn.jsdelivr.net/gh/lewky/lewky.github.io@master";</script><script type=text/javascript src=/js/custom.js></script><script>var _hmt=_hmt||[];(function(){var hm=document.createElement("script");hm.src="https://hm.baidu.com/hm.js?6f278ed0fdb01edb3b1e7398379e5432";var s=document.getElementsByTagName("script")[0];s.parentNode.insertBefore(hm,s);})();</script></body></html>